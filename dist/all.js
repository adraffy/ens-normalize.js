// created 2024-09-11T06:52:01.120Z
// compressed base64-encoded blob for include-ens data
// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js
// see: https://github.com/adraffy/ens-normalize.js#security
// SHA-256: 76ededceb442d548f92752e3e49e5fd44f537436c8231a5212aecd3aac4db0bf
var COMPRESSED$1 = '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';
const FENCED = new Map([[8217,"apostrophe"],[8260,"fraction slash"],[12539,"middle dot"]]);
const NSM_MAX = 4;

function decode_arithmetic(bytes) {
	let pos = 0;
	function u16() { return (bytes[pos++] << 8) | bytes[pos++]; }
	
	// decode the frequency table
	let symbol_count = u16();
	let total = 1;
	let acc = [0, 1]; // first symbol has frequency 1
	for (let i = 1; i < symbol_count; i++) {
		acc.push(total += u16());
	}

	// skip the sized-payload that the last 3 symbols index into
	let skip = u16();
	let pos_payload = pos;
	pos += skip;

	let read_width = 0;
	let read_buffer = 0; 
	function read_bit() {
		if (read_width == 0) {
			// this will read beyond end of buffer
			// but (undefined|0) => zero pad
			read_buffer = (read_buffer << 8) | bytes[pos++];
			read_width = 8;
		}
		return (read_buffer >> --read_width) & 1;
	}

	const N = 31;
	const FULL = 2**N;
	const HALF = FULL >>> 1;
	const QRTR = HALF >> 1;
	const MASK = FULL - 1;

	// fill register
	let register = 0;
	for (let i = 0; i < N; i++) register = (register << 1) | read_bit();

	let symbols = [];
	let low = 0;
	let range = FULL; // treat like a float
	while (true) {
		let value = Math.floor((((register - low + 1) * total) - 1) / range);
		let start = 0;
		let end = symbol_count;
		while (end - start > 1) { // binary search
			let mid = (start + end) >>> 1;
			if (value < acc[mid]) {
				end = mid;
			} else {
				start = mid;
			}
		}
		if (start == 0) break; // first symbol is end mark
		symbols.push(start);
		let a = low + Math.floor(range * acc[start]   / total);
		let b = low + Math.floor(range * acc[start+1] / total) - 1;
		while (((a ^ b) & HALF) == 0) {
			register = (register << 1) & MASK | read_bit();
			a = (a << 1) & MASK;
			b = (b << 1) & MASK | 1;
		}
		while (a & ~b & QRTR) {
			register = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();
			a = (a << 1) ^ HALF;
			b = ((b ^ HALF) << 1) | HALF | 1;
		}
		low = a;
		range = 1 + b - a;
	}
	let offset = symbol_count - 4;
	return symbols.map(x => { // index into payload
		switch (x - offset) {
			case 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);
			case 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);
			case 1: return offset + bytes[pos_payload++];
			default: return x - 1;
		}
	});
}	

// returns an iterator which returns the next symbol
function read_payload(v) {
	let pos = 0;
	return () => v[pos++];
}
function read_compressed_payload(s) {
	return read_payload(decode_arithmetic(unsafe_atob(s)));
}

// unsafe in the sense:
// expected well-formed Base64 w/o padding 
// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4
function unsafe_atob(s) {
	let lookup = [];
	[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
	let n = s.length;
	let ret = new Uint8Array((6 * n) >> 3);
	for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
		carry = (carry << 6) | lookup[s.charCodeAt(i)];
		width += 6;
		if (width >= 8) {
			ret[pos++] = (carry >> (width -= 8));
		}
	}
	return ret;
}

// eg. [0,1,2,3...] => [0,-1,1,-2,...]
function signed(i) { 
	return (i & 1) ? (~i >> 1) : (i >> 1);
}

function read_deltas(n, next) {
	let v = Array(n);
	for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());
	return v;
}

// [123][5] => [0 3] [1 1] [0 0]
function read_sorted(next, prev = 0) {
	let ret = [];
	while (true) {
		let x = next();
		let n = next();
		if (!n) break;
		prev += x;
		for (let i = 0; i < n; i++) {
			ret.push(prev + i);
		}
		prev += n + 1;
	}
	return ret;
}

function read_sorted_arrays(next) {
	return read_array_while(() => { 
		let v = read_sorted(next);
		if (v.length) return v;
	});
}

// returns map of x => ys
function read_mapped(next) {
	let ret = [];
	while (true) {
		let w = next();
		if (w == 0) break;
		ret.push(read_linear_table(w, next));
	}
	while (true) {
		let w = next() - 1;
		if (w < 0) break;
		ret.push(read_replacement_table(w, next));
	}
	return ret.flat();
}

// read until next is falsy
// return array of read values
function read_array_while(next) {
	let v = [];
	while (true) {
		let x = next(v.length);
		if (!x) break;
		v.push(x);
	}
	return v;
}

// read w columns of length n
// return as n rows of length w
function read_transposed(n, w, next) {
	let m = Array(n).fill().map(() => []);
	for (let i = 0; i < w; i++) {
		read_deltas(n, next).forEach((x, j) => m[j].push(x));
	}
	return m;
}
 
// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]
// where dx/dy = steps, n = run size, w = length of y
function read_linear_table(w, next) {
	let dx = 1 + next();
	let dy = next();
	let vN = read_array_while(next);
	let m = read_transposed(vN.length, 1+w, next);
	return m.flatMap((v, i) => {
		let [x, ...ys] = v;
		return Array(vN[i]).fill().map((_, j) => {
			let j_dy = j * dy;
			return [x + j * dx, ys.map(y => y + j_dy)];
		});
	});
}

// return [[x, ys...], ...]
// where w = length of y
function read_replacement_table(w, next) { 
	let n = 1 + next();
	let m = read_transposed(n, 1+w, next);
	return m.map(v => [v[0], v.slice(1)]);
}


function read_trie(next) {
	let ret = [];
	let sorted = read_sorted(next); 
	expand(decode([]), []);
	return ret; // not sorted
	function decode(Q) { // characters that lead into this node
		let S = next(); // state: valid, save, check
		let B = read_array_while(() => { // buckets leading to new nodes
			let cps = read_sorted(next).map(i => sorted[i]);
			if (cps.length) return decode(cps);
		});
		return {S, B, Q};
	}
	function expand({S, B}, cps, saved) {
		if (S & 4 && saved === cps[cps.length-1]) return;
		if (S & 2) saved = cps[cps.length-1];
		if (S & 1) ret.push(cps); 
		for (let br of B) {
			for (let cp of br.Q) {
				expand(br, [...cps, cp], saved);
			}
		}
	}
}

function hex_cp(cp) {
	return cp.toString(16).toUpperCase().padStart(2, '0');
}

function quote_cp(cp) {
	return `{${hex_cp(cp)}}`; // raffy convention: like "\u{X}" w/o the "\u"
}

/*
export function explode_cp(s) {
	return [...s].map(c => c.codePointAt(0));
}
*/
function explode_cp(s) { // this is about 2x faster
	let cps = [];
	for (let pos = 0, len = s.length; pos < len; ) {
		let cp = s.codePointAt(pos);
		pos += cp < 0x10000 ? 1 : 2;
		cps.push(cp);
	}
	return cps;
}

function str_from_cps(cps) {
	const chunk = 4096;
	let len = cps.length;
	if (len < chunk) return String.fromCodePoint(...cps);
	let buf = [];
	for (let i = 0; i < len; ) {
		buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
	}
	return buf.join('');
}

function compare_arrays(a, b) {
	let n = a.length;
	let c = n - b.length;
	for (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];
	return c;
}

function random_choice(v, rng = Math.random) {
	return v[rng() * v.length|0];
}

function random_sample(v, n, rng = Math.random) {
	v = v.slice(); // make copy
	if (v.length > n) {
		for (let i = 0; i < n; i++) { // shuffle prefix n
			let temp = v[i]; 
			let j = Math.floor(i + rng() * (v.length - i));
			v[i] = v[j];
			v[j] = temp;
		}
		v = v.slice(0, n); // truncate
	}
	return v;
}

function array_replace(v, a, b) {
	let prev = 0;
	while (true) {
		let next = v.indexOf(a, prev);
		if (next < 0) break;
		v[next] = b; 
		prev = next + 1;
	}
}

function run_tests(fn, tests) {
	let errors = [];
	for (let test of tests) {
		let {name, norm, error} = test;
		if (typeof norm !== 'string') norm = name;
		try {
			let result = fn(name);
			if (error) {	
				errors.push({type: 'expected error', result, ...test});
			} else if (result != norm) {
				errors.push({type: 'wrong norm', result, ...test});
			}
		} catch (err) {
			if (!error) {
				errors.push({type: 'unexpected error', result: err.message, ...test});
			}
		}
	}
	return errors;
}

// created 2024-09-11T06:52:01.120Z
// compressed base64-encoded blob for include-nf data
// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js
// see: https://github.com/adraffy/ens-normalize.js#security
// SHA-256: a79d5f9b1879a7b416aa659f4a3d788f80a8cf5f0ab955a456592c02f556a28c
var COMPRESSED = 'AEUDVgHLCGMATwDUADIAdAAhADQAFAAtABQAIQAPACcADQASAAoAGAAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAeYDMwCxCl8B8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobWgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vAITAdQZWxDzALN9AhsZVwIcGSkCBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rlr3JG9m8w9lIAXltp/v8kfWaIaaR9OwpAES/I3ZVamDXSgB/UsOgAG6D0tq+5CIqE15FiAhV3yA2VhCQ7tj+m6xXaF53FIfGi/IAZIskMGAi2MU7MDVJNCbMzERyHZi+osdPtnFVbvq653O8rwaCy4IAf9OOok65AqJUtUriUfYsGPPVbe6jm0s9lbKlPCUKjdkHsFsEhvX4kT39ZCtAAbwQdn/h4TpO5hTByWAmr5n+Wuwhdegv6bmvX4LyOes3z2+cuHv2JFYwVMNuq2gzn8YHTjlUQd39osyWei4NKl3LAdfxlO876hh5ENp/cOvpuI9bF55guEthLLPOXjD4dktTH04P5TvZrWTM0e4+BHJxj7MLApXIFOs0sWKhNkG8iwuM5wR83my6V3wW06abhDzTXYfOr/ZpFXgXzmv4d12FFyP00/dPGbIVGV5ao8UufGzUwp/IHx6v/wDWJr9iaoCulhWwlZ7A8q/NMoD12+mBdNRgJYnThRLtMx1Bgwttn8/4Qn2CDfOSup9GVXEvA21ILgp0owHYxNOkpwLWz0G7K+WREIDjIzUzSn8I99CuJSmSpPyH0Ke6/NERYiNx+3dncSebPnOUnnWD61AhJ1n/tSLZmU5wYO5GfgzyAYJm6VL91LxZ8hL1lfximQxIDMRhIecQZBmeE5R0XlrpvwplVrJwpa8BBCdp93GPP9lyBeZ2zkRr920CR3cYbKpKHfogvm0nV7XdDz6EbjzlxADCMjSLXuXpIpyuizy39yY+I+H9rmpoIF3YwEjlH9MgGgWcCNTjHEWMqAbprn2Ox7rOHupaVE3lNyg3nt5XaZID6Y+uml5Ja+aOPu+BI+DZbiJVfaspUadakWUX6TA4dETkIqdJJHYnU4Z4yKpt5y8rVIahoMUf8A8kWtAQNCTbjp71gx3/zVdqNz1Sutkw0gFIMVm2BF4Xdv/0olw+NaDIR9Bb3DPweZA2K/cw+/b+AwyWl9ZOP67A9nexmeTNjfdzPGf9J6E6BMPKa5lJh+qNsdUz3HBUevU71eQFCqOcxiIYhacAhh/8PX0J5DdSViZ6WazDDx7cukJNpMfEkYLJ5Ao4vLoVd3d25Pg4qaVa2p2D2L3WvYPJ5Yf/A/MSxptjlgXL/KJtP2U0cRv2I09ATAiWCJYuRwiapeKFsqmi18yMMulDp3HdcIldq+7jkwsJUOHLHCzzzBw5XFvL0CAmo1ub456z7zb7shk3KPGCLZzr47oT1k/j06XNnJvG3Udv6XrP+wsqTBlZ5MaNPt9FOs/4Bt/ja/vbVhTNpBFl9Gq7MqINvGlWKOAwQzwOZy+EzSdjAqKJVV2YcskTuM94aIK+kc/AZaXiZLPREUDpkXIV947IFfj+85TrqPqLfkGcxgboMQjosf+az+odLNXdyp1mDNGsqSdK/pJ2Ca04mt/4d6s1X+lncOEYaGBBeW4pApGcjf7/XJCFbj3N3mFb+BtlIcw8ZiDKoClFX9Rf0bxCqtLpicObKJzBVVHr/6u4siH2hK75RNv7w9GfTbhJOQBYiFUZAByY4rn37tZBHT//kqKsNi3ryL9AqXJRzqiMIJMhILjoi/i8LVEsbu+Ih9bsyW16sgQqjYLO0qda6KaCPKj3DQcu6CfV5lKtjS3ZCdqLAZkOey9MR+QutJBGiz/r15GVD6rCVwJR4UUKC4GNJkfDf00OMW8aQtLSAGLXV8MIi9mbbl/qQEpxCm2L5hutFX4ekeLH4QgBWUFKs/2VVMKy46WtFE6AbwgmYm/Z0yHk5veDIrcl2HpVqb/rSE0PC9EbDzJEWqeaPhh7vF369Umq2kSiB3s5rBI6c/7N9bkRu4h2n+/h5nSwy+7n+/I+6oXQVANo2Jb5zDwtiBPf1ySCzHdT6yJShMzqSRZfnykX49CaFaxhoVF4PBhEuECJ1PrFYSpmHuyYsl14DTAV9ZxRms1XiR/kBrjhZjidOt0UNe+GSml7XNgpVw8YsUTmZXLTK+6iYnyW/wYR1W4UXwOi14xpFROHb6HcZzksgF5DbL2AFXzKNwHU2adjdAY+KCyM/cwRTBkkq/a227NI0q6DR2MkMCRu620t79bGcYUmACtqN3mk/0uNwd3JSXHqE1kzf6Yyj0W2083JNDRnIXDlgBxJ6uf58NN1f6FQiRCWB4egF8QDx74AixV8oTyw7PluIjr3/rj/WzgwPSq4xPojaF7V0xqG2u5ti2L1h6yYHv73Isrukr0kURDIEjClBsBx7kdcXUxaYMS0syT3ymLzDzslNDWQOT1Tao1YNmJHARUenhCkmV9tqCPGI5GqZaRpkiPxyjoncWjyOHYGqvbvRX+Bn1pn7EhRNXa1lqJPmoeN5VqdqIDPhEVhFsyG0d4iQEIYX0wZUbY2XbZWYlpZ/l66IrDDY0q1C1YzBDpHC4h05YqHQLqS9anyl22JQ6lEvjvdBwMHfE7z0luCXD34/rFeDa2TmSeEAykSpYO5j1G/nsgpR3qn0qaQEmLjnnLfcz+veoYqPnRqmRGwCJ6FJ3Gm/Z1/aVX5PSb03MMnjAf41ww54sD5k8FrkfBP+K0b1MrYpapWjtpZfve2HVf4ickX3LKSOhu7qI1Vd4c1kNrn2ajy1t4y93JhV4fnWCKq7OmFpcr7FjdJCXPTql0Drr14Ho3Z87+GPQ4Z/DcTiGqtvZxlRYi8cNuhXABveZIwNl/BX1huhVLaFax5OqypUrQRyb9OE3SSkPlDdy5uo5XGg2EIGEjLY1MO5cr1ibfiFWV7zspcTgkBKkwo5jPyAin04LqizZXb2tDRgwKJjGx4cVk3ngAQixwcxjYAg2Q7vmUR/hpwInMdw7OhC2qyf41vTPkudQAORS0DdLtOGQxb4fH2VYGsvJCkeWPeUwtf1/tuIhzXEThoCZzzSJqqjUtbaPI3ntHm3T5uf849hGUA0zU8ni5W+EEn3/0Y6oUhQFw9z0aGjkljBbAlFXc0y82G2wkd7VdgWa5KTgJJNjNwZMfmdnUIUn1JU5LiWX5UZEZbVlKSN76mlmjUR2ku+fucTNlO4IAAahnLjBhlvQNR9pe9swGBgq0YR7P3VCyI/seYwQ4QBzy9X+HPePgoF8WfKaJ4MBOhLCGHae6Z8xkNXwni9QAKvTNtVA56x8YJflZ/VvONRSlsSLmiSyNMnTjTaE1ko81zkzGEnVwEhjCzlwIqpxmpDAqwsEmtpdr3xpc7i/ZX3f2TzT3M0FdxIEQvO1jgmmiN+D1YpMduAzEhBtj2OBkMN/rv6p7Th4pSH6f5aH3aTvwFTl7EOSgGASI7ttyMehzpm4AVyK+bFEaFg9gnZsSUPpsbAe/0RFhrH+EXZ12Z7thf4dzN1+Sn+G8QrDA1VKaN4IFxD1rQz9Xq9Coii9S9/hPbTGjyBwFH3H1UdQuz5KsgPDEHua4/kPg2Gp/IIItsaLWBqiT9XH45MiQxSosGJ56H/0F2cjcCFd72l1665RNHURdC3lspI77esfJsl+rXXabkAy7vxDXG/XGGcKpwiKDPFfvMEgjkAHil4Za1F36RnyxxvdIAzvgfH8knukYDck07tc++DP4TdWeI7HXuq5Yl6VVFrUQtf64/dkXewlKZSHQo6YvCSpREB0GDrz+Ys2GfO8nw2SwrYwaf88AifzlPvP17bf1mI3AuccJvAjZIpBmqvharKFAebEjVKfGAwpQjWoXlm9LROsq9bCk1UeQ3CJxJqprzssS/Q04JeS1ReCCubL3J7sx86spkP4eNpp95UF+8K748icIs8vdILFklk9skQqi1So6cx3X906pvy1vz+KipTJ8fiVJxsV5MmT0XwA';

// https://unicode.org/reports/tr15/
// for reference implementation
// see: /derive/nf.js


// algorithmic hangul
// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)
const S0 = 0xAC00;
const L0 = 0x1100;
const V0 = 0x1161;
const T0 = 0x11A7;
const L_COUNT = 19;
const V_COUNT = 21;
const T_COUNT = 28;
const N_COUNT = V_COUNT * T_COUNT;
const S_COUNT = L_COUNT * N_COUNT;
const S1 = S0 + S_COUNT;
const L1 = L0 + L_COUNT;
const V1 = V0 + V_COUNT;
const T1 = T0 + T_COUNT;

function unpack_cc(packed) {
	return (packed >> 24) & 0xFF;
}
function unpack_cp(packed) {
	return packed & 0xFFFFFF;
}

let SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;

// export function nf_deinit() {
// 	if (!SHIFTED_RANK) return;
// 	SHIFTED_RANK = EXCLUSIONS = DECOMP = RECOMP = undefined;
// }

function init$1() {
	//console.time('nf');
	let r = read_compressed_payload(COMPRESSED);
	SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted
	EXCLUSIONS = new Set(read_sorted(r));
	DECOMP = new Map();
	RECOMP = new Map();
	for (let [cp, cps] of read_mapped(r)) {
		if (!EXCLUSIONS.has(cp) && cps.length == 2) {
			let [a, b] = cps;
			let bucket = RECOMP.get(a);
			if (!bucket) {
				bucket = new Map();
				RECOMP.set(a, bucket);
			}
			bucket.set(b, cp);
		}
		DECOMP.set(cp, cps.reverse()); // stored reversed
	}
	//console.timeEnd('nf');
	// 20230905: 11ms
}

function is_hangul(cp) {
	return cp >= S0 && cp < S1;
}

function compose_pair(a, b) {
	if (a >= L0 && a < L1 && b >= V0 && b < V1) {
		return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
	} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {
		return a + (b - T0);
	} else {
		let recomp = RECOMP.get(a);
		if (recomp) {
			recomp = recomp.get(b);
			if (recomp) {
				return recomp;
			}
		}
		return -1;
	}
}

function decomposed(cps) {
	if (!SHIFTED_RANK) init$1();
	let ret = [];
	let buf = [];
	let check_order = false;
	function add(cp) {
		let cc = SHIFTED_RANK.get(cp);
		if (cc) {
			check_order = true;
			cp |= cc;
		}
		ret.push(cp);
	}
	for (let cp of cps) {
		while (true) {
			if (cp < 0x80) {
				ret.push(cp);
			} else if (is_hangul(cp)) {
				let s_index = cp - S0;
				let l_index = s_index / N_COUNT | 0;
				let v_index = (s_index % N_COUNT) / T_COUNT | 0;
				let t_index = s_index % T_COUNT;
				add(L0 + l_index);
				add(V0 + v_index);
				if (t_index > 0) add(T0 + t_index);
			} else {
				let mapped = DECOMP.get(cp);
				if (mapped) {
					buf.push(...mapped);
				} else {
					add(cp);
				}
			}
			if (!buf.length) break;
			cp = buf.pop();
		}
	}
	if (check_order && ret.length > 1) {
		let prev_cc = unpack_cc(ret[0]);
		for (let i = 1; i < ret.length; i++) {
			let cc = unpack_cc(ret[i]);
			if (cc == 0 || prev_cc <= cc) {
				prev_cc = cc;
				continue;
			}
			let j = i-1;
			while (true) {
				let tmp = ret[j+1];
				ret[j+1] = ret[j];
				ret[j] = tmp;
				if (!j) break;
				prev_cc = unpack_cc(ret[--j]);
				if (prev_cc <= cc) break;
			}
			prev_cc = unpack_cc(ret[i]);
		}
	}
	return ret;
}

function composed_from_decomposed(v) {
	let ret = [];
	let stack = [];
	let prev_cp = -1;
	let prev_cc = 0;
	for (let packed of v) {
		let cc = unpack_cc(packed);
		let cp = unpack_cp(packed);
		if (prev_cp == -1) {
			if (cc == 0) {
				prev_cp = cp;
			} else {
				ret.push(cp);
			}
		} else if (prev_cc > 0 && prev_cc >= cc) {
			if (cc == 0) {
				ret.push(prev_cp, ...stack);
				stack.length = 0;
				prev_cp = cp;
			} else {
				stack.push(cp);
			}
			prev_cc = cc;
		} else {
			let composed = compose_pair(prev_cp, cp);
			if (composed >= 0) {
				prev_cp = composed;
			} else if (prev_cc == 0 && cc == 0) {
				ret.push(prev_cp);
				prev_cp = cp;
			} else {
				stack.push(cp);
				prev_cc = cc;
			}
		}
	}
	if (prev_cp >= 0) {
		ret.push(prev_cp, ...stack);	
	}
	return ret;
}

// note: cps can be iterable
function nfd(cps) {
	return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
	return composed_from_decomposed(decomposed(cps));
}

const HYPHEN = 0x2D;
const STOP = 0x2E;
const STOP_CH = '.';
const FE0F = 0xFE0F;
const UNIQUE_PH = 1;

// 20230913: replace [...v] with Array_from(v) to avoid large spreads
const Array_from = x => Array.from(x); // Array.from.bind(Array);

function group_has_cp(g, cp) {
	// 20230913: keep primary and secondary distinct instead of creating valid union
	return g.P.has(cp) || g.Q.has(cp);
}

class Emoji extends Array {
	get is_emoji() { return true; } // free tagging system
}

let MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;

// export function ens_deinit() {
// 	nf_deinit();
// 	if (!MAPPED) return;
// 	MAPPED = IGNORED = CM = NSM = ESCAPE = NFC_CHECK = GROUPS = WHOLE_VALID = WHOLE_MAP = VALID = EMOJI_LIST = EMOJI_ROOT = undefined;
// }

function init() {
	if (MAPPED) return;
	
	let r = read_compressed_payload(COMPRESSED$1);
	const read_sorted_array = () => read_sorted(r);
	const read_sorted_set = () => new Set(read_sorted_array());
	const set_add_many = (set, v) => v.forEach(x => set.add(x));

	MAPPED = new Map(read_mapped(r)); 
	IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints

	/*
	// direct include from payload is smaller than the decompression code
	const FENCED = new Map(read_array_while(() => {
		let cp = r();
		if (cp) return [cp, read_str(r())];
	}));
	*/
	// 20230217: we still need all CM for proper error formatting
	// but norm only needs NSM subset that are potentially-valid
	CM = read_sorted_array();
	NSM = new Set(read_sorted_array().map(i => CM[i]));
	CM = new Set(CM);
	
	ESCAPE = read_sorted_set(); // characters that should not be printed
	NFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations

	let chunks = read_sorted_arrays(r);
	let unrestricted = r();
	//const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));
	const read_chunked = () => {
		// 20230921: build set in parts, 2x faster
		let set = new Set();
		read_sorted_array().forEach(i => set_add_many(set, chunks[i]));
		set_add_many(set, read_sorted_array());
		return set; 
	};
	GROUPS = read_array_while(i => {
		// minifier property mangling seems unsafe
		// so these are manually renamed to single chars
		let N = read_array_while(r).map(x => x+0x60);
		if (N.length) {
			let R = i >= unrestricted; // unrestricted then restricted
			N[0] -= 32; // capitalize
			N = str_from_cps(N);
			if (R) N=`Restricted[${N}]`;
			let P = read_chunked(); // primary
			let Q = read_chunked(); // secondary
			let M = !r(); // not-whitelisted, check for NSM
			// *** this code currently isn't needed ***
			/*
			let V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid
			let M = r()-1; // number of combining mark
			if (M < 0) { // whitelisted
				M = new Map(read_array_while(() => {
					let i = r();
					if (i) return [V[i-1], read_array_while(() => {
						let v = read_array_while(r);
						if (v.length) return v.map(x => x-1);
					})];
				}));
			}*/
			return {N, P, Q, M, R};
		}
	});

	// decode compressed wholes
	WHOLE_VALID = read_sorted_set();
	WHOLE_MAP = new Map();
	let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a-b); // must be sorted
	wholes.forEach((cp, i) => {
		let d = r(); 
		let w = wholes[i] = d ? wholes[i-d] : {V: [], M: new Map()};
		w.V.push(cp); // add to member set
		if (!WHOLE_VALID.has(cp)) {
			WHOLE_MAP.set(cp, w);  // register with whole map
		}
	});

	// compute confusable-extent complements
	// usage: WHOLE_MAP.get(cp).M.get(cp) = complement set
	for (let {V, M} of new Set(WHOLE_MAP.values())) {
		// connect all groups that have each whole character
		let recs = [];
		for (let cp of V) {
			let gs = GROUPS.filter(g => group_has_cp(g, cp));
			let rec = recs.find(({G}) => gs.some(g => G.has(g)));
			if (!rec) {
				rec = {G: new Set(), V: []};
				recs.push(rec);
			}
			rec.V.push(cp);
			set_add_many(rec.G, gs);
		}
		// per character cache groups which are not a member of the extent
		let union = recs.flatMap(x => Array_from(x.G)); // all of the groups used by this whole
		for (let {G, V} of recs) {
			let complement = new Set(union.filter(g => !G.has(g))); // groups not covered by the extent
			for (let cp of V) {
				M.set(cp, complement); // this is the same reference
			}
		}
	}

	// compute valid set
	// 20230924: VALID was union but can be re-used
	VALID = new Set(); // exists in 1+ groups
	let multi = new Set(); // exists in 2+ groups
	const add_to_union = cp => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
	for (let g of GROUPS) {
		for (let cp of g.P) add_to_union(cp);
		for (let cp of g.Q) add_to_union(cp);
	}
	// dual purpose WHOLE_MAP: return placeholder if unique non-confusable
	for (let cp of VALID) {
		if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
			WHOLE_MAP.set(cp, UNIQUE_PH);
		}
	}
	// add all decomposed parts
	// see derive: "Valid is Closed (via Brute-force)"
	set_add_many(VALID, nfd(VALID));
	
	// decode emoji
	// 20230719: emoji are now fully-expanded to avoid quirk logic 
	EMOJI_LIST = read_trie(r).map(v => Emoji.from(v)).sort(compare_arrays);
	EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)
	for (let cps of EMOJI_LIST) {
		// 20230719: change to *slightly* stricter algorithm which disallows 
		// insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)
		// example: beautified [A B] (eg. flag emoji) 
		//  before: allow: [A FE0F B], error: [A FE0F FE0F B] 
		//   after: error: both
		// note: this code now matches ENSNormalize.{cs,java} logic
		let prev = [EMOJI_ROOT];
		for (let cp of cps) {
			let next = prev.map(node => {
				let child = node.get(cp);
				if (!child) {
					// should this be object? 
					// (most have 1-2 items, few have many)
					// 20230719: no, v8 default map is 4?
					child = new Map();
					node.set(cp, child);
				}
				return child;
			});
			if (cp === FE0F) {
				prev.push(...next); // less than 20 elements
			} else {
				prev = next;
			}
		}
		for (let x of prev) {
			x.V = cps;
		}
	}
}

// if escaped: {HEX}
//       else: "x" {HEX}
function quoted_cp(cp) {
	return (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}

// 20230211: some messages can be mixed-directional and result in spillover
// use 200E after a quoted string to force the remainder of a string from 
// acquring the direction of the quote
// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions
function bidi_qq(s) {
	return `"${s}"\u200E`; // strong LTR
}

function check_label_extension(cps) {
	if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
		throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`); // this can only be ascii so cant be bidi
	}
}
function check_leading_underscore(cps) {
	const UNDERSCORE = 0x5F;
	for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
		if (cps[--i] !== UNDERSCORE) {
			throw new Error('underscore allowed only at start');
		}
	}
}
// check that a fenced cp is not leading, trailing, or touching another fenced cp
function check_fenced(cps) {
	let cp = cps[0];
	let prev = FENCED.get(cp);
	if (prev) throw error_placement(`leading ${prev}`);
	let n = cps.length;
	let last = -1; // prevents trailing from throwing
	for (let i = 1; i < n; i++) {
		cp = cps[i];
		let match = FENCED.get(cp);
		if (match) {
			// since cps[0] isn't fenced, cps[1] cannot throw
			if (last == i) throw error_placement(`${prev} + ${match}`);
			last = i + 1;
			prev = match;
		}
	}
	if (last == n) throw error_placement(`trailing ${prev}`);
}

// create a safe to print string 
// invisibles are escaped
// leading cm uses placeholder
// if cps exceed max, middle truncate with ellipsis
// quoter(cp) => string, eg. 3000 => "{3000}"
// note: in html, you'd call this function then replace [<>&] with entities
function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
	//if (Number.isInteger(cps)) cps = [cps];
	//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);
	let buf = [];
	if (is_combining_mark(cps[0])) buf.push('◌');
	if (cps.length > max) {
		max >>= 1;
		cps = [...cps.slice(0, max), 0x2026, ...cps.slice(-max)];
	}
	let prev = 0;
	let n = cps.length;
	for (let i = 0; i < n; i++) {
		let cp = cps[i];
		if (should_escape(cp)) {
			buf.push(str_from_cps(cps.slice(prev, i)));
			buf.push(quoter(cp));
			prev = i + 1;
		}
	}
	buf.push(str_from_cps(cps.slice(prev, n)));
	return buf.join('');
}

// note: set(s) cannot be exposed because they can be modified
// note: Object.freeze() doesn't work
function is_combining_mark(cp, only_nsm) { // 20240127: add extra argument
	init();
	return only_nsm ? NSM.has(cp) : CM.has(cp);
}
function should_escape(cp) {
	init();
	return ESCAPE.has(cp);
}

// return all supported emoji as fully-qualified emoji 
// ordered by length then lexicographic 
function ens_emoji() {
	init();
	return EMOJI_LIST.map(x => x.slice()); // emoji are exposed so copy
}

function ens_normalize_fragment(frag, decompose) {
	init();
	let nf = decompose ? nfd : nfc;
	return frag.split(STOP_CH).map(label => str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);
}

function ens_normalize(name) {
	return flatten(split(name, nfc, filter_fe0f));
}

function ens_beautify(name) {
	let labels = split(name, nfc, x => x); // emoji not exposed
	for (let {type, output, error} of labels) {
		if (error) break; // flatten will throw

		// replace leading/trailing hyphen
		// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant
		// not exactly the same in every font, but very similar: "-" vs "‐"
		/*
		const UNICODE_HYPHEN = 0x2010;
		// maybe this should replace all for visual consistancy?
		// `node tools/reg-count.js regex ^-\{2,\}` => 592
		//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;
		if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;
		let end = output.length-1;
		if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;
		*/
		// 20230123: WHATWG URL uses "CheckHyphens" false
		// https://url.spec.whatwg.org/#idna

		// update ethereum symbol
		// ξ => Ξ if not greek
		if (type !== 'Greek') array_replace(output, 0x3BE, 0x39E);

		// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)
		// could be fixed with special case for: 2D (.) + 200E (LTR)
		// https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824
		//output.splice(0, 0, 0x200E);
	}
	return flatten(labels);
}

function ens_split(name, preserve_emoji) {
	return split(name, nfc, preserve_emoji ? x => x.slice() : filter_fe0f); // emoji are exposed so copy
}

function split(name, nf, ef) {
	if (!name) return []; // 20230719: empty name allowance
	init();
	let offset = 0;
	// https://unicode.org/reports/tr46/#Validity_Criteria
	// 4.) "The label must not contain a U+002E ( . ) FULL STOP."
	return name.split(STOP_CH).map(label => {
		let input = explode_cp(label);
		let info = {
			input,
			offset, // codepoint, not substring!
		};
		offset += input.length + 1; // + stop
		try {
			// 1.) "The label must be in Unicode Normalization Form NFC"
			let tokens = info.tokens = tokens_from_str(input, nf, ef);
			let token_count = tokens.length;
			let type;
			if (!token_count) { // the label was effectively empty (could of had ignored characters)
				//norm = [];
				//type = 'None'; // use this instead of next match, "ASCII"
				// 20230120: change to strict
				// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59
				throw new Error(`empty label`);
			} 
			let norm = info.output = tokens.flat();
			check_leading_underscore(norm);
			let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);
			if (!emoji && norm.every(cp => cp < 0x80)) { // special case for ascii
				// 20230123: matches matches WHATWG, see note 3.3
				check_label_extension(norm); // only needed for ascii
				// cant have fenced
				// cant have cm
				// cant have wholes
				// see derive: "Fastpath ASCII"
				type = 'ASCII';
			} else {
				let chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together
				if (!chars.length) { // theres no text, just emoji
					type = 'Emoji';
				} else {
					// 5.) "The label must not begin with a combining mark, that is: General_Category=Mark."
					if (CM.has(norm[0])) throw error_placement('leading combining mark');
					for (let i = 1; i < token_count; i++) { // we've already checked the first token
						let cps = tokens[i];
						if (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...
							// bidi_qq() not needed since emoji is LTR and cps is a CM
							throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}"`); 
						}
					}
					check_fenced(norm);
					let unique = Array_from(new Set(chars));
					let [g] = determine_group(unique); // take the first match
					// see derive: "Matching Groups have Same CM Style"
					// alternative: could form a hybrid type: Latin/Japanese/...	
					check_group(g, chars); // need text in order
					check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)
					type = g.N;
					// 20230121: consider exposing restricted flag
					// it's simpler to just check for 'Restricted'
					// or even better: type.endsWith(']')
					//if (g.R) info.restricted = true;
				}
			}
			info.type = type;
		} catch (err) {
			info.error = err; // use full error object
		}
		return info;
	});
}

function check_whole(group, unique) {
	let maker;
	let shared = [];
	for (let cp of unique) {
		let whole = WHOLE_MAP.get(cp);
		if (whole === UNIQUE_PH) return; // unique, non-confusable
		if (whole) {
			let set = whole.M.get(cp); // groups which have a character that look-like this character
			maker = maker ? maker.filter(g => set.has(g)) : Array_from(set);
			if (!maker.length) return; // confusable intersection is empty
		} else {
			shared.push(cp); 
		}
	}
	if (maker) {
		// we have 1+ confusable
		// check if any of the remaining groups
		// contain the shared characters too
		for (let g of maker) {
			if (shared.every(cp => group_has_cp(g, cp))) {
				throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
			}
		}
	}
}

// assumption: unique.size > 0
// returns list of matching groups
function determine_group(unique) {
	let groups = GROUPS;
	for (let cp of unique) {
		// note: we need to dodge CM that are whitelisted
		// but that code isn't currently necessary
		let gs = groups.filter(g => group_has_cp(g, cp));
		if (!gs.length) {
			if (!GROUPS.some(g => group_has_cp(g, cp))) { 
				// the character was composed of valid parts
				// but it's NFC form is invalid
				// 20230716: change to more exact statement, see: ENSNormalize.{cs,java}
				// note: this doesn't have to be a composition
				// 20230720: change to full check
				throw error_disallowed(cp); // this should be rare
			} else {
				// there is no group that contains all these characters
				// throw using the highest priority group that matched
				// https://www.unicode.org/reports/tr39/#mixed_script_confusables
				throw error_group_member(groups[0], cp);
			}
		}
		groups = gs;
		if (gs.length == 1) break; // there is only one group left
	}
	// there are at least 1 group(s) with all of these characters
	return groups;
}

// throw on first error
function flatten(split) {
	return split.map(({input, error, output}) => {
		if (error) {
			// don't print label again if just a single label
			let msg = error.message;
			// bidi_qq() only necessary if msg is digits
			throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`); 
		}
		return str_from_cps(output);
	}).join(STOP_CH);
}

function error_disallowed(cp) {
	// TODO: add cp to error?
	return new Error(`disallowed character: ${quoted_cp(cp)}`); 
}
function error_group_member(g, cp) {
	let quoted = quoted_cp(cp);
	let gg = GROUPS.find(g => g.P.has(cp)); // only check primary
	if (gg) {
		quoted = `${gg.N} ${quoted}`;
	}
	return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
	return new Error(`illegal placement: ${where}`);
}

// assumption: cps.length > 0
// assumption: cps[0] isn't a CM
// assumption: the previous character isn't an emoji
function check_group(g, cps) {
	for (let cp of cps) {
		if (!group_has_cp(g, cp)) {
			// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. "e{300}{300}"
			// at the moment, it's unnecessary to introduce an extra error type
			// until there exists a whitelisted multi-character
			//   eg. if (M < 0 && is_combining_mark(cp)) { ... }
			// there are 3 cases:
			//   1. illegal cm for wrong group => mixture error
			//   2. illegal cm for same group => cm error
			//       requires set of whitelist cm per group: 
			//        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))
			//   3. wrong group => mixture error
			throw error_group_member(g, cp);
		}
	}
	//if (M >= 0) { // we have a known fixed cm count
	if (g.M) { // we need to check for NSM
		let decomposed = nfd(cps);
		for (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption
			// 20230210: bugfix: using cps instead of decomposed h/t Carbon225
			/*
			if (CM.has(decomposed[i])) {
				let j = i + 1;
				while (j < e && CM.has(decomposed[j])) j++;
				if (j - i > M) {
					throw new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);
				}
				i = j;
			}
			*/
			// 20230217: switch to NSM counting
			// https://www.unicode.org/reports/tr39/#Optional_Detection
			if (NSM.has(decomposed[i])) {
				let j = i + 1;
				for (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {
					// a. Forbid sequences of the same nonspacing mark.
					for (let k = i; k < j; k++) { // O(n^2) but n < 100
						if (decomposed[k] == cp) {
							throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
						}
					}
				}
				// parse to end so we have full nsm count
				// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).
				if (j - i > NSM_MAX) {
					// note: this slice starts with a base char or spacing-mark cm
					throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);
				}
				i = j;
			}
		}
	}
	// *** this code currently isn't needed ***
	/*
	let cm_whitelist = M instanceof Map;
	for (let i = 0, e = cps.length; i < e; ) {
		let cp = cps[i++];
		let seqs = cm_whitelist && M.get(cp);
		if (seqs) { 
			// list of codepoints that can follow
			// if this exists, this will always be 1+
			let j = i;
			while (j < e && CM.has(cps[j])) j++;
			let cms = cps.slice(i, j);
			let match = seqs.find(seq => !compare_arrays(seq, cms));
			if (!match) throw new Error(`disallowed combining mark sequence: "${safe_str_from_cps([cp, ...cms])}"`);
			i = j;
		} else if (!V.has(cp)) {
			// https://www.unicode.org/reports/tr39/#mixed_script_confusables
			let quoted = quoted_cp(cp);
			for (let cp of cps) {
				let u = UNIQUE.get(cp);
				if (u && u !== g) {
					// if both scripts are restricted this error is confusing
					// because we don't differentiate RestrictedA from RestrictedB 
					if (!u.R) quoted = `${quoted} is ${u.N}`;
					break;
				}
			}
			throw new Error(`disallowed ${g.N} character: ${quoted}`);
			//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);
			//throw new Error(`${g.N} does not allow: ${quoted}`);
		}
	}
	if (!cm_whitelist) {
		let decomposed = nfd(cps);
		for (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading
			if (CM.has(decomposed[i])) {
				let j = i + 1;
				while (j < e && CM.has(decomposed[j])) j++;
				if (j - i > M) {
					throw new Error(`too many combining marks: "${str_from_cps(decomposed.slice(i-1, j))}" (${j-i}/${M})`);
				}
				i = j;
			}
		}
	}
	*/
}

// given a list of codepoints
// returns a list of lists, where emoji are a fully-qualified (as Array subclass)
// eg. explode_cp("abc💩d") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]
// 20230818: rename for 'process' name collision h/t Javarome
// https://github.com/adraffy/ens-normalize.js/issues/23
function tokens_from_str(input, nf, ef) {
	let ret = [];
	let chars = [];
	input = input.slice().reverse(); // flip so we can pop
	while (input.length) {
		let emoji = consume_emoji_reversed(input);
		if (emoji) {
			if (chars.length) {
				ret.push(nf(chars));
				chars = [];
			}
			ret.push(ef(emoji));
		} else {
			let cp = input.pop();
			if (VALID.has(cp)) {
				chars.push(cp);
			} else {
				let cps = MAPPED.get(cp);
				if (cps) {
					chars.push(...cps); // less than 10 elements
				} else if (!IGNORED.has(cp)) {
					// 20230912: unicode 15.1 changed the order of processing such that
					// disallowed parts are only rejected after NFC
					// https://unicode.org/reports/tr46/#Validity_Criteria
					// this doesn't impact normalization as of today
					// technically, this error can be removed as the group logic will apply similar logic
					// however the error type might be less clear
					throw error_disallowed(cp);
				}
			}
		}
	}
	if (chars.length) {
		ret.push(nf(chars));
	}
	return ret;
}

function filter_fe0f(cps) {
	return cps.filter(cp => cp != FE0F);
}

// given array of codepoints
// returns the longest valid emoji sequence (or undefined if no match)
// *MUTATES* the supplied array
// disallows interleaved ignored characters
// fills (optional) eaten array with matched codepoints
function consume_emoji_reversed(cps, eaten) {
	let node = EMOJI_ROOT;
	let emoji;
	let pos = cps.length;
	while (pos) {
		node = node.get(cps[--pos]);
		if (!node) break;
		let {V} = node;
		if (V) { // this is a valid emoji (so far)
			emoji = V;
			if (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()
			cps.length = pos; // truncate
		}
	}
	return emoji;
}

// ************************************************************
// tokenizer 

const TY_VALID = 'valid';
const TY_MAPPED = 'mapped';
const TY_IGNORED = 'ignored';
const TY_DISALLOWED = 'disallowed';
const TY_EMOJI = 'emoji';
const TY_NFC = 'nfc';
const TY_STOP = 'stop';

function ens_tokenize(name, {
	nf = true, // collapse unnormalized runs into a single token
} = {}) {
	init();
	let input = explode_cp(name).reverse();
	let eaten = [];
	let tokens = [];
	while (input.length) {
		let emoji = consume_emoji_reversed(input, eaten);
		if (emoji) {
			tokens.push({
				type: TY_EMOJI,
				emoji: emoji.slice(), // copy emoji
				input: eaten,
				cps: filter_fe0f(emoji)
			});
			eaten = []; // reset buffer
		} else {
			let cp = input.pop();
			if (cp == STOP) {
				tokens.push({type: TY_STOP, cp});
			} else if (VALID.has(cp)) {
				tokens.push({type: TY_VALID, cps: [cp]});
			} else if (IGNORED.has(cp)) {
				tokens.push({type: TY_IGNORED, cp});
			} else {
				let cps = MAPPED.get(cp);
				if (cps) {
					tokens.push({type: TY_MAPPED, cp, cps: cps.slice()});
				} else {
					tokens.push({type: TY_DISALLOWED, cp});
				}
			}
		}
	}
	if (nf) {
		for (let i = 0, start = -1; i < tokens.length; i++) {
			let token = tokens[i];
			if (is_valid_or_mapped(token.type)) {
				if (requires_check(token.cps)) { // normalization might be needed
					let end = i + 1;
					for (let pos = end; pos < tokens.length; pos++) { // find adjacent text
						let {type, cps} = tokens[pos];
						if (is_valid_or_mapped(type)) {
							if (!requires_check(cps)) break;
							end = pos + 1;
						} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { 
							break;
						}
					}
					if (start < 0) start = i;
					let slice = tokens.slice(start, end);
					let cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens
					let cps = nfc(cps0);
					if (compare_arrays(cps, cps0)) { // bundle into an nfc token
						tokens.splice(start, end - start, {
							type: TY_NFC, 
							input: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps
							cps, 
							tokens0: collapse_valid_tokens(slice),
							tokens: ens_tokenize(str_from_cps(cps), {nf: false})
						});
						i = start;
					} else { 
						i = end - 1; // skip to end of slice
					}
					start = -1; // reset
				} else {
					start = i; // remember last
				}
			} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?
				start = -1; // reset
			}
		}
	}
	return collapse_valid_tokens(tokens);
}

function is_valid_or_mapped(type) {
	return type == TY_VALID || type == TY_MAPPED;
}

function requires_check(cps) {
	return cps.some(cp => NFC_CHECK.has(cp));
}

function collapse_valid_tokens(tokens) {
	for (let i = 0; i < tokens.length; i++) {
		if (tokens[i].type == TY_VALID) {
			let j = i + 1;
			while (j < tokens.length && tokens[j].type == TY_VALID) j++;
			tokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});
		}
	}
	return tokens;
}

function create(tag) {
	return document.createElement(tag);
}

function hex_seq(cps) {
	return cps.map(hex_cp).join(' ');
}

function create_arrow_span() {
	let span = create('span');
	span.classList.add('arrow');
	span.innerHTML = '➔'; // '→'; 
	return span;
}

function span_from_cp(cp, in_emoji) {
	let span = create('span');
	if (cp == 0x200D) {
		span.classList.add('mod', 'zwj');
		span.innerText = 'ZWJ';
	} else if (cp == 0x200C) {
		span.classList.add('mod', 'zwj');
		span.innerText = 'ZWNJ';
	} else if (cp == 0xFE0F) {
		span.classList.add('mod', 'dropped', 'style');
		span.innerText = 'FE0F';
	} else if (cp == 0x20E3) {
		span.classList.add('mod', 'keycap');
		span.innerText = 'Keycap';
	} else if (cp >= 0xE0021 && cp <= 0xE007E) { // printable ascii tag
		span.classList.add('mod', 'tag');
		span.innerText = String.fromCodePoint(cp - 0xE0000);
	} else if (cp == 0xE007F) { // tag end
		span.classList.add('mod', 'tag', 'end');
		span.innerText = '⌫'; // 🏷️
	} else if (!in_emoji && should_escape(cp)) {
		span.classList.add('code');
		span.innerText = hex_cp(cp);
	} else {
		span.innerText = safe_str_from_cps([cp]);
	}
	return span;
}

// idea
//export function dom_from_token(token) {

function format_tooltip(obj, extra) {
	let lines = Object.entries(obj).map(([k, v]) => `${k}: ${v}`);
	if (Array.isArray(extra)) lines.push(...extra);	
	return lines.join('\n');
}

function isolated_safe(cps) {
	return cps.map(cp => safe_str_from_cps([cp])).join('\u{200B}')
}

// TODO: these options are shit, fix this
function dom_from_tokens(tokens, {
	before,
	components,
	emoji,
	tld,
	extra = () => {},
} = {}) {
	let div = create('div');
	div.classList.add('tokens');
	div.append(...tokens.map((token, i) => {
		let el;
		switch (token.type) {
			case 'emoji': {
				el = create('a');
				if (emoji) emoji(el, token);
				let cps = before ? token.input : token.cps;
				if (components && cps.length > 1) {
					el.dataset.components='1';
					el.append(...cps.map(cp => span_from_cp(cp, true)));
				} else {
					el.innerText = String.fromCodePoint(...token.emoji); // use fully-qualified form
				}
				el.title = format_tooltip({
					Type: 'Emoji',
					Hex: hex_seq(cps),
					Beautified: hex_seq(token.emoji),
				}, extra(token.type, cps));
				break;
			}
			case 'nfc': {
				el = create('div');
				// get the cps from the original tokens
				let cps0 = token.tokens0.flatMap(t => t.type === 'valid' ? t.cps : t.cp); // this can only be mapped/ignored/valid
				// break every valid token into individual characters
				let lhs = dom_from_tokens(token.tokens0.flatMap(t => t.type === 'valid' ? t.cps.map(cp => ({type: 'valid', cps: [cp]})) : t), {components, before, emoji, extra});
				lhs.title = format_tooltip({
					Type: 'NFC (Unnormalized)',
					Hex: hex_seq(cps0),
				}, extra(token.type, cps0));
				el.append(lhs);
				if (!before) {
					let rhs = dom_from_tokens(token.tokens, {components, emoji, extra});
					rhs.title = format_tooltip({
						Type: 'NFC (Normalized)',
						Hex: hex_seq(token.cps),
					}, extra(token.type, token.cps));
					el.append(create_arrow_span(), rhs);
				}
				break;
			}
			case 'valid': {
				el = create('span');
				let form = safe_str_from_cps(token.cps);
				if (tld && i === tokens.length-1 && (!i || tokens[i-1].type === 'stop') && /^[a-z]+$/.test(form)) {
					el.dataset.tld = form;
				}
				el.innerText = form;
				el.title = format_tooltip({
					Type: 'Valid',
					Hex: hex_seq(token.cps),
				}, extra(token.type, token.cps));
				break;
			}
			case 'mapped': {
				el = create('div');
				let span_src = create('span');
				span_src.classList.add('before');
				span_src.innerText = safe_str_from_cps([token.cp]);	// isolate ? isolated_safe([token.cp]) : 
				span_src.title = format_tooltip({
					Type: 'Mapped (Match)',
					Hex: hex_cp(token.cp),
				}, extra(token.type, [token.cp]));
				el.append(span_src);
				if (!before) {
					let span_dst = create('span');
					span_dst.innerText = isolated_safe(token.cps); // safe_str_from_cps(token.cps);
					span_dst.title = format_tooltip({
						Type: 'Mapped (Replacement)',
						Hex: hex_seq(token.cps),
					}, extra(token.type, token.cps));
					el.append(create_arrow_span(), span_dst);
				}
				break;
			}
			case 'stop':
			case 'ignored':
			case 'disallowed': {
				el = span_from_cp(token.cp);
				el.title = format_tooltip({
					Type: token.type,
					Hex: hex_cp(token.cp),
				}, extra(token.type, [token.cp]));
				break;
			}
			default: throw new TypeError(`unknown token type: ${token.type}`);
		}
		el.classList.add(token.type);
		return el;
	}));
	return div;
}

function use_default_style() {
	let style = create('style');
	style.innerText = `
	.tokens {
		display: flex;
		flex-wrap: wrap;
		gap: 2px;
	}
	.tokens > * {
		padding: 2px 4px;
		display: flex;
		align-items: center;
		gap: 4px;
		border-radius: 5px;
		overflow: hidden;
	}
	.tokens a {
		text-decoration: none;
	}
	.tokens a[href]:hover {
		border-color: #00f;
	}
	.tokens .valid {
		background: #cfc;
		border: 2px solid #0a0;
		line-break: anywhere;
	}
	.tokens .ignored {
		color: #fff;
		background: #aaa;
		font-size: 75%;
		font-family: monospace;
	}
	.tokens .disallowed {
		background: #c00;	
		min-width: 5px;
		min-height: 1em;
		border-radius: 5px;
		color: #fff;
	}
	.tokens .disallowed.code {
		font-size: 75%;
		background: #800;
	}
	.tokens .disallowed.mod {
		border: 2px solid #800;
		font-size: 80%;
	}
	.tokens .disallowed.mod.tag {
		background: #f00;
		color: #000;
	}
	.tokens .mapped {
		display: flex;
		border: 2px solid #66f;
		background: #ccf;
	}
	.tokens .mapped span:first-child {
		margin-bottom: -4px;
		border-bottom: 4px solid #000;
		text-align: center;
		min-width: 0.5rem;
	}
	.tokens .stop {
		font-weight: bold;
		background: linear-gradient(#fff, #ff0);
		padding-bottom: 0;
		border: 1px solid #ccc;
	}
	.tokens .emoji {
		border: 2px solid #0aa;
		background: #cff;
		color: #000;
	}
	.tokens .mod {
		color: #fff;
	}
	.tokens * .mod {
		font-size: 70%;
		padding: 2px;
		border-radius: 3px;
	}
	.tokens .emoji .mod {
		background: #333;
	}
	.tokens .emoji .mod.zwj {
		background: #0aa;
	}
	.tokens .emoji .mod.tag {
		background: #0aa;
	}
	.tokens .emoji .mod.tag.end {
		background: #066;
	}
	.tokens .emoji .mod.dropped {
		background: #aaa;		
	}
	.tokens .arrow {
		color: rgba(0, 0, 0, 0.35);
		user-select: none;
		margin: 0 -2px;
	}
	.tokens .code {
		font-family: monospace;
	}
	.tokens .nfc {
		display: flex;
		border: 2px solid #c80;
		background: #fd8;
		border-radius: 5px;
		padding: 2px;
	}`;
	document.body.append(style);
}

// see: https://github.com/adraffy/ens-normalize.js#security
const derived = "2024-09-11T06:51:59.656Z";
const unicode = "16.0.0 (2024-09-10T20:47:54.200Z)";
const cldr = "45 (2024-04-19T05:36:55.332Z)";
const ens_hash_base64 = "76ededceb442d548f92752e3e49e5fd44f537436c8231a5212aecd3aac4db0bf";
const nf_hash_base64 = "a79d5f9b1879a7b416aa659f4a3d788f80a8cf5f0ab955a456592c02f556a28c";
const spec_hash = "dbe76634f67cd03248e838b15138b0c8948d84c86e18fb32a460ddb4990f173e";
const built = "2024-09-11T06:52:01.120Z";
const version = "1.11.0";

var includeVersions = /*#__PURE__*/Object.freeze({
	__proto__: null,
	built: built,
	cldr: cldr,
	derived: derived,
	ens_hash_base64: ens_hash_base64,
	nf_hash_base64: nf_hash_base64,
	spec_hash: spec_hash,
	unicode: unicode,
	version: version
});

export { array_replace, compare_arrays, dom_from_tokens, ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, explode_cp, hex_cp, is_combining_mark, nfc, nfd, quote_cp, random_choice, random_sample, run_tests, safe_str_from_cps, should_escape, str_from_cps, use_default_style, includeVersions as versions };
