'use strict';

// created 2025-08-07T02:23:16.240Z
// compressed base64-encoded blob for include-ens data
// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js
// see: https://github.com/adraffy/ens-normalize.js#security
// SHA-256: 620cf9955fe047b920a82f3c6c44cd27c6e9951119381ceb6ca07cba2825e54d
var COMPRESSED = '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';
const FENCED = new Map([[8217,"apostrophe"],[8260,"fraction slash"],[12539,"middle dot"]]);
const NSM_MAX = 4;

function decode_arithmetic(bytes) {
	let pos = 0;
	function u16() { return (bytes[pos++] << 8) | bytes[pos++]; }
	
	// decode the frequency table
	let symbol_count = u16();
	let total = 1;
	let acc = [0, 1]; // first symbol has frequency 1
	for (let i = 1; i < symbol_count; i++) {
		acc.push(total += u16());
	}

	// skip the sized-payload that the last 3 symbols index into
	let skip = u16();
	let pos_payload = pos;
	pos += skip;

	let read_width = 0;
	let read_buffer = 0; 
	function read_bit() {
		if (read_width == 0) {
			// this will read beyond end of buffer
			// but (undefined|0) => zero pad
			read_buffer = (read_buffer << 8) | bytes[pos++];
			read_width = 8;
		}
		return (read_buffer >> --read_width) & 1;
	}

	const N = 31;
	const FULL = 2**N;
	const HALF = FULL >>> 1;
	const QRTR = HALF >> 1;
	const MASK = FULL - 1;

	// fill register
	let register = 0;
	for (let i = 0; i < N; i++) register = (register << 1) | read_bit();

	let symbols = [];
	let low = 0;
	let range = FULL; // treat like a float
	while (true) {
		let value = Math.floor((((register - low + 1) * total) - 1) / range);
		let start = 0;
		let end = symbol_count;
		while (end - start > 1) { // binary search
			let mid = (start + end) >>> 1;
			if (value < acc[mid]) {
				end = mid;
			} else {
				start = mid;
			}
		}
		if (start == 0) break; // first symbol is end mark
		symbols.push(start);
		let a = low + Math.floor(range * acc[start]   / total);
		let b = low + Math.floor(range * acc[start+1] / total) - 1;
		while (((a ^ b) & HALF) == 0) {
			register = (register << 1) & MASK | read_bit();
			a = (a << 1) & MASK;
			b = (b << 1) & MASK | 1;
		}
		while (a & ~b & QRTR) {
			register = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();
			a = (a << 1) ^ HALF;
			b = ((b ^ HALF) << 1) | HALF | 1;
		}
		low = a;
		range = 1 + b - a;
	}
	let offset = symbol_count - 4;
	return symbols.map(x => { // index into payload
		switch (x - offset) {
			case 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);
			case 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);
			case 1: return offset + bytes[pos_payload++];
			default: return x - 1;
		}
	});
}	

// returns an iterator which returns the next symbol
function read_payload(v) {
	let pos = 0;
	return () => v[pos++];
}
function read_compressed_payload(s) {
	return read_payload(decode_arithmetic(unsafe_atob(s)));
}

// unsafe in the sense:
// expected well-formed Base64 w/o padding 
// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4
function unsafe_atob(s) {
	let lookup = [];
	[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
	let n = s.length;
	let ret = new Uint8Array((6 * n) >> 3);
	for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
		carry = (carry << 6) | lookup[s.charCodeAt(i)];
		width += 6;
		if (width >= 8) {
			ret[pos++] = (carry >> (width -= 8));
		}
	}
	return ret;
}

// eg. [0,1,2,3...] => [0,-1,1,-2,...]
function signed(i) { 
	return (i & 1) ? (~i >> 1) : (i >> 1);
}

function read_deltas(n, next) {
	let v = Array(n);
	for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());
	return v;
}

// [123][5] => [0 3] [1 1] [0 0]
function read_sorted(next, prev = 0) {
	let ret = [];
	while (true) {
		let x = next();
		let n = next();
		if (!n) break;
		prev += x;
		for (let i = 0; i < n; i++) {
			ret.push(prev + i);
		}
		prev += n + 1;
	}
	return ret;
}

function read_sorted_arrays(next) {
	return read_array_while(() => { 
		let v = read_sorted(next);
		if (v.length) return v;
	});
}

// returns map of x => ys
function read_mapped(next) {
	let ret = [];
	while (true) {
		let w = next();
		if (w == 0) break;
		ret.push(read_linear_table(w, next));
	}
	while (true) {
		let w = next() - 1;
		if (w < 0) break;
		ret.push(read_replacement_table(w, next));
	}
	return ret.flat();
}

// read until next is falsy
// return array of read values
function read_array_while(next) {
	let v = [];
	while (true) {
		let x = next(v.length);
		if (!x) break;
		v.push(x);
	}
	return v;
}

// read w columns of length n
// return as n rows of length w
function read_transposed(n, w, next) {
	let m = Array(n).fill().map(() => []);
	for (let i = 0; i < w; i++) {
		read_deltas(n, next).forEach((x, j) => m[j].push(x));
	}
	return m;
}
 
// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]
// where dx/dy = steps, n = run size, w = length of y
function read_linear_table(w, next) {
	let dx = 1 + next();
	let dy = next();
	let vN = read_array_while(next);
	let m = read_transposed(vN.length, 1+w, next);
	return m.flatMap((v, i) => {
		let [x, ...ys] = v;
		return Array(vN[i]).fill().map((_, j) => {
			let j_dy = j * dy;
			return [x + j * dx, ys.map(y => y + j_dy)];
		});
	});
}

// return [[x, ys...], ...]
// where w = length of y
function read_replacement_table(w, next) { 
	let n = 1 + next();
	let m = read_transposed(n, 1+w, next);
	return m.map(v => [v[0], v.slice(1)]);
}


function read_trie(next) {
	let ret = [];
	let sorted = read_sorted(next); 
	expand(decode([]), []);
	return ret; // not sorted
	function decode(Q) { // characters that lead into this node
		let S = next(); // state: valid, save, check
		let B = read_array_while(() => { // buckets leading to new nodes
			let cps = read_sorted(next).map(i => sorted[i]);
			if (cps.length) return decode(cps);
		});
		return {S, B, Q};
	}
	function expand({S, B}, cps, saved) {
		if (S & 4 && saved === cps[cps.length-1]) return;
		if (S & 2) saved = cps[cps.length-1];
		if (S & 1) ret.push(cps); 
		for (let br of B) {
			for (let cp of br.Q) {
				expand(br, [...cps, cp], saved);
			}
		}
	}
}

function hex_cp(cp) {
	return cp.toString(16).toUpperCase().padStart(2, '0');
}

function quote_cp(cp) {
	return `{${hex_cp(cp)}}`; // raffy convention: like "\u{X}" w/o the "\u"
}

/*
export function explode_cp(s) {
	return [...s].map(c => c.codePointAt(0));
}
*/
function explode_cp(s) { // this is about 2x faster
	let cps = [];
	for (let pos = 0, len = s.length; pos < len; ) {
		let cp = s.codePointAt(pos);
		pos += cp < 0x10000 ? 1 : 2;
		cps.push(cp);
	}
	return cps;
}

function str_from_cps(cps) {
	const chunk = 4096;
	let len = cps.length;
	if (len < chunk) return String.fromCodePoint(...cps);
	let buf = [];
	for (let i = 0; i < len; ) {
		buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
	}
	return buf.join('');
}

function compare_arrays(a, b) {
	let n = a.length;
	let c = n - b.length;
	for (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];
	return c;
}

function array_replace(v, a, b) {
	let prev = 0;
	while (true) {
		let next = v.indexOf(a, prev);
		if (next < 0) break;
		v[next] = b; 
		prev = next + 1;
	}
}

// reverse polyfill
// replace custom nf implementation with system implementation
// (saves approximately 6KB)


function nf(cps, form) {
	return explode_cp(str_from_cps(cps).normalize(form));
}

function nfc(cps) {
	return nf(cps, 'NFC');
}
function nfd(cps) {
	return nf(cps, 'NFD');
}

const HYPHEN = 0x2D;
const STOP = 0x2E;
const STOP_CH = '.';
const FE0F = 0xFE0F;
const UNIQUE_PH = 1;

// 20230913: replace [...v] with Array_from(v) to avoid large spreads
const Array_from = x => Array.from(x); // Array.from.bind(Array);

function group_has_cp(g, cp) {
	// 20230913: keep primary and secondary distinct instead of creating valid union
	return g.P.has(cp) || g.Q.has(cp);
}

class Emoji extends Array {
	get is_emoji() { return true; } // free tagging system
}

let MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;

// export function ens_deinit() {
// 	nf_deinit();
// 	if (!MAPPED) return;
// 	MAPPED = IGNORED = CM = NSM = ESCAPE = NFC_CHECK = GROUPS = WHOLE_VALID = WHOLE_MAP = VALID = EMOJI_LIST = EMOJI_ROOT = undefined;
// }

function init() {
	if (MAPPED) return;
	
	let r = read_compressed_payload(COMPRESSED);
	const read_sorted_array = () => read_sorted(r);
	const read_sorted_set = () => new Set(read_sorted_array());
	const set_add_many = (set, v) => v.forEach(x => set.add(x));

	MAPPED = new Map(read_mapped(r)); 
	IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints

	/*
	// direct include from payload is smaller than the decompression code
	const FENCED = new Map(read_array_while(() => {
		let cp = r();
		if (cp) return [cp, read_str(r())];
	}));
	*/
	// 20230217: we still need all CM for proper error formatting
	// but norm only needs NSM subset that are potentially-valid
	CM = read_sorted_array();
	NSM = new Set(read_sorted_array().map(i => CM[i]));
	CM = new Set(CM);
	
	ESCAPE = read_sorted_set(); // characters that should not be printed
	NFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations

	let chunks = read_sorted_arrays(r);
	let unrestricted = r();
	//const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));
	const read_chunked = () => {
		// 20230921: build set in parts, 2x faster
		let set = new Set();
		read_sorted_array().forEach(i => set_add_many(set, chunks[i]));
		set_add_many(set, read_sorted_array());
		return set; 
	};
	GROUPS = read_array_while(i => {
		// minifier property mangling seems unsafe
		// so these are manually renamed to single chars
		let N = read_array_while(r).map(x => x+0x60);
		if (N.length) {
			let R = i >= unrestricted; // unrestricted then restricted
			N[0] -= 32; // capitalize
			N = str_from_cps(N);
			if (R) N=`Restricted[${N}]`;
			let P = read_chunked(); // primary
			let Q = read_chunked(); // secondary
			let M = !r(); // not-whitelisted, check for NSM
			// *** this code currently isn't needed ***
			/*
			let V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid
			let M = r()-1; // number of combining mark
			if (M < 0) { // whitelisted
				M = new Map(read_array_while(() => {
					let i = r();
					if (i) return [V[i-1], read_array_while(() => {
						let v = read_array_while(r);
						if (v.length) return v.map(x => x-1);
					})];
				}));
			}*/
			return {N, P, Q, M, R};
		}
	});

	// decode compressed wholes
	WHOLE_VALID = read_sorted_set();
	WHOLE_MAP = new Map();
	let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a-b); // must be sorted
	wholes.forEach((cp, i) => {
		let d = r(); 
		let w = wholes[i] = d ? wholes[i-d] : {V: [], M: new Map()};
		w.V.push(cp); // add to member set
		if (!WHOLE_VALID.has(cp)) {
			WHOLE_MAP.set(cp, w);  // register with whole map
		}
	});

	// compute confusable-extent complements
	// usage: WHOLE_MAP.get(cp).M.get(cp) = complement set
	for (let {V, M} of new Set(WHOLE_MAP.values())) {
		// connect all groups that have each whole character
		let recs = [];
		for (let cp of V) {
			let gs = GROUPS.filter(g => group_has_cp(g, cp));
			let rec = recs.find(({G}) => gs.some(g => G.has(g)));
			if (!rec) {
				rec = {G: new Set(), V: []};
				recs.push(rec);
			}
			rec.V.push(cp);
			set_add_many(rec.G, gs);
		}
		// per character cache groups which are not a member of the extent
		let union = recs.flatMap(x => Array_from(x.G)); // all of the groups used by this whole
		for (let {G, V} of recs) {
			let complement = new Set(union.filter(g => !G.has(g))); // groups not covered by the extent
			for (let cp of V) {
				M.set(cp, complement); // this is the same reference
			}
		}
	}

	// compute valid set
	// 20230924: VALID was union but can be re-used
	VALID = new Set(); // exists in 1+ groups
	let multi = new Set(); // exists in 2+ groups
	const add_to_union = cp => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
	for (let g of GROUPS) {
		for (let cp of g.P) add_to_union(cp);
		for (let cp of g.Q) add_to_union(cp);
	}
	// dual purpose WHOLE_MAP: return placeholder if unique non-confusable
	for (let cp of VALID) {
		if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
			WHOLE_MAP.set(cp, UNIQUE_PH);
		}
	}
	// add all decomposed parts
	// see derive: "Valid is Closed (via Brute-force)"
	set_add_many(VALID, nfd(VALID));
	
	// decode emoji
	// 20230719: emoji are now fully-expanded to avoid quirk logic 
	EMOJI_LIST = read_trie(r).map(v => Emoji.from(v)).sort(compare_arrays);
	EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)
	for (let cps of EMOJI_LIST) {
		// 20230719: change to *slightly* stricter algorithm which disallows 
		// insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)
		// example: beautified [A B] (eg. flag emoji) 
		//  before: allow: [A FE0F B], error: [A FE0F FE0F B] 
		//   after: error: both
		// note: this code now matches ENSNormalize.{cs,java} logic
		let prev = [EMOJI_ROOT];
		for (let cp of cps) {
			let next = prev.map(node => {
				let child = node.get(cp);
				if (!child) {
					// should this be object? 
					// (most have 1-2 items, few have many)
					// 20230719: no, v8 default map is 4?
					child = new Map();
					node.set(cp, child);
				}
				return child;
			});
			if (cp === FE0F) {
				prev.push(...next); // less than 20 elements
			} else {
				prev = next;
			}
		}
		for (let x of prev) {
			x.V = cps;
		}
	}
}

// if escaped: {HEX}
//       else: "x" {HEX}
function quoted_cp(cp) {
	return (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}

// 20230211: some messages can be mixed-directional and result in spillover
// use 200E after a quoted string to force the remainder of a string from 
// acquring the direction of the quote
// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions
function bidi_qq(s) {
	return `"${s}"\u200E`; // strong LTR
}

function check_label_extension(cps) {
	if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
		throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`); // this can only be ascii so cant be bidi
	}
}
function check_leading_underscore(cps) {
	const UNDERSCORE = 0x5F;
	for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
		if (cps[--i] !== UNDERSCORE) {
			throw new Error('underscore allowed only at start');
		}
	}
}
// check that a fenced cp is not leading, trailing, or touching another fenced cp
function check_fenced(cps) {
	let cp = cps[0];
	let prev = FENCED.get(cp);
	if (prev) throw error_placement(`leading ${prev}`);
	let n = cps.length;
	let last = -1; // prevents trailing from throwing
	for (let i = 1; i < n; i++) {
		cp = cps[i];
		let match = FENCED.get(cp);
		if (match) {
			// since cps[0] isn't fenced, cps[1] cannot throw
			if (last == i) throw error_placement(`${prev} + ${match}`);
			last = i + 1;
			prev = match;
		}
	}
	if (last == n) throw error_placement(`trailing ${prev}`);
}

// create a safe to print string 
// invisibles are escaped
// leading cm uses placeholder
// if cps exceed max, middle truncate with ellipsis
// quoter(cp) => string, eg. 3000 => "{3000}"
// note: in html, you'd call this function then replace [<>&] with entities
function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
	//if (Number.isInteger(cps)) cps = [cps];
	//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);
	let buf = [];
	if (is_combining_mark(cps[0])) buf.push('â—Œ');
	if (cps.length > max) {
		max >>= 1;
		cps = [...cps.slice(0, max), 0x2026, ...cps.slice(-max)];
	}
	let prev = 0;
	let n = cps.length;
	for (let i = 0; i < n; i++) {
		let cp = cps[i];
		if (should_escape(cp)) {
			buf.push(str_from_cps(cps.slice(prev, i)));
			buf.push(quoter(cp));
			prev = i + 1;
		}
	}
	buf.push(str_from_cps(cps.slice(prev, n)));
	return buf.join('');
}

// note: set(s) cannot be exposed because they can be modified
// note: Object.freeze() doesn't work
function is_combining_mark(cp, only_nsm) { // 20240127: add extra argument
	init();
	return only_nsm ? NSM.has(cp) : CM.has(cp);
}
function should_escape(cp) {
	init();
	return ESCAPE.has(cp);
}

// return all supported emoji as fully-qualified emoji 
// ordered by length then lexicographic 
function ens_emoji() {
	init();
	return EMOJI_LIST.map(x => x.slice()); // emoji are exposed so copy
}

function ens_normalize_fragment(frag, decompose) {
	init();
	let nf = decompose ? nfd : nfc;
	return frag.split(STOP_CH).map(label => str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);
}

function ens_normalize(name) {
	return flatten(split(name, nfc, filter_fe0f));
}

function ens_beautify(name) {
	let labels = split(name, nfc, x => x); // emoji not exposed
	for (let {type, output, error} of labels) {
		if (error) break; // flatten will throw

		// replace leading/trailing hyphen
		// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant
		// not exactly the same in every font, but very similar: "-" vs "â€"
		/*
		const UNICODE_HYPHEN = 0x2010;
		// maybe this should replace all for visual consistancy?
		// `node tools/reg-count.js regex ^-\{2,\}` => 592
		//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;
		if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;
		let end = output.length-1;
		if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;
		*/
		// 20230123: WHATWG URL uses "CheckHyphens" false
		// https://url.spec.whatwg.org/#idna

		// update ethereum symbol
		// Î¾ => Îž if not greek
		if (type !== 'Greek') array_replace(output, 0x3BE, 0x39E);

		// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)
		// could be fixed with special case for: 2D (.) + 200E (LTR)
		// https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824
		//output.splice(0, 0, 0x200E);
	}
	return flatten(labels);
}

function ens_split(name, preserve_emoji) {
	return split(name, nfc, preserve_emoji ? x => x.slice() : filter_fe0f); // emoji are exposed so copy
}

function split(name, nf, ef) {
	if (!name) return []; // 20230719: empty name allowance
	init();
	let offset = 0;
	// https://unicode.org/reports/tr46/#Validity_Criteria
	// 4.) "The label must not contain a U+002E ( . ) FULL STOP."
	return name.split(STOP_CH).map(label => {
		let input = explode_cp(label);
		let info = {
			input,
			offset, // codepoint, not substring!
		};
		offset += input.length + 1; // + stop
		try {
			// 1.) "The label must be in Unicode Normalization Form NFC"
			let tokens = info.tokens = tokens_from_str(input, nf, ef);
			let token_count = tokens.length;
			let type;
			if (!token_count) { // the label was effectively empty (could of had ignored characters)
				//norm = [];
				//type = 'None'; // use this instead of next match, "ASCII"
				// 20230120: change to strict
				// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59
				throw new Error(`empty label`);
			} 
			let norm = info.output = tokens.flat();
			check_leading_underscore(norm);
			let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);
			if (!emoji && norm.every(cp => cp < 0x80)) { // special case for ascii
				// 20230123: matches matches WHATWG, see note 3.3
				check_label_extension(norm); // only needed for ascii
				// cant have fenced
				// cant have cm
				// cant have wholes
				// see derive: "Fastpath ASCII"
				type = 'ASCII';
			} else {
				let chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together
				if (!chars.length) { // theres no text, just emoji
					type = 'Emoji';
				} else {
					// 5.) "The label must not begin with a combining mark, that is: General_Category=Mark."
					if (CM.has(norm[0])) throw error_placement('leading combining mark');
					for (let i = 1; i < token_count; i++) { // we've already checked the first token
						let cps = tokens[i];
						if (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...
							// bidi_qq() not needed since emoji is LTR and cps is a CM
							throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}"`); 
						}
					}
					check_fenced(norm);
					let unique = Array_from(new Set(chars));
					let [g] = determine_group(unique); // take the first match
					// see derive: "Matching Groups have Same CM Style"
					// alternative: could form a hybrid type: Latin/Japanese/...	
					check_group(g, chars); // need text in order
					check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)
					type = g.N;
					// 20230121: consider exposing restricted flag
					// it's simpler to just check for 'Restricted'
					// or even better: type.endsWith(']')
					//if (g.R) info.restricted = true;
				}
			}
			info.type = type;
		} catch (err) {
			info.error = err; // use full error object
		}
		return info;
	});
}

function check_whole(group, unique) {
	let maker;
	let shared = [];
	for (let cp of unique) {
		let whole = WHOLE_MAP.get(cp);
		if (whole === UNIQUE_PH) return; // unique, non-confusable
		if (whole) {
			let set = whole.M.get(cp); // groups which have a character that look-like this character
			maker = maker ? maker.filter(g => set.has(g)) : Array_from(set);
			if (!maker.length) return; // confusable intersection is empty
		} else {
			shared.push(cp); 
		}
	}
	if (maker) {
		// we have 1+ confusable
		// check if any of the remaining groups
		// contain the shared characters too
		for (let g of maker) {
			if (shared.every(cp => group_has_cp(g, cp))) {
				throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
			}
		}
	}
}

// assumption: unique.size > 0
// returns list of matching groups
function determine_group(unique) {
	let groups = GROUPS;
	for (let cp of unique) {
		// note: we need to dodge CM that are whitelisted
		// but that code isn't currently necessary
		let gs = groups.filter(g => group_has_cp(g, cp));
		if (!gs.length) {
			if (!GROUPS.some(g => group_has_cp(g, cp))) { 
				// the character was composed of valid parts
				// but it's NFC form is invalid
				// 20230716: change to more exact statement, see: ENSNormalize.{cs,java}
				// note: this doesn't have to be a composition
				// 20230720: change to full check
				throw error_disallowed(cp); // this should be rare
			} else {
				// there is no group that contains all these characters
				// throw using the highest priority group that matched
				// https://www.unicode.org/reports/tr39/#mixed_script_confusables
				throw error_group_member(groups[0], cp);
			}
		}
		groups = gs;
		if (gs.length == 1) break; // there is only one group left
	}
	// there are at least 1 group(s) with all of these characters
	return groups;
}

// throw on first error
function flatten(split) {
	return split.map(({input, error, output}) => {
		if (error) {
			// don't print label again if just a single label
			let msg = error.message;
			// bidi_qq() only necessary if msg is digits
			throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`); 
		}
		return str_from_cps(output);
	}).join(STOP_CH);
}

function error_disallowed(cp) {
	// TODO: add cp to error?
	return new Error(`disallowed character: ${quoted_cp(cp)}`); 
}
function error_group_member(g, cp) {
	let quoted = quoted_cp(cp);
	let gg = GROUPS.find(g => g.P.has(cp)); // only check primary
	if (gg) {
		quoted = `${gg.N} ${quoted}`;
	}
	return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
	return new Error(`illegal placement: ${where}`);
}

// assumption: cps.length > 0
// assumption: cps[0] isn't a CM
// assumption: the previous character isn't an emoji
function check_group(g, cps) {
	for (let cp of cps) {
		if (!group_has_cp(g, cp)) {
			// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. "e{300}{300}"
			// at the moment, it's unnecessary to introduce an extra error type
			// until there exists a whitelisted multi-character
			//   eg. if (M < 0 && is_combining_mark(cp)) { ... }
			// there are 3 cases:
			//   1. illegal cm for wrong group => mixture error
			//   2. illegal cm for same group => cm error
			//       requires set of whitelist cm per group: 
			//        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))
			//   3. wrong group => mixture error
			throw error_group_member(g, cp);
		}
	}
	//if (M >= 0) { // we have a known fixed cm count
	if (g.M) { // we need to check for NSM
		let decomposed = nfd(cps);
		for (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption
			// 20230210: bugfix: using cps instead of decomposed h/t Carbon225
			/*
			if (CM.has(decomposed[i])) {
				let j = i + 1;
				while (j < e && CM.has(decomposed[j])) j++;
				if (j - i > M) {
					throw new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);
				}
				i = j;
			}
			*/
			// 20230217: switch to NSM counting
			// https://www.unicode.org/reports/tr39/#Optional_Detection
			if (NSM.has(decomposed[i])) {
				let j = i + 1;
				for (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {
					// a. Forbid sequences of the same nonspacing mark.
					for (let k = i; k < j; k++) { // O(n^2) but n < 100
						if (decomposed[k] == cp) {
							throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
						}
					}
				}
				// parse to end so we have full nsm count
				// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).
				if (j - i > NSM_MAX) {
					// note: this slice starts with a base char or spacing-mark cm
					throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);
				}
				i = j;
			}
		}
	}
	// *** this code currently isn't needed ***
	/*
	let cm_whitelist = M instanceof Map;
	for (let i = 0, e = cps.length; i < e; ) {
		let cp = cps[i++];
		let seqs = cm_whitelist && M.get(cp);
		if (seqs) { 
			// list of codepoints that can follow
			// if this exists, this will always be 1+
			let j = i;
			while (j < e && CM.has(cps[j])) j++;
			let cms = cps.slice(i, j);
			let match = seqs.find(seq => !compare_arrays(seq, cms));
			if (!match) throw new Error(`disallowed combining mark sequence: "${safe_str_from_cps([cp, ...cms])}"`);
			i = j;
		} else if (!V.has(cp)) {
			// https://www.unicode.org/reports/tr39/#mixed_script_confusables
			let quoted = quoted_cp(cp);
			for (let cp of cps) {
				let u = UNIQUE.get(cp);
				if (u && u !== g) {
					// if both scripts are restricted this error is confusing
					// because we don't differentiate RestrictedA from RestrictedB 
					if (!u.R) quoted = `${quoted} is ${u.N}`;
					break;
				}
			}
			throw new Error(`disallowed ${g.N} character: ${quoted}`);
			//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);
			//throw new Error(`${g.N} does not allow: ${quoted}`);
		}
	}
	if (!cm_whitelist) {
		let decomposed = nfd(cps);
		for (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading
			if (CM.has(decomposed[i])) {
				let j = i + 1;
				while (j < e && CM.has(decomposed[j])) j++;
				if (j - i > M) {
					throw new Error(`too many combining marks: "${str_from_cps(decomposed.slice(i-1, j))}" (${j-i}/${M})`);
				}
				i = j;
			}
		}
	}
	*/
}

// given a list of codepoints
// returns a list of lists, where emoji are a fully-qualified (as Array subclass)
// eg. explode_cp("abcðŸ’©d") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]
// 20230818: rename for 'process' name collision h/t Javarome
// https://github.com/adraffy/ens-normalize.js/issues/23
function tokens_from_str(input, nf, ef) {
	let ret = [];
	let chars = [];
	input = input.slice().reverse(); // flip so we can pop
	while (input.length) {
		let emoji = consume_emoji_reversed(input);
		if (emoji) {
			if (chars.length) {
				ret.push(nf(chars));
				chars = [];
			}
			ret.push(ef(emoji));
		} else {
			let cp = input.pop();
			if (VALID.has(cp)) {
				chars.push(cp);
			} else {
				let cps = MAPPED.get(cp);
				if (cps) {
					chars.push(...cps); // less than 10 elements
				} else if (!IGNORED.has(cp)) {
					// 20230912: unicode 15.1 changed the order of processing such that
					// disallowed parts are only rejected after NFC
					// https://unicode.org/reports/tr46/#Validity_Criteria
					// this doesn't impact normalization as of today
					// technically, this error can be removed as the group logic will apply similar logic
					// however the error type might be less clear
					throw error_disallowed(cp);
				}
			}
		}
	}
	if (chars.length) {
		ret.push(nf(chars));
	}
	return ret;
}

function filter_fe0f(cps) {
	return cps.filter(cp => cp != FE0F);
}

// given array of codepoints
// returns the longest valid emoji sequence (or undefined if no match)
// *MUTATES* the supplied array
// disallows interleaved ignored characters
// fills (optional) eaten array with matched codepoints
function consume_emoji_reversed(cps, eaten) {
	let node = EMOJI_ROOT;
	let emoji;
	let pos = cps.length;
	while (pos) {
		node = node.get(cps[--pos]);
		if (!node) break;
		let {V} = node;
		if (V) { // this is a valid emoji (so far)
			emoji = V;
			if (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()
			cps.length = pos; // truncate
		}
	}
	return emoji;
}

// ************************************************************
// tokenizer 

const TY_VALID = 'valid';
const TY_MAPPED = 'mapped';
const TY_IGNORED = 'ignored';
const TY_DISALLOWED = 'disallowed';
const TY_EMOJI = 'emoji';
const TY_NFC = 'nfc';
const TY_STOP = 'stop';

function ens_tokenize(name, {
	nf = true, // collapse unnormalized runs into a single token
} = {}) {
	init();
	let input = explode_cp(name).reverse();
	let eaten = [];
	let tokens = [];
	while (input.length) {
		let emoji = consume_emoji_reversed(input, eaten);
		if (emoji) {
			tokens.push({
				type: TY_EMOJI,
				emoji: emoji.slice(), // copy emoji
				input: eaten,
				cps: filter_fe0f(emoji)
			});
			eaten = []; // reset buffer
		} else {
			let cp = input.pop();
			if (cp == STOP) {
				tokens.push({type: TY_STOP, cp});
			} else if (VALID.has(cp)) {
				tokens.push({type: TY_VALID, cps: [cp]});
			} else if (IGNORED.has(cp)) {
				tokens.push({type: TY_IGNORED, cp});
			} else {
				let cps = MAPPED.get(cp);
				if (cps) {
					tokens.push({type: TY_MAPPED, cp, cps: cps.slice()});
				} else {
					tokens.push({type: TY_DISALLOWED, cp});
				}
			}
		}
	}
	if (nf) {
		for (let i = 0, start = -1; i < tokens.length; i++) {
			let token = tokens[i];
			if (is_valid_or_mapped(token.type)) {
				if (requires_check(token.cps)) { // normalization might be needed
					let end = i + 1;
					for (let pos = end; pos < tokens.length; pos++) { // find adjacent text
						let {type, cps} = tokens[pos];
						if (is_valid_or_mapped(type)) {
							if (!requires_check(cps)) break;
							end = pos + 1;
						} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { 
							break;
						}
					}
					if (start < 0) start = i;
					let slice = tokens.slice(start, end);
					let cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens
					let cps = nfc(cps0);
					if (compare_arrays(cps, cps0)) { // bundle into an nfc token
						tokens.splice(start, end - start, {
							type: TY_NFC, 
							input: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps
							cps, 
							tokens0: collapse_valid_tokens(slice),
							tokens: ens_tokenize(str_from_cps(cps), {nf: false})
						});
						i = start;
					} else { 
						i = end - 1; // skip to end of slice
					}
					start = -1; // reset
				} else {
					start = i; // remember last
				}
			} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?
				start = -1; // reset
			}
		}
	}
	return collapse_valid_tokens(tokens);
}

function is_valid_or_mapped(type) {
	return type == TY_VALID || type == TY_MAPPED;
}

function requires_check(cps) {
	return cps.some(cp => NFC_CHECK.has(cp));
}

function collapse_valid_tokens(tokens) {
	for (let i = 0; i < tokens.length; i++) {
		if (tokens[i].type == TY_VALID) {
			let j = i + 1;
			while (j < tokens.length && tokens[j].type == TY_VALID) j++;
			tokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});
		}
	}
	return tokens;
}

exports.ens_beautify = ens_beautify;
exports.ens_emoji = ens_emoji;
exports.ens_normalize = ens_normalize;
exports.ens_normalize_fragment = ens_normalize_fragment;
exports.ens_split = ens_split;
exports.ens_tokenize = ens_tokenize;
exports.is_combining_mark = is_combining_mark;
exports.nfc = nfc;
exports.nfd = nfd;
exports.safe_str_from_cps = safe_str_from_cps;
exports.should_escape = should_escape;
