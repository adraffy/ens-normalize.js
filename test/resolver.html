<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ENS Resolver</title>
<style>
:root {
	--btn-fill-color: #eee;
	--btn-hover-fill-color: #ccc;
	--btn-border-color: #888;
	--copied-color: #8f8;
}
.hide {
	display: none !important;
}
.balloon {
	flex: 1;
}
.long {
	white-space: pre-wrap !important;
	line-break: anywhere;
}
.force-ltr {
	direction: ltr;
	unicode-bidi: bidi-override;
}
a, button {
	cursor: pointer;
}
button {
	appearance: none;
	margin: 0;
	padding: 4px 8px;
	border: 1px solid var(--btn-border-color);
	border-radius: 4px;
	background-color: var(--btn-fill-color);
	color: #000;
	font-size: 100%;
}
button:disabled {
	opacity: 50%;
	pointer-events: none;
}
button:hover {
	background-color: var(--btn-hover-fill-color);
}
button:hover:active {
	background-color: #aaa;
	/*transform: translate(0px, 1px);*/
}
body { 
	margin: 3rem; 
	background: #eee;
	display: flex;
	flex-direction: column;
	gap: 8px;
	overflow-y: scroll;
}
header {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	gap: 4px 8px;
}
h1 {
	margin: 0;
}
#provider {
	font-size: 11pt;
	font-weight: normal;
	color: #666;
	display: flex;
	flex-direction: column;
	flex-wrap: wrap;
	align-items: start;
	align-self: end;
}
#provider button {
	margin-left: 5px;
	font-size: 9pt;
	padding: 2px 6px;
}
#provider .error {
	background-color: #fcc;
	color: #000;
	padding: 1px 4px;
	border-radius: 4px;
	font-size: 90%;
}
#provider a {
	font-weight: bold;
}
#github {
	flex: 1;
	text-align: right;
	display: flex;
	flex-direction: column;
	gap: 2px;
	order: 2;
	align-items: end;
}
#github a {	
	white-space: pre;
}
body.testnet {
	background: #fef;
}
body.testnet #provider a {
	background: #f3f;
	color: #fff;
	border-radius: 4px;
	padding: 2px 4px;
	margin: -2px 0;
	text-decoration: none;
}
.spinner {
	width: 32px;
	height: 32px;
	box-sizing: border-box;
	animation: spin 2s infinite linear;
	border: 5px solid #000;
	border-bottom-color: transparent;
	border-radius: 100%;
}
@keyframes spin {
	to { transform:rotate(360deg); }
}
#examples {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 4px;
	font-size: 11pt;
	padding-bottom: 6px;
	border-bottom: 2px solid #fff;
}
#examples b {
	font-size: 12pt;
}
#examples button:not([id]) {
	background: #fff;
	padding: 2px 4px;
	border: 2px solid transparent;
	transition: transform 0.1s;
	font-size: 10pt;
}
#examples button:not([id]):hover {
	border-color: #aaa;
	transform: scale(1.5);
}
#examples button:not([id]):hover:active {
	border-color: #000;
}
#examples button.mapped:not([id]) {
	border-color: #ccf;
}
#examples button.error:not([id]) {
	border-color: #fcc;
}
#examples a {
	background-color: #ffc;
}
#examples_btn {
	font-weight: bold;
}
#input {
	display: flex;
	align-items: stretch;
	gap: 8px;
}
#input input {
	box-sizing: border-box;
	width: 100%;
	padding: 8px;
	font-size: 20pt;
}
#actions {
	min-height: 32px; /* spinner */
	display: flex;
	flex-wrap: wrap;
	justify-content: flex-end;
	align-items: stretch;
	gap: 8px;
	margin-bottom: 4px;
}
.segmented {
	display: flex;
}
.segmented button:not(:last-child) {
	border-top-right-radius: 0;
	border-bottom-right-radius: 0;
}
.segmented button:not(:first-child) {
	border-left: 0;
	border-top-left-radius: 0;
	border-bottom-left-radius: 0;
}
#options {
	display: flex;
	flex-wrap: wrap;
	align-items: stretch;
	gap: 6px;
}
#options input {
	display: none;
}
#options label {
	display: flex;
	gap: 4px;
	align-items: center;
	padding: 2px 4px;
	border-radius: 4px;
	border: 2px solid #ccc;
	user-select: none;
	color: #666;
	background-color: #fff;
}
#options :disabled + label {
	opacity: 0.5;
}
#options :not(:disabled) + label {
	cursor: pointer;
}
#options :not(:disabled) + label:hover {
	outline: 2px solid #000;
}
#options :checked + label {	
	color: #000;
}
#auto_resolve_check:checked + label {
	border-color: #5c5;
	background: linear-gradient(90deg, #fff, #cfc);
}
#show_details_check:checked + label {
	border-color: #ca4;
	background-color: #edb;
	/* font: 85% monospace; */
	color: #432;
}
#show_components_check:checked + label {
	border-color: #0aa;
	background-color: #cff;
}
#show_records_check:checked + label {
	border-color: #aa0;
	background-color: #ffa;
}
#skip_norm_check:checked + label {
	border-color: #f00;
	background-color: #f00;
	color: #fff;
}
#force_ltr_check:checked + label {	
	border-color: #555;
	background-color: #555;
	color: #fff;
}
#force_mainnet_check:checked + label {
	border-color: #58f;
	background-color: #58f;
	color: #fff;
}
#resolve_btn {
	font-weight: bold;
}
#output {
	display: flex;
	flex-direction: column;
	gap: 8px;
	font-size: 14pt;
}
#output button {
	font-size: 11pt;
}
.row-label {
	order: -10;
	text-align: right;
	font-weight: bold;
	white-space: pre-wrap;
}
.row-label a {	
	color: #000;
}
.row {
	padding: 8px;
	background: #fff;
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 8px;
	border-radius: 4px;
}
.row.display {
	background: #eff;
}
.row.normalized {
	background: #efe;
	outline: 1px solid #cdc;
	border-radius: 0;
}
.row.addr {
	background: #fffff0;
}
.row.dns {
	background:#f5faff; 
}
.row.old {
	opacity: 65%;
}
.row.old:not(.details) {
	outline: 1px solid #ccc;
}
.row.dns .main {
	border-bottom-style: dotted;
}
.row.dns.invalid {
	background: #fff0f0;	
	outline: 3px dashed #fcc;
}
.row.pretty {
	background: linear-gradient(90deg, #fff, #fff0fc);
}
.row.category {
	background: #ffe;
}
.row.category .row-label {
	color: #654;
}
.row.category + .row.category {
	margin-top: -6px;
}
.formula {
	display: flex;
	flex-wrap: wrap;
	gap: 4px;
}
.formula a {
	padding: 4px;
	cursor: pointer;
	color: #000;
	text-decoration: none;
}
.formula a:hover {
	background: #cff;
}
.formula a sup {
	font-family: monospace;
}
.row .main {
	display: inline;
	font-size: 16pt;
	border-bottom: 2px solid #000;
	line-height: 130%;
}
ul.row {
	margin: 4px 0;
	padding: 16px 16px 16px 36px;
	flex-direction: column;
	align-items: start;
}
ul .tokens {
	display: inline-flex;
}
.row.readme {
	background: #ffc;
}
.row.readme code {
	background: #cff;
	padding: 1px;
}
a.internal {
	font-weight: bold;
}
.row.legend {
	background: #fff;
	list-style: disclosure-closed;
	gap: 8px;
}
.row.legend .tokens {
	min-height: 32px;
}
.row.links {
	display: grid;	
	gap: 8px;
	grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
	background: #eff;
	order: 100;
}
a.wide {
	line-break: anywhere;
}
sub {
	user-select: none;
}
span.tags {
	background: #ddd;
	color: #555;
	padding: 4px 8px;
	font-size: 12pt;
	border-radius: 4px;
	/* border: 1px solid #ccc; */
	white-space: pre;
}
button.copy {
	align-self: center;
	padding: 0;
	border: none;
	width: 28px;
	height: 28px;
	border-radius: 4px;
	background-color: inherit;
	background-position: center;
	background-repeat: no-repeat;
	background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='24' shape-rendering='geometricPrecision' stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' viewBox='0 0 24 24' width='24' style='color:var(--geist-foreground)'%3E%3Cpath d='M6 17C4.89543 17 4 16.1046 4 15V5C4 3.89543 4.89543 3 6 3H13C13.7403 3 14.3866 3.4022 14.7324 4M11 21H18C19.1046 21 20 20.1046 20 19V9C20 7.89543 19.1046 7 18 7H11C9.89543 7 9 7.89543 9 9V19C9 20.1046 9.89543 21 11 21Z'/%3E%3C/svg%3E");
}
button.copy:hover {
	background-color: var(--copied-color);
}
button.copy.copied {
	background-color: var(--copied-color);
	background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='24' shape-rendering='geometricPrecision' stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' viewBox='0 0 24 24' width='24' style='color:var(--geist-foreground)'%3E%3Cpath d='M20 6L9 17l-5-5'/%3E%3C/svg%3E");
}
.tags.long { order: 30; }
.tags.old {
	background-color: #df8;
	order: 8;
}
.tags.ens { order: 9; }
.tags.metadata { order: 10; }
.tags.external { order: 11; font-size: 80%; }
.tags.invalid { color: #f00; }
.tags.elapsed {
	background: #f0f0f0;
	font: 9pt sans-serif;
	order: 50;
}
.tags.normalized { background: #8f8; }
.tags.normalized.ascii {
	background: #00f;
	color: #fff;
	font-family: monospace;
}
.tags.length {
	background: #f8eedd;
}
.tags.iface {
	display: flex;
	align-items: center;
	gap: 4px;
	text-decoration: none;
	background-color: #dde;
	padding: 4px 8px;
	border-radius: 4px;
	white-space: pre;
	color: #000;
}
.tags.iface:hover {
	background-color: #bbd;
}
.tags.iface code {
	font-size: 13px;
	color: #666;
}
.tags.iface code.prefix {
	color: #00f;
}
.tags.good {
	color: #060;
	background: #cfc;
}
.tags.fire {
	color: #000;
	background: #fdb;
}
.tags.warn {
	background: #ffc;
}
.tags.attn {
	/* background: #fe0;
	color: #000; */
	background: #d47;
	color: #fff;
}
.tags.second {
	background: #fff0dd;
}
.tags.fail {
	background: #fcc;
	color: #600;
}
.tags.special {
	background: #f84;
	border: none;
	color: #fff;
}
.tags.clean {
	background: none;
	border: none;
	padding: 0;
	font-size: 110%;
	order: 7;
}
.tags.white {
	color: #000;
	background: #fff;
}
.jazz {
	order: -9;
	width: 1.2rem;
	height: 1.2rem;
	border-radius: 4px;
	display: flex;
	align-items: center;
	justify-content: center;
	color: #fff;
	font: bold 12px monospace;
}
.jazz.addr1 { background-color: #66f; }
.jazz.addr2 { background-color: #c4c; }
.jazz.addr3 { background-color: #0a8; }
.jazz.addr4 { background-color: #0a8; }
.avatar {
	order: -1;
} 
.avatar img {
	position: relative;
	z-index: 1;
	display: block;
	border-radius: 4px;
	width: 32px;
	height: 32px;
	transition: transform 0.2s;
}
.avatar img:hover {
	transform: scale(3);
}
button.glow {
	border: 2px solid #2c2;
}
.row.details {
	display: grid;
	background: none;
	padding: 0;
	grid-template-columns: 2fr min-content 3fr;
	align-items: start;
	gap: 4px;
	font-size: 12pt;
	box-sizing: border-box;
}
.details a.hashproof {
	color: #000;
	font-weight: bold;
	text-decoration: none;
}
.details a.hashproof:hover {
	text-decoration: underline;
}
#output .details button {
	white-space: pre;
	font-size: 85%;
	padding: 2px 4px;
}
.details .length {
	color: #777;
	background: #f8eedd;
	border: 1px solid #ccc;
	text-align: center;
	padding: 2px 4px;
	border-radius: 5px;
	justify-self: center;
}
.details .label {
	font-size: 14pt;
	display: flex;
	text-align: center;
	background: linear-gradient(90deg, #cfc8, #0000);
}
.details .label br {
	display: none;
}
.details .label .text {
	flex: 1;
}
.details .label.error {
	background: linear-gradient(90deg, #fcc, #0000);
}
.details .label.mapped {
	background: linear-gradient(90deg, #ccf8, #0000);
}
.details code {
	font-size: 90%;
}
.details code,
.details .label {	
	max-height: 10rem;
	overflow-y: auto;
}
.details .group {
	color: #666;
	text-align: left;
	font-style: italic;
	padding-right: 10px;
	font-size: 85%;
}
.details .restricted {
	display: flex;
	align-items: center;
	background: #ffc;
	border: 1px solid #ddd;
	padding: 1px 3px;
	text-decoration: none;
	font-size: 85%;
	color: #000;
}
.details .restricted:hover {
	background-color: #cff;
}
.details .disabled {
	opacity: 50%;
	user-select: none;
}
.details .wide {
	grid-column: 1 / -1;
	text-align: center;
	line-break: anywhere;
	padding-bottom: 2px;;
	border-bottom: 3px solid #fff;
} 
.details .wide:first-child {
	padding-bottom: 5px;
}
.details .wide:last-child {
	border-bottom: none;
}
.details .footer {
	font-size: 90%;
	color: #666;
	padding: 4px 0;
}
.details .footer .error {
	color: #d00;
	font-size: 11pt;
	font-weight: bold;	
	background: #fee;
}
.details .footer.sep {	
	border-top: 1px dotted #aaa;
}
.tokens {
	font-size: 16pt;
}
.exploded > .error {
	background-color: #f97;
	padding: 3px;
	border-radius: 5px;
}
.exploded > .error.first {
	background: #f77;
}
.row.records {
	background-color: #ffc;
}
.record {
	display: flex;
	color: #000;
	font-size: 90%;
	text-decoration: none;
	align-items: center;
	background: #fff;
	padding: 4px 8px;
	border-radius: 4px;
	border: 1px solid #ccc;
	gap: 4px;
}
.record.copied {
	background-color: var(--copied-color);
}
.record b {
	font: 11px sans-serif;
	color: #666;
}
.record:hover {
	outline: 2px solid #00f;
}
.record img,
.record svg {
	width: 18px;
	height: auto;
}
.row.error {
	background: #fcc;
	outline: 3px dashed #d00;
	border-radius: 0;
}
.row.contract:not(.error) {
	background-color: #fffcf6;
	outline: 2px dashed #cc0;
}
.row.contract {
	position: relative;
}
.row.contract::before {
	position: absolute;
	top: 3px;
	right: 6px;
	content: 'Contract';
	font: 11px monospace;
	color: #999;
}
.transform {
	background: #fffaf0;
}
#recent_select {
	outline: none;
	width: 37px;
	padding: 0;
	margin: 0;
	border: 1px solid var(--btn-border-color);
	border-radius: 4px;
	cursor: pointer;
	font-size: 100%;
	appearance: none;
	background: no-repeat center url("data:image/svg+xml,%3Csvg height='21' width='20' version='1.1' viewBox='0 0 20 21' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10.5,0 C7,0 3.9,1.9 2.3,4.8 L0,2.5 L0,9 L6.5,9 L3.7,6.2 C5,3.7 7.5,2 10.5,2 C14.6,2 18,5.4 18,9.5 C18,13.6 14.6,17 10.5,17 C7.2,17 4.5,14.9 3.4,12 L1.3,12 C2.4,16 6.1,19 10.5,19 C15.8,19 20,14.7 20,9.5 C20,4.3 15.7,0 10.5,0 L10.5,0 Z M9,5 L9,10.1 L13.7,12.9 L14.5,11.6 L10.5,9.2 L10.5,5 L9,5 L9,5 Z'/%3E%3C/svg%3E"), no-repeat bottom 3px right 2px url("data:image/svg+xml,%3Csvg style='fill: currentColor' width='8' height='4' viewBox='0 0 8 4' version='1.1' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h8l-4 4Z' /%3E%3C/svg%3E") var(--btn-fill-color);
}
#recent_select:hover,
#recent_select:active {
	background-color: var(--btn-hover-fill-color);
}
footer {
	text-align: center;
	color: #666;
	margin: 8px 0 16px;
}
footer span {
	cursor: help;
}
footer span:hover {	
	color: #000;
}
@media only screen and (max-width: 800px) { 
	body {
		margin: 0;
	}
	button {
		font-size: 100%;
	}
	header {
		margin: 16px;
		margin-bottom: 0;
	}
	#provider {
		order: 3;
		flex-direction: row;
		align-items: center;
		gap: 4px;
		width: 100%;
	}
	#input input {
		font-size: 20pt;
	}
	#input, #actions, #options, #examples {
		margin: 0 16px;
	}
	#content {
		font-size: 12pt;
	}
	a.wide {
		font-size: 95%;
	}
	.row {
		justify-content: center;
	}
	.row.details .wide {
		padding-left: 5px;
		padding-right: 5px;
	}
	.row.details .label {
		flex-direction: column-reverse;
		align-items: center;
		margin-left: 5px;
	}
	.row.details .group {
		text-align: center;
		padding-right: 0;
	}
	.row.details .restricted {
		flex-direction: row-reverse;
		font-size: 75%;
	}
	#examples_btn {
		display: block;
		width: 100%;
		margin-bottom: 4px;
		font-size: 14pt;
		padding: 4px;
	}
	#output {
		font-size: 13pt;
	}
}
@media only screen and (max-width: 400px) { 
	h1 a {
		display: none;
	}
}
</style>
</head>
<body>
<header>
	<h1><a href="https://ens.domains/">ENS</a> Resolver</h1>
	<div id="provider"></div>
	<div id="github">
		<a href="https://github.com/adraffy/ens-normalize.js">adraffy/ens-normalize.js</a>
		<a href="https://docs.ens.domains/ens-improvement-proposals/ensip-15-normalization-standard">ENSIP-15</a>
	</div>
</header>
<div id="examples" class="hide">
<button>vitalik.eth</button>
<button>nIcK.eTh</button>
<button>brantly.cash</button>
<button>🏴‍☠.art</button>
<button>..a..eth</button>
<button>öbb</button>
<button>Öbb</button>
<button data-name="◌̈bb">◌̈bb</button>

<a href="https://adraffy.github.io/punycode.js/test/demo.html"><b>Punycode:</b></a>
<button>xn--ls8h</button>
<button>xn--💩</button>
<button>💷pound.eth</button>

<a href="https://github.com/ensdomains/ens-contracts/tree/master/contracts/wrapper#namewrapper-docs"><b>Wrapped:</b></a>
<button>firstwrappedname.eth</button>
<button>dessert3.menu.bestsushi7.eth</button>

<b>Subdomain:</b>
<button data-name="nowzad.loopring.eth">loopring</button>
<button data-name="239.chonksociety.eth">Chonk #239</button>
<button>raffy.antistupid.com</button>

<a href="https://docs.ens.domains/ens-improvement-proposals/ensip-10-wildcard-resolution"><b>Wildcard:</b></a>
<button>moo331.nft-owner.eth</button>
<button>💎.gmcafe.art</button>
<button>1.offchainexample.eth</button>
<button>barmstrong.cb.id</button>

<!--
<a href="./display.html"><b>Display:</b></a>
<button>ADRaffy</button>
-->

<b>Address:</b>
<button data-name="0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045">d8dA..6045</button>

<b>Contract:</b>
<button data-name="eth-usd.data.eth">Chainlink ETH-USD</button>

<b>Preimage:</b>
<button data-delay="1000" data-name="token:91842011529764390124322931916134555051359118325819011691525342013207339157209">Token#</button>
<button data-delay="1000" data-name="https://opensea.io/assets/ethereum/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209">OpenSea</button>
<button data-delay="1000" data-name="https://www.gem.xyz/asset/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209">Gem</button>

<a href="./chars.html"><b>Mapped:</b></a>
<button data-name="hyph{2D}{2010}{2011}{2012}{2013}{2014}{2015}{2043}{2212}{23AF}{23E4}{FE58}e{2E3A}n{2E3B}s">Hyphens</button>
<button>A.™️.Ю</button>
<button>Ⅷ</button>
<button>⨌</button>

<b>Ignored:</b> 
<button data-name="{FE0E}{FE0F}">Emoji Style</button>

<b>Disallowed:</b>
<button data-name="{26}{3000}{E0061}{FFFFFF}{200D}">Types</button>
<button data-name="test .te st. test">Whitespace</button>
<button data-name="{3002}.{FF0E}.{FF61}">Alt Stops</button>
<button data-name="y{303}.{1EF9}">Invalid NFC</button>
<button data-name="{DF00}">Surrogate</button>
<button data-name="[ba967c160905ade030f84952644a963994eeaed3881a6b8a4e9c8cbe452ad7a2].eth" data-skip="1">"💩.eth"</button>

<b>Deviation:</b> 
<button>ß</button>
<button>ẞ</button>
<button>ς</button>

<b>Complex:</b>
<button data-name="_1{FE0F}E{FE0E}{303}{AD}{1F4A9}{24C2}{FE0E}{2E3B}a{301}"></button>

<b>Combining Marks:</b>
<button data-name="{300}">Leading</button>
<button data-name="💩{300}">Emoji</button>
<button data-name="x{300}{300}">Whitelisted</button>
<button data-name="{622}{64D}{64E}.{929}{901}{902}">NFD w/CM</button>

<b>NSM:</b>
<button data-name="{625}{610}{610}">Repeated</button>
<button data-name="{625}{610}{611}{612}{613}{614}">Too Many</button>

<a href="https://unicode.org/reports/tr46/#Validity_Criteria"><b>CheckHyphen:</b></a>
<button>-test.test-.t-e--s---t</button>
<button>te--st</button>

<b>Underscore:</b>
<button>__ab</button>
<button>a_b</button>

<a href="./emoji.html"><b>Emoji:</b></a>
<button>©</button>
<button>🕵</button>
<button>🧙‍♂</button>
<button>🏋🏿‍♂</button>
<button data-name="💩💩💩">💩<sup>3</sup></button>
<button data-name="🍞🍞🍞🍞🍞🍞🍞🍞🍞🍞🍞🍞🍞">🍞<sup>13</sup></button>
<button data-name="👁🗨👁️‍🗨️">👁️‍🗨️</button>
<button data-name="🧟🧟♂🧟‍♂">🧟</button>
<button>😵‍💫😵‍💫😵‍💫</button>
<button>😵💫😵💫😵💫</button>
<button>👩‍⚕👩🏽‍⚕️</button>
<button>👪👨‍👩‍👦</button>
<button data-name="🚴️🚵️🚴🏻🚴🏼🚴🏽🚴🏾🚴🏿🚵🏻🚵🏼🚵🏽🚵🏾🚵🏿🚴‍♀️🚴‍♂️🚵‍♀️🚵‍♂️🚴🏻‍♀️🚴🏻‍♂️🚴🏼‍♀️🚴🏼‍♂️🚴🏽‍♀️🚴🏽‍♂️🚴🏾‍♀️🚴🏾‍♂️🚴🏿‍♀️🚴🏿‍♂️🚵🏻‍♀️🚵🏻‍♂️🚵🏼‍♀️🚵🏼‍♂️🚵🏽‍♀️🚵🏽‍♂️🚵🏾‍♀️🚵🏾‍♂️🚵🏿‍♀️🚵🏿‍♂️">🚴️ Bikes (36)</button>
<button data-name="🦰🦱🦲🦳">🦰</button>
<button>👨‍👩‍👦🏿</button>
<button data-name="{1F3FB}{1F3FC}{1F3FD}{1F3FE}{1F3FF}">🏻</button>
<button data-name="💩{200D}💩">💩+💩</button>
<button data-name="{261D}{FE0F}{1F3FB}"></button>
<button>‼️</button>
<button>⁉️</button>
<button data-name="™ℹⓂ㊗㊙🈁🈂🈚🈯🈲🈳🈴🈵🈶🈷🈸🈹🈺🉐🉑">☹️ Demoted</button>

<b>Non-RGI:</b>
<button>🐱‍🐉</button>
<button>👪🏻</button>
<button>🤼🏻‍♀️</button>
<button data-name="{1F469}{1F3FE}{200D}{1F91D}{200D}{1F469}{1F3FE}">Mod+Mod</button>

<b>Regional:</b>
<button>🇦</button>
<button>🇦🇦</button>
<button>🇺🇸🇺🇲</button>

<b>Flag:</b>
<button>🏴</button>
<button>🏁️</button>
<button>🏳️‍🌈</button>

<a href="https://www.unicode.org/reports/tr51/#DisplayValidEmojiTagSeqs"><b>Tag:</b></a>
<button>{1F3F4}{E0067}{E0062}{E0065}{E006E}{E0067}{E007F}</button>
<button>{1F3F4}{E0067}{E0062}{E0073}{E0063}{E0074}{E007F}</button>
<button>{1F3F4}{E0067}{E0062}{E0077}{E006C}{E0073}{E007F}</button>
<button data-name="{1F3F4}{E0075}{E0073}{E0063}{E0061}{E007F}">usca</button>

<b>Circled/Squared:</b>
<button>i{2139}{2139}{FE0F}🛈</button>
<button data-name="ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ">Ⓐ-Ⓩ</button>
<button data-name="ⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ">ⓐ-ⓩ</button>
<button data-name="⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳㉑㉒㉓㉔㉕㉖㉗㉘㉙㉚㉛㉜㉝㉞㉟">⓪-㉟</button>
<button data-name="🅰🅱🅲🅳🅴🅵🅶🅷🅸🅹🅺🅻🅼🅽🅾🅿🆀🆁🆂🆃🆄🆅🆆🆇🆈🆉">🅰-🆉</button>
<button data-name="🅐🅑🅒🅓🅔🅕🅖🅗🅘🅙🅚🅛🅜🅝🅞🅟🅠🅡🅢🅣🅤🅥🅦🅧🅨🅩">🅐-🅩</button>
<button data-name="⓿❶❷❸❹❺❻❼❽❾❿⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴">⓿-❿</button>
<button data-name="🄌➊➋➌➍➎➏➐➑➒➓">🄌-➓</button>
<button data-name="㉈㉉㉊㉋㉌㉍㉎㉏">㉈-㉏</button>

<a href="https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.1"><b>ContextJ:</b></a>
ZWNJ:
<button data-name="ന്{200C}മ"></button>
<button data-name="نیم‌فاصله"></button>
<button data-name="a{200C}b"></button>

ZWJ:
<button data-name="ണ്‍"></button>
<button data-name="a{200D}b"></button>

<a href="https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.3"><b>ContextO:</b></a>
Middle Dot: 
<button data-name="{6C}{B7}{6C}"></button>

Katakana Dot:
<button data-name="月・水"></button>
<button data-name="a・a{300}"></button>

Greek Keraia: 
<button data-name="{375}α"></button>

Hebrew Geresh:
<button data-name="{5D1}{5F3}"></button>


<a href="https://www.rfc-editor.org/rfc/rfc5893.html#section-2"><b>CheckBidi:</b></a>
<button>פעילותהבינאום</button>
<button data-name="{0786}{07AE}{0782}{07B0}{0795}{07A9}{0793}{07A6}{0783}{07AA}">Dhivehi</button>
<button data-name="{05D9}{05B4}{05D5}{05D0}{05B8}">Yiddish</button>
<button data-name="{1F1F8}{1F1E6}{633}{644}{645}{627}{646}">Emoji+RTL</button>
<button data-name="{633}{644}{645}{627}{646}{1F1F8}{1F1E6}">RTL+Emoji</button>
<button data-name="bahrain.مصر">LTR.RTL</button>
<button data-name="bahrainمصر">LTR+RTL in Label</button>
<button data-name="{202e}elgoog{202d}.eth">.ethgoogle</button>
<button data-name="{202e}hte.elgoog">google.eth</button>

<b>Keycaps:</b>
<button>1⃣2️⃣🔟.eth</button>
<button data-name="0️⃣1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣🔟*️⃣#️⃣">*️⃣-🔟</button>

<a href="https://unicode-org.github.io/cldr-staging/charts/latest/by_type/core_data.alphabetic_information.main.html">Exemplars</a> /
<a href="https://util.unicode.org/UnicodeJsps/confusables.jsp"><b>Confusables:</b></a>
<button>aα.ɑ</button>
<button>ஶ்ரீ.ஸ்ரீ</button>
<button data-name="i.i{307}.{131}{307}">i̇</button>
<button data-name="{E8}.e{300}.{450}.{435}{300}">è</button>

<b>Mixed-Script:</b>
<button data-name="0a〇.黑a8">Digit+Latin+Han</button>
<button data-name="あアいイうウえエおオ">Kana+Hira</button>
<button data-name="bitcoin.bitcοin.bi̇tcoin.bitсoin">"bitcoin"</button>
<button>ァ힣</button>

<b>Whole-Script:</b>
<button data-name="0x.0χ.0х">"0x"</button>
<button data-name="apple.дррӏе.аррӏе.aррӏе">"apple"</button>
<button data-name="ιοσρβυνγ">Greek</button>
<button data-name="o.٥.०.౦.੦.൦.ο.օ">"o"</button>
<button data-name="あー.〇一.一ー.一.ー.ᅳ">CJK Dash</button>

<a href="https://unicode.org/emoji/charts/emoji-released.html"><b>Unicode 15.0:</b></a>
<button data-name="{1F6DC}{1FA75}{1FA76}{1FA77}{1FA87}{1FA88}{1FAAD}{1FAAE}{1FAAF}{1FABB}{1FABC}{1FABD}{1FABF}{1FACE}{1FACF}{1FADA}{1FADB}{1FAE8}{1FAF7}{1FAF8}">Single Emoji (20)</button>
<button data-name="{1FAF7}{1F3FB}{1FAF7}{1F3FC}{1FAF7}{1F3FD}{1FAF7}{1F3FE}{1FAF7}{1F3FF}{1FAF8}{1F3FB}{1FAF8}{1F3FC}{1FAF8}{1F3FD}{1FAF8}{1F3FE}{1FAF8}{1F3FF}">Sequences (10)</button>
<button data-name="{1F426}{200D}{2B1B}">Black Bird</button>

<a href="https://unicode.org/reports/tr51/proposed.html"><b>Unicode 15.1:</b></a>
<button>≠.≮.≯</button>
<button data-name="{26D3}{200D}{1F4A5}.{1F344}{200D}{1F7EB}.{1F34B}{200D}{1F7E9}.{1F426}{200D}{1F525}.{1F642}{200D}{2194}.{1F642}{200D}{2195}.{1F9D1}{200D}{1F9D2}.{1F9D1}{200D}{1F9D1}{200D}{1F9D2}.{1F9D1}{200D}{1F9D2}{200D}{1F9D2}.{1F9D1}{200D}{1F9D1}{200D}{1F9D2}{200D}{1F9D2}">ZWJ Sequences (10)</button>
<button data-name="{1F3C3}{1F3FB}{200D}{27A1}.{1F3C3}{1F3FB}{200D}{27A1}.{1F3C3}{1F3FC}{200D}{27A1}.{1F3C3}{1F3FD}{200D}{27A1}.{1F3C3}{1F3FE}{200D}{27A1}.{1F3C3}{1F3FF}{200D}{27A1}">Directional (108)</button>

<b>Fenced:</b>
<button>O'Brian</button>
<button data-name="¼½¾⅐⅑⅒⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞⅟↉">"½"</button>
<button>123⁄456’s</button>
<button data-name="a'.’z.a'’b.a⁄'.⁄a">Invalid</button>

<b>Misc:</b>
<button data-name="$¢£¤¥₡₦₩₪₫€₭₮₱₲₴₵₸₹₺₼₽₾⃀₿Ξ.؋">Currency</button>
<button data-name="•-•¬.⌐◨-◨.⌐〇-〇¬">Glasses</button>
<button>360°</button>
<button data-name="2πr.4πθ.8п">"π"</button>
<button>Ξ.≡.☰</button>
<button>♢⟠⧫</button>
<button data-name="_▁▂▃▄▅▆▇█">▃▅▇</button>
<button data-name="✓.✔︎.✔️.✅️.☑️">Checks</button>
<button data-name="ᴀʙᴄᴅᴇꜰɢʜɪᴊᴋʟᴍɴᴏᴘꞯʀꜱᴛᴜᴠᴡxʏᴢ">ꜱᴍᴀʟʟ ᴄᴀᴘꜱ</button>
<button data-name="zʎxʍʌnʇsɹbdouɯꞁʞſ̣ᴉɥᵷɟǝpↄqɐ">pǝuɹnʇ</button>
<button data-name="💩ąçęşìíîïǐł">Rare Latin</button>

<b>Pure:</b>
Arabic:
<button>إنترنت</button>
<button data-name="{660}{661}{662}{663}{664}{665}{666}{667}{668}{669}.{6F0}{6F1}{6F2}{6F3}{6F4}{6F5}{6F6}{6F7}{6F8}{6F9}.{6F0}{780}">Digits</button>
Hebrew:
<button>שירות־שמות</button>

<a href="https://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers"><b>Restricted:</b></a>
<button data-name="𓀀𓀁𓀂">Egyptian Hieroglyphs</button>
<button data-name="𐌱𐌻𐍉𐌼𐌰">Gothic</button>
<button>𓆏➡🐸️</button>
<button data-name="a𓀂">Mixed</button>
<button>ᏎᏮᏂᎥ.eth</button>

<a href="https://adraffy.github.io/ens-norm-tests/test-compare/output/ens_normalize.git_1.9.0_vs_eth-ens-namehash_2.0.15.html#diff-norm"><b>Different Norm:</b></a>
<button data-name="‑888">Remapped Hyphen</button>
<button data-name="۰۱۲۳۷۸۹">Mapped Arabic</button>

</div>
<div id="options">
	<button id="examples_btn">👀 Examples</button>
	<input type="checkbox" id="auto_resolve_check" checked>
	<label for="auto_resolve_check"><svg data-testid="geist-icon" fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" style="color:var(--geist-foreground);width:20px;height:20px"><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/></svg> <i>on Input</i></label>
	<input type="checkbox" id="show_details_check" checked>
	<label for="show_details_check">Details</label>
	<input type="checkbox" id="show_components_check" checked>
	<label for="show_components_check">Emoji Components</label>
	<input type="checkbox" id="show_records_check">
	<label for="show_records_check" title="Include common text and address records">Records</label>
	<input type="checkbox" id="skip_norm_check">
	<label for="skip_norm_check"  title="Use without normalization"><svg data-testid="geist-icon" fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" style="color:var(--geist-foreground);width:20px;height:20px"><circle cx="12" cy="12" r="10" fill="var(--geist-fill)"></circle><path d="M15 9L9 15" stroke="var(--geist-stroke)" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path><path d="M9 9L15 15" stroke="var(--geist-stroke)" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path></svg>Norm</label>
	<input type="checkbox" id="force_mainnet_check">
	<label for="force_mainnet_check" title="Use mainnet regardless of selected browser provider network"><svg data-testid="geist-icon" fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" style="color:var(--geist-foreground);width:20px;height:20px"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0110 0v4"/></svg> Mainnet</label>
	<input type="checkbox" id="force_ltr_check">
	<label for="force_ltr_check" title="Override Bidi Handling with Left-to-Right Direction&#10;(Applies only to Input)">LTR!</label>
</div>
<div id="input">
	<input id="input_field" size="20" placeholder="Name or Address or URL">
	<select id="recent_select" title="Recent Names" class="hide">
		<option value="reset">🗑️ Clear History</option>
		<optgroup label="Recent Names"></optgroup>
	</select>
</div>
<div id="actions">
	<div class="spinner"></div>
	<div class="balloon"></div>
	<div class="segmented">
		<button id="random_emoji_btn" title="Random Emoji&#10;[ALT] Only Use Singles">🎲</button>
		<button id="find_emoji_btn">Emoji</button>
	</div>
	<div class="segmented">
		<button id="chars_btn" title="Lookup First/Selected Character">Chars</button>
		<button id="confused_btn" title="Explain Confusable Characters">Confused</button>
	</div>
	<div class="segmented">
		<button id="nf_btn">NFD↔NFC</button>
		<button id="escape_btn" title="[ALT] Unicode Escaped">Escape</button>
	</div>
	<button id="parent_btn" title="Drop the leading label">Parent</button>
	<button id="copy_link_btn">Copy Link</button>
	<button id="resolve_btn">Resolve</button>
</div>
<div id="output">
<ul class="row readme">
<li>Click an <button data-name="👁️‍🗨️A{303}.Eth">Example</button> to see how it works.</li>
<li><code>token:__</code> lookup the <a href="../../keccak.js/test/demo.html#algo=keccak-256&s=raffy&escape=1&encoding=utf8">labelhash</a> (if known) <button data-name="token:91842011529764390124322931916134555051359118325819011691525342013207339157209" data-delay="1000">raffy.eth</button> or <a href="../../ens-labels/demo.html">search for it</a></li>
<li><code>wrapped:__</code> lookup the <a href="../../keccak.js/test/demo.html#algo=namehash&s=firstwrappedname.eth&escape=1&encoding=utf8">namehash</a> (if wrapped) <button data-name="wrapped:0xc44eec7fb870ae46d4ef4392d33fbbbdc164e7817a86289a1fe30e5f4d98ae85" data-delay="1000">firstwrappedname.eth</button></li>
<li>Use <code>{FF}</code> or <code>[255]</code> to include codepoints <button data-raw data-name="a{61}[97].eth">aaa</button></li>
<li><code>\uFFFF</code>, <code>\u{HEX}</code>, <code>&amp;#xFF;</code>, <code>&amp;#255;</code>, or <code>&amp;entity;</code> are shorthand for <code>{HEX}</code>.</li>
<li><code>HEX<sub>1</sub> HEX<sub>2</sub></code> is shorthand for <code>{HEX<sub>1</sub>}{HEX<sub>2</sub>}</code> <button data-name="65 74 68" data-meta data-delay="1000">eth</button></li>
<li><code>range:HEX<sub>1</sub>..HEX<sub>n</sub></code> expands to a range of characters <button data-name="range:61..7A" data-delay="1000">ASCII a-z</button></li>
<li><button id="copy_example_btn">Copy Link</button></a> to get a URL that resolves on page-load.</li>
<li>Many elements have tooltips with additional information.</li>
<li>Follows <a class="internal" href="https://docs.ens.domains/ens-improvement-proposals/ensip-15-normalization-standard">ENSIP-15</a> and <a href="https://docs.ens.domains/terminology">ENS Terminology</a>.</li>
<li class="req-window">Supports <button id="add_goerli_btn" class="chain">Goerli</button> and <button id="add_sepolia_btn" class="chain">Sepolia</button> testnets.</li>
</ul>
<ul class="row legend">
<li>This is a <b>valid</b> sequence of characters: <span data-tokenize="abc"></span> and <b>.eth</b> name: <span data-tokenize="abc.eth"></span></li>
<li>This is an <b>emoji</b>: <span data-tokenize="👩🏽‍⚕️"></span> and its corresponding <b>components</b>: <span data-tokenize="👩🏽‍⚕️" data-parts="1"></span></li>
<li>This is a <b>mapped</b> token: <span data-tokenize="™"></span> which transforms into a <b>valid</b> sequence: <span data-tokenize="tm"></span></li>
<li>Characters not in canonical form require <b>NFC</b>: <span data-tokenize="a{303}"></span></li>
<li>These are <b>ignored</b> characters: <span data-tokenize="{AD}{FE0F}{E0100}"></span></li>
<li>These are <b>disallowed</b> characters: <span data-tokenize="#{00}{1FFFFF}{E0061}{200D}"></span></li>
</ul>
<ul class="row links">
<li><a class="internal" href="./emoji.html">Supported Emoji</a></li>
<li><a class="internal" href="./chars.html">Characters Viewer</a></li>
<li><a class="internal" href="./confused.html">Confused Explainer</a></li>
<li><a class="internal" href="./validate.html">Validation Test</a></li>
<li><a class="internal" href="./report-nf.html">Unicode NormalizationTest</a></li>
<li><a href="../../ens-norm-tests/test-breakdown/output-20230226/">ENSIP-1→15 Breakdown</a></li>
<li><a href="https://github.com/ensdomains/ens-contracts/tree/staging/deployments/">ENS Deployments</a></li>
<li><a href="../../ens-labels/demo.html">Labelhash⁻¹</a></li>
<li><a href="https://github.com/adraffy/ens-labels/">Label Database</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-regs.html">Recent Registrations</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-renews.html">Recent Renews</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-emoji-freq.html">Emoji Frequency Browser</a></li>
<li><a href="../../emoji.js/test/demo.html">Emoji Parser</a></li>
<li><a href="../../keccak.js/test/demo.html">Keccak Hasher</a></li>
<li><a href="../../punycode.js/test/demo.html">Punycode Coder</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-batch-resolver.html">Batch Resolver</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-exp.html">Expirations</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-nft-matcher.html">ENS+NFT Matcher</a></li>
<li><a href="https://raffy.antistupid.com/eth/emoji-pixels.html">Emoji Pixel Maker</a></li>
</ul>
</div>
<footer>Created by <a href="https://x.com/adraffy">raffy.eth</a></footer>
<script type="module">
// to prepare this file for self-hosted deployment:
// * replace infura_provider with a public provider, eg. new ethers.providers.CloudflareProvider();
// * replace punycode.js import with 'https://cdn.jsdelivr.net/npm/@adraffy/punycode@latest/dist/index.min.js'
// * replace "../../" with "https://adraffy.github.io/"
import {ethers} from 'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.esm.min.js';
import {
	ens_normalize, ens_split, ens_beautify, ens_tokenize, ens_emoji,
	nfc, nfd, hex_cp, quote_cp, explode_cp, str_from_cps, safe_str_from_cps,
	dom_from_tokens, use_default_style, versions, compare_arrays, should_escape,
} from '../dist/all.min.js';
import {puny_encoded, is_surrogate} from '../../punycode.js/dist/index.min.js'; 
import eth_ens_namehash from './eth-ens-namehash@2.0.15.min.js';
use_default_style();

const EMOJI = ens_emoji();

const input_field = document.querySelector('#input_field');
const resolve_btn = document.querySelector('#resolve_btn');
const auto_resolve_check = document.querySelector('#auto_resolve_check');
const show_components_check = document.querySelector('#show_components_check');
const show_records_check = document.querySelector('#show_records_check');
const skip_norm_check = document.querySelector('#skip_norm_check');
const show_details_check = document.querySelector('#show_details_check');
const force_ltr_check = document.querySelector('#force_ltr_check');
const force_mainnet_check = document.querySelector('#force_mainnet_check');
const recent_select = document.querySelector('#recent_select');
const recent_optgroup = document.querySelector('#recent_select optgroup');
const options_div = document.querySelector('#options');
const actions_div = document.querySelector('#actions');
const primary_loader = document.querySelector('#actions .spinner');
const output_div = document.querySelector('#output');
const readme_dom = [...output_div.childNodes]; // save initial ux
const examples_div = document.querySelector('#examples');
const examples_btn = document.querySelector('#examples_btn');
const provider_div = document.querySelector('#provider');
const nf_btn = document.querySelector('#nf_btn');
const escape_btn = document.querySelector('#escape_btn');
const parent_btn = document.querySelector('#parent_btn');

const RESOLVE_MODE_IDLE = 'idle';
const RESOLVE_MODE_EMPTY = 'empty';

const STORAGE_RECENT = 'recent';
const STORAGE_AUTO_RESOLVE = 'auto_resolve';
const STORAGE_SHOW_DETAILS = 'show_details';
const STORAGE_SHOW_RECORDS = 'show_records';
const STORAGE_SHOW_COMPONENTS = 'show_components';
const STORAGE_FORCE_LTR = 'force_ltr';
const STORAGE_HIDE_EXAMPLES = 'hide_examples';

const INPUT_NAME = 'Input';
const OPENSEA_NAME = 'OpenSea';
const VISION_NAME = 'Vision';
const PRETTY_NAME = '💖️';
const MANAGER_NAME = 'Manager';
const NFT_OWNER_NAME = 'NFT Owner';

const emoji_url = './emoji.html#q=%s';

const CHAIN_ID_MAINNET = 1;
const CHAIN_ID_GOERLI = 5;
const CHAIN_ID_SEPOLIA = 11155111;
const CHAINS = [
	// https://chainlist.wtf/
	//case 3: return 'https://ropsten.etherscan.io';
	//case 4: return 'https://rinkeby.etherscan.io';
	//case 139: return 'https://polygonscan.io';	
	{
		id: CHAIN_ID_MAINNET,
		name: 'Mainnet',
		explorer: 'https://etherscan.io',
		metadata: 'https://metadata.ens.domains/mainnet',
		opensea: 'https://opensea.io/assets/ethereum/',
		is_mainnet: true,
	},
	{
		id: CHAIN_ID_GOERLI,
		name: 'Goerli',
		explorer: 'https://goerli.etherscan.io',
		metadata: 'https://metadata.ens.domains/goerli',
		opensea: 'https://testnets.opensea.io/assets/goerli/'
	},
	{
		id: CHAIN_ID_SEPOLIA,
		name: 'Sepolia',
		explorer: 'https://sepolia.etherscan.io',
		metadata: 'https://metadata.ens.domains/sepolia',
		opensea: 'https://testnets.opensea.io/assets/sepolia/',
	}
];

const MIN_ETH_LENGTH = 3;
const NFT_DOMAINS = new Set(['eth', 'art']); //, 'box']);
const REVERSE_DOMAIN = 'addr.reverse';
const RESOLVER_NAMES = {
	'0x1da022710dF5002339274AaDEe8D58218e9D6AB5': 'Old Public (v1)',
	'0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41': 'Old Public (v2)',
	'0x231b0Ee14048e9dCcD1d247744d114a4EB5E8E63': '✨️ Public (v3)',
	'0x5fBb459C49BB06083C33109fA4f14810eC2Cf358': 'Old (v1)',
	'0xA2C122BE93b0074270ebeE7f6b7292C7deB45047': '✨️ Newest (v2)',
};
const IS_CONTRACT = new Map();
const NOT_IFACE_RESOLVER = new Set();
const ADDRESS_MAP = new Map();
const IFACE_ETH_CONTROLLER = '0x612e8c09';

// https://docs.ens.domains/ens-improvement-proposals/ensip-5-text-records
// https://github.com/ensdomains/docs/blob/profile-text-records/ens-improvement-proposals/ensip-xx-profile-text-records.md
const RECORDS = [
	{
		type: 'text', 
		key: 'name',
	},
	{
		type: 'text', 
		key: 'description',
		icon: '<b>desc</b>',
	},
	// {
	// 	type: 'text', 
	// 	key: 'language',
	// },
	// {
	// 	type: 'text', 
	// 	key: 'timezone',
	// 	icon: '<b>tz</b>'
	// },
	{
		type: 'text', 
		key: 'notice',
		icon: '⚠️',
	},
	{
		type: 'text', 
		key: 'url',
		icon: '🌐️',
		format(x) {
			let match = x.match(/^https?:\/\/(.*)$/i);
			return match ? match[1] : x;
		},
		url(x) { return x; }
	},
	{
		type: 'text', 
		key: 'location'
	},	
	{
		type: 'text', 
		key: 'phone',
		icon: '☎️',
		url(x) { return `tel:${x}`; }
	},
	{
		type: 'text', 
		key: 'email',
		icon: '📧️',
		url(x) { return `mailto:${x}`; }
	},
	{
		type: 'text', 
		key: 'com.twitter', 
		icon: `<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 22 20"><path fill="var(--geist-fill, currentColor)" stroke="none" d="M16.99 0H20.298L13.071 8.26L21.573 19.5H14.916L9.702 12.683L3.736 19.5H0.426L8.156 10.665L0 0H6.826L11.539 6.231L16.99 0ZM15.829 17.52H17.662L5.83 1.876H3.863L15.829 17.52Z"/></svg>`,
		//format(x) { return `@${x}`; },
		url(x) { return `https://x.com/${encodeURIComponent(x)}`; }
	},
	{
		type: 'text', 
		key: 'farcaster', 
		url(x) { return `https://warpcast.com/${encodeURIComponent(x)}`; }
	},
	{
		type: 'text', 
		key: 'lens', 
		url(x) { return `https://hey.xyz/u/${encodeURIComponent(x)}`; }
	},
	{
		type: 'text',
		key: 'com.github', 
		icon: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="#000000"><path d="M12 0.297134C5.37 0.297134 0 5.67014 0 12.2971C0 17.6001 3.438 22.0971 8.205 23.6821C8.805 23.7951 9.025 23.4241 9.025 23.1051C9.025 22.8201 9.015 22.0651 9.01 21.0651C5.672 21.7891 4.968 19.4551 4.968 19.4551C4.422 18.0701 3.633 17.7001 3.633 17.7001C2.546 16.9561 3.717 16.9711 3.717 16.9711C4.922 17.0551 5.555 18.2071 5.555 18.2071C6.625 20.0421 8.364 19.5121 9.05 19.2051C9.158 18.4291 9.467 17.9001 9.81 17.6001C7.145 17.3001 4.344 16.2681 4.344 11.6701C4.344 10.3601 4.809 9.29014 5.579 8.45014C5.444 8.14714 5.039 6.92714 5.684 5.27414C5.684 5.27414 6.689 4.95214 8.984 6.50414C9.944 6.23714 10.964 6.10513 11.984 6.09913C13.004 6.10513 14.024 6.23714 14.984 6.50414C17.264 4.95214 18.269 5.27414 18.269 5.27414C18.914 6.92714 18.509 8.14714 18.389 8.45014C19.154 9.29014 19.619 10.3601 19.619 11.6701C19.619 16.2801 16.814 17.2951 14.144 17.5901C14.564 17.9501 14.954 18.6861 14.954 19.8101C14.954 21.4161 14.939 22.7061 14.939 23.0961C14.939 23.4111 15.149 23.7861 15.764 23.6661C20.565 22.0921 24 17.5921 24 12.2971C24 5.67014 18.627 0.297134 12 0.297134Z"></path></svg>`,
		url(x) { return `https://github.com/${encodeURIComponent(x)}`; }
	},
	{
		type: 'text',
		key: 'com.discord',
		icon: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" role="img" fill="#5A57DD"><path d="M20.7273 5.45455C20.7273 5.45455 18.2264 3.49746 15.2727 3.27273L15.0065 3.80509C17.6771 4.45855 18.9022 5.39509 20.1818 6.54546C17.9755 5.41909 15.7969 4.36364 12 4.36364C8.20309 4.36364 6.02455 5.41909 3.81818 6.54546C5.09782 5.39509 6.55527 4.35546 8.99345 3.80509L8.72727 3.27273C5.62855 3.56564 3.27273 5.45455 3.27273 5.45455C3.27273 5.45455 0.479455 9.50455 0 17.4545C2.81564 20.7016 7.09091 20.7273 7.09091 20.7273L7.98491 19.5355C6.46745 19.008 4.75364 18.066 3.27273 16.3636C5.03891 17.7 7.70455 19.0909 12 19.0909C16.2955 19.0909 18.9611 17.7 20.7273 16.3636C19.2464 18.066 17.5325 19.008 16.0151 19.5355L16.9091 20.7273C16.9091 20.7273 21.1844 20.7016 24 17.4545C23.5205 9.50455 20.7273 5.45455 20.7273 5.45455ZM8.45455 15.2727C7.40018 15.2727 6.54545 14.2958 6.54545 13.0909C6.54545 11.886 7.40018 10.9091 8.45455 10.9091C9.50891 10.9091 10.3636 11.886 10.3636 13.0909C10.3636 14.2958 9.50891 15.2727 8.45455 15.2727ZM15.5455 15.2727C14.4911 15.2727 13.6364 14.2958 13.6364 13.0909C13.6364 11.886 14.4911 10.9091 15.5455 10.9091C16.5998 10.9091 17.4545 11.886 17.4545 13.0909C17.4545 14.2958 16.5998 15.2727 15.5455 15.2727Z"></path></svg>`,
	},
	{
		type: 'text',
		key: 'io.keybase',
		icon: '<img src="https://keybase.io/images/icons/icon-keybase-logo-48.png">',
		url(x) { return `https://keybase.io/${encodeURIComponent(x)}`; }
	},
	{
		type: 'text',
		key: 'org.telegram',
		icon: `<svg xmlns="http://www.w3.org/2000/svg" fill="#2BABEE" viewBox="0 0 24 24" role="img"><g fill="inherit" clip-path="url(#a)"><path fill="inherit" fill-rule="evenodd" d="M24 12c0 6.6274-5.3726 12-12 12-6.62742 0-12-5.3726-12-12C0 5.37258 5.37258 0 12 0c6.6274 0 12 5.37258 12 12ZM12.43 8.85893c-1.1672.48547-3.49987 1.49027-6.99812 3.01437-.56806.2259-.86563.4469-.89272.663-.04578.3652.41154.509 1.03431.7048.08471.0267.17248.0543.26246.0835.6127.1992 1.43689.4322 1.86535.4414.38865.0084.82244-.1518 1.30135-.4807 3.26847-2.2063 4.95577-3.32149 5.06167-3.34553.0747-.01696.1783-.03829.2485.02408.0701.06235.0632.18045.0558.21215-.0453.1931-1.8405 1.8621-2.7695 2.7258-.2896.2692-.495.4602-.537.5038-.0941.0978-.19.1902-.2821.279-.5692.5487-.9961.9602.0236 1.6322.49.3229.8821.59 1.2733.8564.4273.2909.8534.5811 1.4047.9425.1405.0921.2746.1877.4053.2808.4972.3545.9438.6729 1.4957.6221.3206-.0295.6519-.331.8201-1.2302.3975-2.1252 1.1789-6.7299 1.3595-8.62742.0158-.16625-.0041-.37901-.0201-.4724-.0159-.0934-.0493-.22647-.1707-.32498-.1438-.11666-.3658-.14126-.465-.13952-.4514.00796-1.1439.24874-4.4764 1.63485Z" clip-rule="evenodd"></path></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h24v24H0z"></path></clipPath></defs></svg>`,
		url(x) { return `https://t.me/${encodeURIComponent(x)}`; }
	},
	{
		type: 'text',
		key: 'com.linkedin',
		url(x) { return `https://www.linkedin.com/in/${encodeURIComponent(x)}`; }
	},
	{
		type: 'addr',
		coin: 0,
		icon: `<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 500 500" role="img" class="sc-56a68b4b-0 nEsDk"><path fill="#F39321" d="M43.43 125.143c7.71-10.766 14.875-21.901 23.562-31.986 15.8-18.343 33.692-34.063 54.18-47.075 18.379-11.672 37.761-20.872 58.501-27.305 32.294-10.018 65.26-12.997 98.838-9.165 24.544 2.801 48.191 9.067 70.713 19.215 13.633 6.142 26.456 13.731 39.025 21.927 25.328 16.515 45.618 38.014 62.58 62.577 18.116 26.236 29.889 55.421 36.346 86.725 4.535 21.983 6.449 44.171 4.503 66.504-2.399 27.536-8.514 54.086-19.938 79.604-9.662 21.583-21.589 41.401-36.861 59.301-14.94 17.511-31.788 32.831-51.149 45.461-13.184 8.6-26.926 16.276-41.434 21.975-24.274 9.537-49.447 15.986-75.787 17.115-18.545.795-36.985.483-55.279-2.763-15.713-2.788-31.049-6.858-46.063-12.496-14.566-5.47-28.693-11.95-41.709-20.143-18.766-11.812-35.683-26.147-50.737-42.663-16.773-18.403-30.373-38.808-40.779-61.344-14.7-31.835-21.929-65.401-22.359-100.425-.162-13.173 1.349-26.244 3.105-39.283.126-.933-.002-1.899-.012-2.851 1.536-.952 1.4-2.618 1.677-4.071 3.906-20.483 10.494-40.059 19.418-58.906 3.162-6.674 7.525-12.764 9.659-19.928zm281.727 129.37c6.537-3.474 12.749-5.465 17.658-9.85 18.918-16.899 23.96-56.673-6.747-75.833-9.566-5.969-19.77-10.393-30.77-14.907 1.819-14.731 7.709-28.516 9.622-43.603-9.076-2.249-17.578-5.234-26.425-6.193l-10.674 41.837c-6.78-2.076-13.761-1.879-20.142-5.473 2.302-14.39 7.773-27.872 9.268-42.314-9.322-1.464-17.216-5.094-26.265-5.485l-10.586 42.215c-17.944-2.75-34.419-8.921-52.52-12.239-3.977 8.91-5.738 18.311-7.334 28.313 5.896 1.392 11.022 2.623 16.158 3.811 12.965 2.998 16.517 10.086 13.439 21.424-2.19 8.065-4.166 16.189-6.182 24.301-7.245 29.16-14.432 58.333-21.72 87.482-1.642 6.567-5.734 8.706-12.398 7.731-6.563-.96-12.757-3.907-19.99-3.693-3.136 10.032-9.378 18.871-11.588 29.946l51.344 13.08c-1.312 15.208-7.614 29.125-9.476 44.441l25.544 6.123c5.653-14.044 6.957-28.803 12.226-43.33 6.351 3.265 13.397 2.317 19.612 6.427l-10.178 42.077c8.986 3.216 17.753 4.528 26.758 6.77l10.578-42.386c2.123-1.091 3.676-.888 5.143-.574a132.886 132.886 0 0 0 42.676 2.14c12.368-1.373 23.343-6.088 32.148-15.372 9.791-10.323 14.71-22.952 17.078-36.535 1.93-11.065 1.436-22.277-5.06-32.071-5.091-7.674-12.084-13.53-21.197-18.26zM223.128 312.17c17.411 4.325 34.803 8.95 53.02 5.624 9.715-1.774 17.037-6.73 19.985-16.503 2.78-9.218 1.164-17.593-5.673-24.879-7.11-7.576-16.254-11.514-25.682-14.807-11.264-3.934-22.683-7.508-34.99-8.48l-13.972 56.788c2.981.929 5.117 1.712 7.312 2.257zm61.5-80.324c9.628-1.368 17.612-7.738 19.958-16.393 2.869-10.583-.337-19.865-8.902-26.178-9.718-7.163-20.908-10.807-32.47-13.337-4.307-.943-8.544-3.454-13.756-1.759l-12.599 51.209c16.457 4.155 31.611 8.753 47.769 6.458z"></path></svg>`,
	},
	{
		type: 'addr',
		coin: 2,
		key: 'LTC',
	},
	{
		type: 'addr',
		coin: 3,
		icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2000 2000" role="img" class="sc-56a68b4b-0 nEsDk"><g fill="#c2a633"><path d="M1024 659H881.12v281.69h224.79v117.94H881.12v281.67H1031c38.51 0 316.16 4.35 315.73-327.72S1077.44 659 1024 659z"></path><path d="M1000 0C447.71 0 0 447.71 0 1000s447.71 1000 1000 1000 1000-447.71 1000-1000S1552.29 0 1000 0zm39.29 1540.1H677.14v-481.46H549.48V940.7h127.65V459.21h310.82c73.53 0 560.56-15.27 560.56 549.48 0 574.09-509.21 531.41-509.21 531.41z"></path></g></svg>`,
	},
	{
		type: 'text',
		key: 'avatar',
		cached: 'avatar',
		format() { return ''; },
		url(x) { return x; }
	},
	{
		type: 'text',
		key: 'banner',
		format() { return ''; },
		url(x) { return x; }
	},
	{
		type: 'contenthash',
	}
];

const location0 = new URL(window.location.href);
const entity_span = document.createElement('span');

input_field.value = decodeURIComponent(location0.hash.slice(1));
force_mainnet_check.checked = location0.searchParams.has('1');
skip_norm_check.checked = location0.searchParams.has('skip');
const debug = location0.searchParams.has('debug');

let infura_provider = new ethers.providers.InfuraProvider(CHAIN_ID_MAINNET, 'f36f6a8638134ac09f9400d3a7008dfe');
let window_provider;
let active_provider;
let active_chain; // = CHAINS[0];
let registry_contract;
let eth_resolver_contract;
let eth_nft_contract;
let eth_controller_contract;
let wrapper_contract;
let multicall_contract;
let price_oracle_contract;
let reverse_registrar;
let resolve_timer = RESOLVE_MODE_IDLE;
let resolve_date0;

console.log(versions);
document.querySelector('footer').innerHTML += ` — <span>v${versions.version}</span>`;
document.querySelector('footer span').addEventListener('click', () => {
	window.alert(JSON.stringify(versions, null, ' '));
});
// TODO: add more 
function keycap(i) {
	return String.fromCodePoint(0x30+i, 0xFE0F, 0x20E3);
}
const KEYCAP_MINUS = '➖️';
const KEYCAP_NAME = 'Keycap';
const DIGIT_MAP = new Map();
const DIGITS_MAP = new Map();
for (let i = 0; i < 10; i++) DIGIT_MAP.set(keycap(i), i);
function add_digits(name, digits, extra = {}) {
	explode_cp(digits).forEach((cp, i) => DIGIT_MAP.set(cp, {name, i, ...extra}));
	DIGITS_MAP.set(name, digits);
}
add_digits('ASCII', '0123456789');
add_digits('Arabic', '٠١٢٣٤٥٦٧٨٩', {mixed: 1}); //, reversed: true
[[0x6F4, 4], [0x6F5, 5], [0x6F6, 6]].forEach(([cp, i]) => {
	DIGIT_MAP.set(cp, {name: 'Extended Arabic', i, mixed: 1});
});
add_digits('CJK', '〇一二三四五六七八九');
add_digits('Devangari', '०१२३४५६७८९');
add_digits('Thai', '๐๑๒๓๔๕๖๗๘๙');
//add_digits('Bengali', '০১২৩৪৫৬৭৮৯');
//add_digits('Tamil', '௦௧௨௩௪௫௬௭௮௯'); 

read_local_storage(STORAGE_HIDE_EXAMPLES, x => examples_div.classList.toggle('hide', x), true);
read_local_storage(STORAGE_AUTO_RESOLVE, x => auto_resolve_check.checked = x);
read_local_storage(STORAGE_SHOW_DETAILS, x => show_details_check.checked = x);
read_local_storage(STORAGE_SHOW_COMPONENTS, x => show_components_check.checked = x);
read_local_storage(STORAGE_SHOW_RECORDS, x => show_records_check.checked = x);
read_local_storage(STORAGE_FORCE_LTR, x => force_ltr_check.checked = x);

sync_recent(localStorage[STORAGE_RECENT]);

for (let btn of document.querySelectorAll('#examples button:not([id]), button[data-name]')) {
	let name = btn.innerText;
	if (btn.dataset.name) name = btn.dataset.name;
	if (typeof btn.dataset.raw !== 'string') name = replace_escapes(name);
	if (!btn.innerText || btn.innerText.includes('{')) btn.innerText = name;
	let meta = typeof btn.dataset.meta === 'string' || name.includes(':') || is_checksum_address(name);
	try {
		if (meta || name !== ens_normalize(name)) {
			btn.classList.add('mapped');
		}
	} catch (err) {
		btn.classList.add('error');
	}	
	if (!meta && !name.includes('.')) name += '.eth';
	if (typeof btn.dataset.escape === 'string') name = apply_escapes(name);
	if (!btn.title) btn.title = meta ? name : `${name}\n${explode_cp(name).map(hex_cp).join(' ')}`;
	btn.addEventListener('click', () => {
		input_field.value = name;
		if (btn.dataset.skip) skip_norm_check.checked = true;
		if (options_div.getBoundingClientRect().top > window.innerHeight * .9) {
			options_div.scrollIntoView(); // scuffed
		}
		let delay = parseInt(btn.dataset.delay)|0;
		if (delay > 0) {
			schedule_resolve(delay);
		} else {
			resolve();
		}
	});
}
for (let x of document.querySelectorAll('[data-tokenize]')) {
	x.replaceWith(dom_from_tokens(ens_tokenize(replace_escapes(x.dataset.tokenize)), {
		emoji_url,
		components: x.dataset.parts
	}));
}

resolve_btn.addEventListener('click', () => resolve());
input_field.addEventListener('keydown', e => {
	if (e.key === 'Enter') {
		e.stopPropagation();
		resolve();
	}
});
input_field.addEventListener('input', () => {
	if (parse() && auto_resolve_check.checked) schedule_resolve();
});

window.addEventListener('storage', e => {
	if (e.type === 'storage' && e.key === STORAGE_RECENT) {
		sync_recent(e.newValue);
	}
});
function sync_recent(saved) {
	recent_optgroup.innerHTML = '';
	try {
		JSON.parse(saved).reverse().forEach(x => add_recent(x, false));
	} catch (err) {	
	}
}
recent_select.addEventListener('change', () => {
	let option = recent_select.selectedOptions[0];
	recent_select.selectedIndex = -1;
	if (!option) return;
	if (recent_optgroup.contains(option)) {
		input_field.value = option.value;
		resolve();
	} else if (option.value === 'reset') {
		recent_select.classList.add('hide');
		recent_optgroup.innerHTML = '';
		localStorage[STORAGE_RECENT] = '[]';
	}
});
function add_recent(name, save = true) {
	if (!name) return;
	let found;
	for (let x of recent_optgroup.children) {
		if (x.value === name) {
			recent_optgroup.prepend(x); // move to top
			found = true;
			break;
		}
	}
	if (!found) {
		while (recent_optgroup.childElementCount >= 25) { // max
			recent_optgroup.lastChild.remove();
		}
		let option = new Option();
		option.value = name;
		if (is_checksum_address(name)) {
			option.innerHTML = `🏠️ ${name}`; 
		} else {
			try {
				let norm = ens_normalize(name);
				option.innerHTML = `${norm === name ? '✅️' : '☑️'} ${name}`;
			} catch (err) {
				option.innerHTML = `❌️ ${apply_escapes(name, cp => should_escape(cp) || cp == 0x20)}`;
			}
		}
		recent_optgroup.prepend(option);
	}
	recent_select.selectedIndex = -1;
	recent_select.classList.remove('hide');
	if (save) {
		localStorage[STORAGE_RECENT] = JSON.stringify([...recent_optgroup.children].map(x => x.value));
	} 
}
make_network_switcher(document.querySelector('#add_goerli_btn'), CHAIN_ID_GOERLI);
make_network_switcher(document.querySelector('#add_sepolia_btn'), CHAIN_ID_SEPOLIA);
document.querySelector('#random_emoji_btn').addEventListener('click', e => {
	let name = '';
	let pool = e.altKey ? EMOJI.filter(cps => cps.length == 1 || (cps.length == 2 && cps[1] === 0xFE0F)) : EMOJI;
	while (Array.from(name).length < MIN_ETH_LENGTH) {
		name += ens_normalize(str_from_cps(pool[Math.random() * pool.length|0]));
	}
	input_field.value = `${name}.eth`;
	skip_norm_check.checked = false;
	resolve();
});
function get_selected_input() {
	let {value, selectionStart, selectionEnd} = input_field;
	if (selectionEnd > selectionStart) {
		value = value.slice(selectionStart);
	}
	return replace_escapes(value);
}
document.querySelector('#find_emoji_btn').addEventListener('click', e => {
	let url = './emoji.html';
	let value = get_selected_input();
	let token = ens_tokenize(value).find(x => x.emoji);
	if (token) url += `#q=${encodeURIComponent(String.fromCodePoint(...token.cps))}`;
	create_link(url).click();	
});
document.querySelector('#chars_btn').addEventListener('click', e => {
	let url = './chars.html';
	let value = get_selected_input();
	if (value) url += `#${value.codePointAt(0).toString(16)}`;
	create_link(url).click();
});
document.querySelector('#confused_btn').addEventListener('click', e => {
	let s = input_field.value;
	create_link(`./confused.html#${encode_uri_component_surrogate_escaped(s.replaceAll('.', ''))}`).click();
});
nf_btn.addEventListener('click', () => {
	let s0 = input_field.value;
	let s1 = replace_escapes(s0);
	let s2 = apply_escapes(str_from_cps(nfd(explode_cp(s1))));
	let s3 = apply_escapes(str_from_cps(nfc(explode_cp(s1))));
	if (s2 === s3 && s2 === apply_escapes(s1)) return; // do nothing
	input_field.value = s0 == s2 ? s3 : s2;
	resolve();
});
parent_btn.addEventListener('click', e => {
	let name = input_field.value;
	let pos = name.indexOf('.');
	input_field.value = pos >= 0 ? name.slice(pos+1) : '';
	resolve();
});
escape_btn.addEventListener('click', e => {
	let s0 = input_field.value;
	let s1 = replace_escapes(s0);
	let s2 = apply_escapes(s1, undefined, e.altKey);
	let s3 = apply_escapes(s1, () => true, e.altKey);
	let set = [...new Set([s1, s2, s3])];
	let pos = set.indexOf(s0);	
	input_field.value = set[(pos + 1) % set.length];
	update_title();
});
document.querySelector('#copy_link_btn').addEventListener('click', () => {
	navigator.clipboard.writeText(window.location.href);
});
document.querySelector('#copy_example_btn').addEventListener('click', () => {
	let url = new URL(window.location.href);
	url.hash = '#vitalik.eth';
	navigator.clipboard.writeText(url);
});
auto_resolve_check.addEventListener('input', () => {
	localStorage[STORAGE_AUTO_RESOLVE] = auto_resolve_check.checked;	
	if (auto_resolve_check.checked && input_field.value) {
		resolve();
	}
});
show_details_check.addEventListener('input', () => {	
	localStorage[STORAGE_SHOW_DETAILS] = show_details_check.checked;	
	for (let el of document.querySelectorAll('.detailed')) {
		el.classList.toggle('hide', !show_details_check.checked);
	}
});
show_records_check.addEventListener('input', () => {
	localStorage[STORAGE_SHOW_RECORDS] = show_records_check.checked;	
	let records = document.querySelector('.row.records');
	if (records) {
		records.classList.toggle('hide', !show_records_check.checked);
	} else if (show_records_check.checked) {
		resolve();
	}
});
show_components_check.addEventListener('input', () => {
	localStorage[STORAGE_SHOW_COMPONENTS] = show_components_check.checked;
	update_exploded();
});
force_ltr_check.addEventListener('input', () => {
	localStorage[STORAGE_FORCE_LTR] = force_ltr_check.checked;
	sync_force_ltr();
});
force_mainnet_check.addEventListener('input', async () => {
	update_title();
	if (!window_provider) return;
	force_mainnet_check.disabled = true;
	if (update_network(await get_window_provider_network().catch(() => {}))) {
		resolve();
	}
	force_mainnet_check.disabled = false;
});
skip_norm_check.addEventListener('input', () => {
	resolve();
}); 
examples_btn.addEventListener('click', () => {
	let b = !examples_div.classList.contains('hide');
	examples_div.classList.toggle('hide', b);
	localStorage[STORAGE_HIDE_EXAMPLES] = b;
	sync_examples();
});

if (input_field.value.endsWith('_!')) { // backwards compat
	input_field.value = input_field.value.slice(0, -2);
	skip_norm_check.checked = true;
}
if (window.ethereum) {
	let p = ethereum;
	if (Array.isArray(ethereum.providers)) p = ethereum.providers[0]; // fix scuffed multi-provider
	window_provider = new ethers.providers.Web3Provider(p, 'any');
	let timer = setTimeout(update_network, 100); // avoid creating infura connection if possible
	window_provider.once('network', () => clearTimeout(timer));
	window_provider.on('network', update_network);
	ethereum.on('connect', async () => update_network(await window_provider.getNetwork()));
	ethereum.on('disconnect', () => update_network());
} else {
	force_mainnet_check.checked = false;
	force_mainnet_check.classList.add('hide');
	update_network();
}

sync_examples();
sync_force_ltr();
input_field.focus();
window.addEventListener('hashchange', () => {
	input_field.value = decodeURIComponent(window.location.hash.slice(1));
	resolve();
});

function make_network_switcher(btn, id) {
	btn.classList.add('chain');
	btn.dataset.chain = id;
	btn.title = `Chain: ${id} / 0x${id.toString(16)}`;
	btn.addEventListener('click', () => switch_to_network(id).catch(() => {}));
}
async function get_window_provider_network() {
	if (!window_provider) throw new Error('no window');
	if (!window_provider.provider.isConnected()) throw new Error('not connected');
	return window_provider.getNetwork();
}
async function switch_to_network(id) {
	let network = await get_window_provider_network();
	if (network.chainId === id) {
		if (active_provider === window_provider) return;
		return update_network(network);
	}
	await window_provider.send('wallet_switchEthereumChain', [{chainId: `0x${id.toString(16)}`}]);
	for (let btn of document.querySelectorAll('.chain')) {
		btn.disabled = true;
	}
}
function update_network(network) {
	let chain0 = active_chain;
	active_chain = CHAINS[0];
	active_provider = infura_provider;
	let window_online = window_provider && window_provider.provider.isConnected();
	let registry = '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e';
	if (network && window_online) {
		let chain = CHAINS.find(x => x.id === network.chainId);
		if (chain && (!force_mainnet_check.checked || chain.is_mainnet)) {
			active_chain = chain;
			active_provider = window_provider;
			if (network.ensAddress) {
				registry = network.ensAddress;
			} else {
				network.ensAddress = registry; // force it into ethers
			}
		}
	}
	let using_window = active_provider === window_provider;
	let provider_name = using_window ? 'window.ethereum' : 'Infura';
	document.body.classList.toggle('testnet', !active_chain.is_mainnet);	
	let network_div = document.createElement('div');
	network_div.innerHTML = `using <b>${provider_name}</b> on <a target="_blank" href="${active_chain.explorer}/address/${registry}" title="Registry Contract">${active_chain.name}</a>`;
	if (window_online && !using_window && network && network.chainId !== CHAIN_ID_MAINNET && !force_mainnet_check.checked) {
		provider_div.innerHTML = `<div class="error">Unsupported Network (${network.chainId})</div>`;
	} else {
		provider_div.innerHTML = '';	
	}
	provider_div.append(network_div);
	for (let btn of document.querySelectorAll('.chain')) {
		btn.disabled = !window_online || active_chain.id == btn.dataset.chain;
	}
	if (!active_chain.is_mainnet || (window_online && active_provider !== window_provider)) {
		let btn = document.createElement('button');
		btn.innerHTML = active_chain.is_mainnet ? 'Use Browser' : '↪ Mainnet';
		make_network_switcher(btn, CHAIN_ID_MAINNET);
		network_div.append(btn);
	}
	if (chain0 === active_chain) return; // no change	
	let init = !registry_contract;
	registry_contract = new ethers.Contract(registry, [
		'function resolver(bytes32 node) external view returns (address)',
		'function owner(bytes32 node) external view returns (address)',
	], active_provider);
	eth_resolver_contract = null;
	eth_nft_contract = null;
	eth_controller_contract = null;
	wrapper_contract = null;
	multicall_contract = null;
	reverse_registrar = null;
	NOT_IFACE_RESOLVER.clear();
	IS_CONTRACT.clear();
	if (input_field.value) {
		schedule_resolve(0);
	} else if (init) {
		parse();
	}
	return true; // changed
}

function sync_examples() {
	if (examples_div.classList.contains('hide')) {
		examples_btn.innerText = '👀 Examples';
		options_div.prepend(examples_btn);
	} else {
		examples_btn.innerText = '🙈 Hide Examples';
		examples_div.prepend(examples_btn);
	}
}

function sync_force_ltr() {
	input_field.classList.toggle('force-ltr', force_ltr_check.checked);
}

function should_stop_resolving() {
	return resolve_timer !== RESOLVE_MODE_IDLE;
}

function schedule_resolve(delay = 500) {
	clearTimeout(resolve_timer);
	if (is_working()) {
		resolve_timer = [Date.now() + delay]; // encode as future time
	} else {
		primary_loader.classList.remove('hide');
		resolve_timer = setTimeout(resolve, delay);
	}
} 

function stop_resolving() {
	clearTimeout(resolve_timer);
	resolve_timer = RESOLVE_MODE_EMPTY;
	primary_loader.classList.add('hide');
}

function update_title() {
	let title = 'ENS Resolver';
	let input = input_field.value;
	let url = new URL(location0);
	let args = [];
	if (debug) args.push('debug');
	if (force_mainnet_check.checked) args.push('1');
	if (skip_norm_check.checked) args.push('skip');
	url.search = args.join('&');
	if (input) {
		title += `: “${input}”`;
		if (skip_norm_check.checked) {
			title += ' (!)';
		}
		url.hash = '#' + encode_uri_component_surrogate_escaped(input);
	} else {
		url.hash = '';	
	}
	if (!active_chain.is_mainnet) {
		title += ` / ${active_chain.name}`;
	}
	window.history.replaceState(null, null, url); 
	document.title = title;
}

function replace_name(name) {
	//if (name === '[root]') return '';
	return name;
}

function parse() {
	update_title();	
	let input = input_field.value;
	let skip = skip_norm_check.checked;
	nf_btn.disabled = !input;
	escape_btn.disabled = !input;
	parent_btn.disabled = !input;	
	if (!input) {
		stop_resolving();
		output_div.innerHTML = '';
		output_div.append(...readme_dom);	
		return;
	}
	// TODO: conslidate this code with resolve()
	let name = replace_name(replace_escapes(input));
	output_div.innerHTML = '';
	if (resolve_timer === RESOLVE_MODE_EMPTY) {
		resolve_timer = RESOLVE_MODE_IDLE;
	}
	if (is_checksum_address(name)) {
		let row = create_row('Address');
		row.append(create_etherscan_address_link(name));		
		add_row_tag(row, create_reverse_resolve_btn(name));
		output_div.append(row);
		return true;
	}
	let row = create_row(INPUT_NAME);
	make_exploded(row, name, false);
	output_div.append(row, create_details_row(name, true));
	try {
		let norm = ens_normalize(name);
		if (norm === name) {
			make_normalized(row, norm);
		} else {
			add_row_tag(row, create_typed_tag('fail', 'Normalized'));
			if (!skip) {
				add_transformed_row(name);
				let norm_row = create_row('Normalized');
				make_exploded(norm_row, norm, true);
				make_normalized(norm_row, norm);
				add_old_tag(norm_row, name, true);
				output_div.append(norm_row, create_details_row(norm));
			}
		}		
		add_old_tag(row, name);
		//output_div.append(create_dns_row(norm));
		return true;
	} catch (err) {
		row.classList.add('error');
		add_row_tag(row, create_typed_tag('norm', err));
		if (skip) return true;
		add_old_tag(row, name);
		make_exploded(row, name, false); // show the mapping during the error
		stop_resolving();

		// if there is a fully ignorable label
		let collapsed = ens_split(name).filter(x => !x.tokens || x.tokens.length).map(x => str_from_cps(x.input)).join('.');
		if (collapsed !== name) {
			let btn = document.createElement('button');
			btn.innerText = '💥️ Collapse Empty Labels';
			btn.addEventListener('click', () => {
				input_field.value = collapsed;
				resolve();
			});
			add_row_tag(row, btn);
		}

		// if there is whitespace
		let stripped = name.replace(/\s+/g, '');
		if (stripped !== name) {
			let btn = document.createElement('button');
			btn.innerText = '✂️ Strip Whitespace';
			btn.addEventListener('click', () => {
				input_field.value = stripped;
				resolve();
			});
			add_row_tag(row, btn);
		}

		// if there are likely unmapped mistakes
		const SLOPPY_MAP = new Map([
			[0x2F, 0x2044], 
			[0x3002, 0x2E],
			[0xFF0E, 0x2E],
			[0xFF61, 0x2E],
		]);
		let sloppy = str_from_cps(explode_cp(name).map(x => SLOPPY_MAP.get(x) || x))
		if (sloppy !== name) {
			let btn = document.createElement('button');
			btn.innerHTML = '💣️ Unsafe Replace';
			btn.title = `Replace the following characters:` + [...SLOPPY_MAP.entries()].map(([a, b]) => {
				return `\n"${safe_str_from_cps([a])}" ${hex_cp(a)} → "${safe_str_from_cps([b])}" ${hex_cp(b)}`
			}).join('');
			btn.addEventListener('click', () => {
				input_field.value = sloppy;
				resolve();
			});
			add_row_tag(row, btn);
		}

		let tokens = ens_tokenize(name); 

		// if there are disallowed characters
		if (tokens.some(x => x.type === 'disallowed')) {
			try {
				ens_normalize(stripped);
			} catch (err) {
				// and they aren't just whitespace
				let btn = document.createElement('button');
				btn.innerText = '❌ Remove Disallowed';
				btn.addEventListener('click', () => {
					input_field.value = str_from_cps(tokens.flatMap(t => t.type === 'nfc' ? t.tokens0 : t).flatMap(t => {
						switch (t.type) {
							case 'disallowed': return [];
							case 'valid': return t.cps;
							case 'emoji': return t.input;
							default: return t.cp;
						}
					}));
					resolve();
				});
				add_row_tag(row, btn);	
			}
		}

		// if there are normalizable parts
		if (tokens.some(x => x.type === 'nfc' || x.type === 'ignored' || x.type === 'mapped' || (x.type === 'emoji' && x.input.includes(0xFE0F)))) {
			let btn = document.createElement('button');
			btn.innerHTML = '💪️ Force Normalize';
			btn.addEventListener('click', () => {
				input_field.value = str_from_cps(tokens.flatMap(token => {
					switch (token.type) { 
						case 'ignored': return []; // removes ignored (dangerous)
						case 'mapped': // applies known mappings 
						case 'emoji': // removes FE0F from known emoji
						case 'nfc':
						case 'valid': return token.cps;
						default: return token.cp;
					}
				}));
				resolve();
			});
			add_row_tag(row, btn);
		}
	}
}

function add_detailed(row) {
	row.classList.add('detailed');
	row.classList.toggle('hide', !show_details_check.checked);
}

function add_transformed_row(input) {
	if (ens_tokenize(input).some(x => x.type === 'nfc' || x.type === 'mapped')) {
		let row = create_row('Transform');
		row.classList.add('transform');
		add_detailed(row);
		make_exploded(row, input, true);
		output_div.append(row);
	}
}

function create_dns_row(name, replaced) {
	let row = create_row(replaced ? 'Alternative DNS' : 'DNS');
	let try_replace = false;
	row.classList.add('dns');
	try {
		const MAX_LABEL = 63;
		const MAX_NAME = 253; 
		const VALID_REGEX = /^[-0-9a-z]*$/;
		let encoded = name.split('.').map(label => {
			let cps = explode_cp(label);
			try {
				let encoded = puny_encoded(cps).toLowerCase();
				if (!VALID_REGEX.test(encoded)) {
					let first = [...encoded].find(ch => !VALID_REGEX.test(ch));
					throw new Error(`unsupported ASCII: "${safe_str_from_cps(explode_cp(first))}"`);
				}
				if (encoded === label) {
					if (label.startsWith('xn--')) throw new Error('punycode literal');
					if (label.slice(2, 4) === '--') throw new Error('invalid label extension');
					// 20230123: WHATWG URL uses "CheckHyphens" false
					//if (label.startsWith('-')) throw new Error('leading hyphen');
					//if (label.endsWith('-')) throw new Error('trailing hyphen');
				}
				if (encoded.length > MAX_LABEL) throw new Error(`too long: ${encoded.length} > ${MAX_LABEL}`);
				return encoded;
			} catch (err) {
				throw new Error(`Invalid label "${safe_str_from_cps(cps)}": ${err.message}`);
			}
		}).join('.');
		if (encoded.length > MAX_NAME) {
			throw new Error(`Name too long: ${encoded.length} > ${MAX_NAME}`);
		}
		let browser;
		try {
			browser = new URL(`https://${name}`).host;
		} catch (ignored) {
		}
		row.append(create_main_span(encoded));
		add_row_tag(row, create_copy_btn(encoded));
		if (encoded === name) {
			add_row_tag(row, create_typed_tag('good', 'Verbatim'));
		} else if (!browser || browser !== encoded) {
			add_row_tag(row, create_typed_tag('stop', 'Pre-IDNA Punycode Required'));
			if (browser) {
				add_row_tag(row, create_copy_btn(browser));
			}
			if (!replaced) {
				add_alternative_btn(row, name);
			}
		} else {
			add_row_tag(row, create_typed_tag('second', 'Punycode Compatible'));
		}
		if (name.includes('\u200D')) {
			add_row_tag(row, create_typed_tag('warn', 'ZWJ'));
		}
		if (active_chain.is_mainnet) {
			if (encoded.endsWith('.eth')) {
				add_row_tag(row, create_link(`https://${encoded}.limo`, '.limo', 'external'));
				add_row_tag(row, create_link(`https://${encoded}.link`, '.link', 'external'));
				add_row_tag(row, create_link(`https://${encoded}.li`,   '.li',   'external'));
				add_row_tag(row, create_link(`https://${encoded}.xyz`,  '.xyz',  'external'));
				add_row_tag(row, create_link(`https://${encoded}.co`,   '.co',   'external'));
			} else {
				add_row_tag(row, create_link(`https://${encoded}`, 'Website', 'external'));
			}
		}
		add_row_tag(row, create_link(`../../punycode.js/test/demo.html#${browser?'p':'u'}=${browser || name}`, '<button>✅️ Check</button>'));
	} catch (err) {
		row.classList.add('invalid');
		add_row_tag(row, create_typed_tag('fail', err));
		if (!replaced) {
			add_alternative_btn(row, name);
		}
	}	
	return row;
	
}

// try some transformations
function add_alternative_btn(row, name) {
	let alt = name;
	try {
		alt = ens_beautify(alt);
	} catch (err) {
	}
	alt = str_from_cps(explode_cp(name).map(cp => {
		if (cp >= 0x660 && cp <= 0x669) {
			return cp + 0x90; // try other arabic digits
		} else {
			return cp;
		}
	}));
	if (alt !== name) {
		let btn = document.createElement('button');
		btn.innerText = '🥈️ Try Alternative';
		btn.addEventListener('click', () => {
			row.replaceWith(create_dns_row(alt, true));
		});
		add_row_tag(row, btn);
	}
}

function is_safe_ascii(cp) {
	// same as:
	//return !should_escape(cp) && cp != 0x20;
	return cp >= 0x21 && cp <= 0x7E;
}
function unicode_escape_cp(cp) {
	let hex = hex_cp(cp);
	return hex.length > 4 ? `\\u{${hex}}` : `\\u${hex.padStart(4, '0')}`; // be nice
}
function unicode_escape(s) {
	return explode_cp(s).map(unicode_escape_cp).join('');
}
function entity_escape(s) {
	return explode_cp(s).map(cp => is_safe_ascii(cp) ? String.fromCodePoint(cp) : `&#x${hex_cp(cp)};`).join('');
}
// escape where escape_fn is true (default: non-ascii)
// unicode: use \u-format
function apply_escapes(s, escape_fn, unicode) {
	if (!escape_fn) escape_fn = cp => !is_safe_ascii(cp);
	return explode_cp(s).map(cp => {
		return escape_fn(cp) ? unicode ? unicode_escape_cp(cp) : quote_cp(cp) : String.fromCodePoint(cp);
	}).join('');
}
function replace_escapes(s) {
	// match: \u{HEX}, {HEX}, \uXXXX, [0xHEX], [DEC]
	return s.replace(/(?:(?:(?:\\u)?\{([0-9a-f]+)\}|\\u([0-9a-f]{4}))|(?:\[((?:0x[0-9a-f]+)|[0-9]+)\]))/uig, (_, hex1, hex2, num) => {
		try {
			return String.fromCodePoint(num ? parseInt(num) : parseInt(hex1 || hex2, 16)); 
		} catch (err) {
			return '�';
		}
	});
}
function encode_uri_component_ens_escaped(s) {
	return s.split('.').map(x => {
		try {
			return encodeURIComponent(x);
		} catch (err) {
			return `[${labelhash(x).slice(2)}]`; // support unlinkable stuff
		}
	}).join('.');
}
function encode_uri_component_surrogate_escaped(s) {
	return encodeURIComponent(apply_escapes(s, is_surrogate));
}
function create_link(url, html, cls) {
	let a = document.createElement('a');
	a.href = url;
	a.target = '_blank';
	a.innerHTML = html || url;
	if (cls) a.classList.add(cls);
	try {
		new URL(url, window.location.href);
	} catch (err) {
		a.classList.add('invalid');
	}
	return a;
}
function create_ens_link(name, html = '<button>🛠️ ENS</button>') {
	return create_link(`https://app.ens.domains/${encode_uri_component_ens_escaped(name)}`, html, 'ens');
}
function create_ens_metadata_link(contract, token, {html = '<button class="code">🏷️ Metadata</button>'} = {}) {
	return create_link(`${active_chain.metadata}/${contract}/${token}`, html, 'metadata');
}
function create_etherscan_address_link(addr, {title, anchor, contract} = {}) {
	if (contract && !anchor) anchor = '#readContract';
	return create_link(`${active_chain.explorer}/address/${addr}${anchor || ''}`, title || addr, title ? false : 'wide');
}
function create_etherscan_nft_link(contract, token, {title = 'Etherscan', cls = 'external'} = {}) {
	return create_link(`${active_chain.explorer}/nft/${contract}/${ethers.BigNumber.from(token)}`, title, cls); 
}
function create_opensea_nft_link(contract, token, {title = OPENSEA_NAME, cls = 'external'} = {}) {
	let {opensea} = active_chain;
	return opensea && create_link(`${opensea}${contract}/${ethers.BigNumber.from(token)}`, title, cls);
}
function create_jazz_icon(address) {
	let i = ADDRESS_MAP.get(address);
	if (!i || debug) ADDRESS_MAP.set(address, i = ADDRESS_MAP.size + 1);
	let span = document.createElement('span');
	span.classList.add('jazz', `addr${i}`);
	span.innerHTML = i;
	return span;
}

function make_copier(el, raw) {
	el.addEventListener('click', e => {
		let copy = raw;
		if (e.altKey) {
			copy = unicode_escape(copy);
		} else if (e.shiftKey) {
			copy = entity_escape(copy);
		} 
		const cls = 'copied';
		document.querySelectorAll(`.${cls}`).forEach(x => x.classList.remove(cls));
		navigator.clipboard.writeText(copy);
		el.classList.add(cls);
		setTimeout(() => el.classList.remove(cls), 2000);
	});
}

function create_copy_btn(raw) {
	let btn = document.createElement('button');
	make_copier(btn, raw);
	btn.classList.add('copy');
	btn.title = raw;
	if (!/^0x[0-9a-f]*$/i.test(raw)) {
		btn.title += '\n' + explode_cp(raw).map(hex_cp).join(' ');
	}
	if (unicode_escape(raw) !== raw) {
		btn.title += `\n[ALT] Unicode Escaped`;
	}
	if (entity_escape(raw) !== raw) {
		btn.title += `[SHIFT] Entity Escaped`;
	}
	return btn;
}
function reverse_name(addr) {
	return `${addr.slice(2).toLowerCase()}.${REVERSE_DOMAIN}`;
}
function create_reverse_resolve_btn(addr) {
	return create_resolve_btn(reverse_name(addr), '↩️ Reverse Record');
}
function create_resolve_btn(name, html = '↩️ Resolve') {
	let btn = document.createElement('button');
	btn.innerHTML = html;
	btn.title = name;
	btn.addEventListener('click', () => {
		input_field.value = name;
		resolve();
	});
	return btn;
}

function set_length(el, n, unit = 'ch') {
	el.classList.add('length');
	el.innerHTML = `${n}<sub>${unit}</sub>`;
	return el;
}

function create_main_span(text) {
	let inner = document.createElement('span');
	inner.classList.add('main', 'long');
	inner.innerText = text;
	let outer = document.createElement('span');
	outer.append(inner);
	return outer;
}
function create_pretty_tag() {
	let span = document.createElement('span');
	span.classList.add('clean');
	span.innerHTML = PRETTY_NAME;
	span.title = 'Beautified Form';
	return span;
}
function upgrade_split_type(info) {
	info.restricted = info.type.startsWith('Restricted[');
	if (info.type === 'Latin') {
		let cps = info.tokens.flatMap(x => x.is_emoji ? [] : x); // ascii+emoji
		if (cps.every(cp => cp < 0x80)) {
			info.type = 'ASCII';
		} else if (/[ąçęşìíîïǐł]/u.test(str_from_cps(cps))) { // TODO: formalize this logic in ens-normalize
			info.confusing = 'latin';
		}
	} else if (info.type === 'ASCII') {
		if (/^0x[0-9a-f]{18,}$/i.test(str_from_cps(info.output))) {
			info.confusing = 'address';
		}
	}
}

function make_normalized(row, name) {
	row.classList.add('normalized');
	let span = document.createElement('span');
	span.title = 'Normalized Form';
	span.innerHTML = `✅️`; 
	span.classList.add('normalized');
	let split = ens_split(name);
	if (split.length > 1 && split[split.length-1].type === 'ASCII') {
		split.pop(); // remove ASCII TLD
	}
	let pure_ascii = split.every(x => x.type === 'ASCII');
	split.forEach(upgrade_split_type);
	if (pure_ascii) {
		span.classList.add('ascii');
		span.innerHTML += ` ASCII`; 
	} else {
		let types = new Set(split.map(x => x.type));
		if (types.has('Latin') && types.has('ASCII')) {
			types.delete('ASCII');
		}
		if (split.some(x => x.emoji)) {
			types.add('Emoji');
		} else {
			types.delete('Emoji');
		}
		span.innerHTML += ` ${[...types].sort().join('+')}`;
	}
	if (split.some(x => x.confusing)) {
		let span = document.createElement('span');
		span.innerHTML = 'Possibly<br>Confusing';
		span.style.cssText = `
			color: #fff;
			background-color: #d47;
			margin: -8px 0;
			text-align: center;
			font-size: 75%;
		`;
		add_row_tag(row, span);
	}
	add_row_tag(row, span);	
}

function make_contract(row) {
	row.classList.add('contract');
	//let span = row.querySelector('.row-label');
	//span.innerHTML = span.innerHTML.replace('Address', 'Contract'); // meh
}

function create_palindrome_tag() {
	// let span = document.createElement('span');
	// span.classList.add('palindrome');
	// span.innerHTML = '⇄ Palindrome';
	// return span;
	return create_typed_tag('good', '⇄')
}

function create_ethmoji_row(tokens, suffix) {
	let row = create_row('Ethmoji');
	row.classList.add('category', 'ethmoji');
	add_detailed(row);
	let tally = new Map();
	let last;
	for (let token of tokens) {
		let form = str_from_cps(token.emoji);
		let rec = tally.get(form);
		if (!rec) {
			rec = {form, count: 0, ...token};
			tally.set(form, rec);
		}
		++rec.count;
	}
	tally = [...tally.values()];
	let formula = document.createElement('div');
	formula.classList.add('formula');
	for (let rec of tally.values()) {
		formula.append(create_link(`./emoji.html#q=${str_from_cps(rec.cps)}`, `${rec.form}<sup>${rec.count}</sup>`));
	}
	row.append(formula);
	let span_grade = document.createElement('span');
	let min_repeated;
	if (tokens.every(t => t.emoji[2] == 0x20E3)) {
		if (tokens.length == 2) {
			add_row_tag(row, create_typed_tag('fire', 'Shortest Keycaps'));
		} else {
			add_row_tag(row, create_typed_tag('second', 'Keycaps'));
		}
	} else if (tally.length == 1) {
		let ncp = tally[0].cps.length;
		let repeat = 1 + Math.max(0, MIN_ETH_LENGTH - ncp);
		if (tally[0].count === repeat) {
			add_row_tag(row, create_typed_tag('fire', repeat == 1 ? 'Single' : 'Shortest'));
		} else {
			if (tally[0].count > 1) {
				add_row_tag(row, create_typed_tag('second', 'Repeated'));
			}
			min_repeated = str_from_cps(tally[0].cps).repeat(repeat);
		}
	} else {
		add_row_tag(row, `Unique: ${tally.length}`);
	}
	// if (tokens.every((x, i) => x.form == tokens[tokens.length-1-i].form)) {
	// 	add_row_tag(row, create_palindrome_tag());
	// }
	if (min_repeated) {
		add_row_tag(row, create_resolve_btn(min_repeated + suffix, '↩️ Shortest'));
	}
	return row;
}

function create_digits_row(norm, group, values, negative, suffix) {
	//let row = create_row(`${name0} Digits`);
	let row = create_row('Integer');
	row.classList.add('category', 'integer');
	add_detailed(row);
	let sign = negative ? '-' : '';
	let form = sign + values.join('');
	// if (norm !== form) {
	let main = document.createElement('code');
	main.innerText = form;
	main.classList.add('long', 'main'); 
	row.append(main);
	// }
	if (values.length == (negative ? 2 : 3)) {
		add_row_tag(row, create_typed_tag('fire', 'Shortest'));
	}
	if (values.every((x, i) => x == values[0])) {
		add_row_tag(row, create_typed_tag('second', `Repeated (${values.length})`));
	}
	if (negative) {
		add_row_tag(row, 'Negative');
	} else if (values.length > 1 && values.every((x, i) => x == values[values.length-1-i])) {
		add_row_tag(row, create_palindrome_tag());
	}	
	let pad = 0;
	while (values[pad] === 0) pad++;
	if (pad) {
		add_row_tag(row, `Zero Pad (${pad})`);
	}
	let btn = create_resolve_btn((negative ? KEYCAP_MINUS : '') + values.map(keycap).join('') + suffix, KEYCAP_NAME);
	btn.disabled = group === KEYCAP_NAME;
	add_row_tag(row, btn);
	for (let [name, digits] of DIGITS_MAP) {
		//if (name0 === name) continue;
		let btn = create_resolve_btn(sign + values.map(x => digits.charAt(x)).join('') + suffix, name);
		btn.disabled = group === name;
		add_row_tag(row, btn);
	}
	return row;
}

async function add_contract_name(row, address) {
	let name = RESOLVER_NAMES[address];
	if (active_chain.is_mainnet && name) {
		add_row_tag(row, create_typed_tag('good', name));
	} else if (!await is_contract(address)) {
		add_row_tag(row, create_typed_tag('fail', 'Not a Contract'));
	}
}

function add_old_tag(row, name, is_norm) {
	const OLD_NAME = 'ENSIP-1';
	let span = document.createElement('span');
	span.classList.add('tags', 'old');
	try {
		let norm0 = eth_ens_namehash.normalize(name);
		let norm;
		try {
			norm = ens_normalize(name);
		} catch (err) {
		}
		let html = OLD_NAME;
		if (!is_norm && norm0 !== norm) { // diff-norm
			html += `: ⚠️<b>Diff Norm</b>`;
		}
		if (norm0 === name) {
			span.innerHTML = `✅️ ${html}`;
		} else {
			if (norm === norm0) throw new Error('not normalized');
			add_row_tag(row, create_resolve_btn(norm0, `❌️ ${html}`));
			return;
		}
	} catch (err) {
		span.innerHTML = `❌️ ${OLD_NAME}`;
		span.title = err.message;
	}
	add_row_tag(row, span);
}

function add_nft_links(row, name, contract, token) {
	add_row_tag(row, create_ens_metadata_link(contract, token));
	add_row_tag(row, create_etherscan_nft_link(contract, token));
	add_row_tag(row, create_opensea_nft_link(contract, token));
	if (!active_chain.is_mainnet) return;
	try {
		let encoded = encodeURIComponent(name);
		if (encoded.endsWith('.eth')) {
			add_row_tag(row, create_link(`https://www.ens.vision/name/${encoded.slice(0, -4)}`, VISION_NAME, 'external'));
		}
		add_row_tag(row, create_link(`http://predomain.eth.limo/#/domain/${encoded}`, 'Predomain', 'external'));
	} catch (err) {
	}
}

async function add_avatar(row, resolver) {
	try {
		let avatar = await resolver.getAvatar();
		if (!avatar || should_stop_resolving()) return;
		let {url} = avatar;
		try {
			url = new URL(url).toString().replaceAll('#', '%23');	
		} catch (ignored) {
		}
		let img = new Image();
		img.src = url;
		let a = document.createElement('a');
		a.classList.add('avatar');
		a.href = url;
		a.target = '_blank';
		a.append(img);
		row.append(a);
		resolver.avatar = url;
	} catch (err) {
		console.log('Avatar error', avatar, err);
	}
}

// https://github.com/adraffy/keccak.js/blob/main/src/utils.js#L96
function bytes_from_utf8(s) {
	if (typeof s !== 'string') throw new TypeError('expected string');
	let v = [];
	for (let pos = 0, len = s.length; pos < len; ) {
		let cp = s.codePointAt(pos++);
		if (cp < 0x800) {
			if (cp < 0x80) {
				v.push(cp);
			} else {
				v.push(0xC0 | (cp >> 6), 0x80 | (cp & 0x3F));
			}
		} else {
			if (cp < 0x10000) {
				v.push(0xE0 | (cp >> 12), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
			} else {
				v.push(0xF0 | (cp >> 18), 0x80 | ((cp >> 12) & 0x3F), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
				pos++;
			}
		}
	}
	return Uint8Array.from(v);
}
function utf8_from_bytes(v) {
	let cps = [];
	for (let i = 0, n = v.length; i < n; ) {
		let x = v[i++];
		if (x < 0x80) {
			cps.push(x);
		} else if (x < 0xE0) {
			cps.push(((x & 0x1F) << 6) | req_utf8_cont(v, i++));
		} else if (x < 0xF0) {
			cps.push(((x & 0x0F) << 12) | (req_utf8_cont(v, i++) << 6) | req_utf8_cont(v, i++));
		} else {
			cps.push(((x & 0x07) << 18) | (req_utf8_cont(v, i++) << 12) | (req_utf8_cont(v, i++) << 6) | req_utf8_cont(v, i++));
		}
	}
	return str_from_cps(cps);
}
function req_utf8_cont(v, i) {
	let x = v[i];
	if ((x & 0xC0) != 0x80) throw new Error(`malformed utf8 at ${i}: expected continuation`);
	return x & 0x3F;
}

function name_from_wrapper_bytes(v) {
	if (v.length < 1 || v[v.length-1] != 0) {
		throw new Error('expected null terminator');
	}
	let labels = [];
	for (let pos = 0, end = v.length-1; pos < end; ) {
		let n = v[pos++];
		labels.push(utf8_from_bytes(v.slice(pos, pos += n)));
	}
	return labels.join('.');
}

function make_tokens_div(name, before) {
	// tokenize each label separately so we can show major/minor errors
	// flatten non-errors tokens into wrapper
	let split = ens_split(name);
	let wrapper = document.createElement('div');
	wrapper.classList.add('tokens');
	let first = true;
	for (let i = 0; i < split.length; i++) {
		if (i > 0) {
			wrapper.append(...dom_from_tokens(ens_tokenize('.')).children); 
		}
		let {input, error} = split[i];
		let tokens = dom_from_tokens(ens_tokenize(str_from_cps(input)), {
			before, 
			emoji_url,
			components: show_components_check.checked,
			tld_class: i == split.length-1
		});
		if (error) {
			tokens.classList.add('error');
			if (first) {
				tokens.classList.add('first');
				first = false;
			}
			wrapper.append(tokens);
		} else {
			wrapper.append(...tokens.children);
		}		
	}
	wrapper.classList.add('exploded');
	wrapper.dataset.name = name;
	if (before) wrapper.dataset.before = 1;
	return wrapper;
}

function update_exploded() {
	for (let exploded of output_div.querySelectorAll('.exploded')) {
		let tokens_div = make_tokens_div(exploded.dataset.name, exploded.dataset.before);
		if (exploded.dataset.downgraded) {
			apply_downgrade(tokens_div);
		}
		exploded.replaceWith(tokens_div);
	}
}

function apply_downgrade(tokens_div) {
	tokens_div.dataset.downgraded = '1';
	for (let x of tokens_div.querySelectorAll('.disallowed')) {
		x.classList.add('ignored');
		x.classList.remove('disallowed');
	}
}

function make_exploded(row, name, is_norm, downgrade_disallowed) {	
	let before = !is_norm;
	let tokens_div = make_tokens_div(name, before);
	if (downgrade_disallowed) {
		apply_downgrade(tokens_div);
	}
	let old = row.querySelector('.exploded');
	if (old) {
		old.replaceWith(tokens_div);
	} else {
		row.append(tokens_div);
	}
}

function create_typed_tag(type, value) {
	if (!value) return;
	let span = document.createElement('span');
	if (value instanceof Error) {
		value = value.message;
		span.classList.add('long');
	}
	switch (type) {
		case 'second': 
			value = `⭐️ ${value}`;
			break;
		case 'fresh': {
			type = 'second';
			value = `🌻️ ${value}`;
			break;
		}
		case 'norm':
			//desc = `❌ ${desc}`;
			type = 'warn';
			//break;
		//case 'error':
		//	type = 'fail'
		case 'attn': 
			//desc = `👀️ ${desc}`;
			//break;
		case 'warn': 
			value = `⚠️ ${value}`;
			break;
		case 'fire':
			value = `🔥️ ${value}`;
			break;
		case 'good': 
			break;
		case 'special':
			break;
		case 'fail': 
			value = `❌️ ${value}`;
			break;
		case 'stop':
			type = 'fail';
			value = `🛑️ ${value}`;
			break;
		//default: throw new TypeError(`unknown grade: ${type}`);
	}
	span.innerHTML = value;
	span.classList.add(type);
	return span;
}

function create_namehash_row(name) {
	let row = create_row();
	row.classList.add('details');
	add_detailed(row);
	let hash_span = document.createElement('span');
	hash_span.classList.add('wide');
	hash_span.innerHTML = `<a target="_blank" class="hashproof" href="../../keccak.js/test/demo.html#algo=namehash&s=${encode_uri_component_surrogate_escaped(name)}&escape=1">Namehash:</a> <code>${namehash(name)}</code>`;
	row.append(hash_span);
	return row;
}

function create_details_row(name, before) {
	
	let row = create_namehash_row(name);

	let split = ens_split(name);	

	for (let info of split) {
		info.cps = before || !info.output ? info.input : info.output;
		info.label = str_from_cps(info.cps);
	}

	for (let i = 0; i < split.length; i++) {

		let info = split[i];
		let {cps, label} = info;
		let hash = labelhash(label);
		
		let footer_span = document.createElement('span');
		footer_span.classList.add('wide', 'footer');

		if (cps.length) {

			let label_div = document.createElement('span');
			label_div.classList.add('label');

			if (info.error) {
				label_div.classList.add('error');
			} else if (compare_arrays(info.input, info.output)) { 
				label_div.classList.add('mapped');
			} else {
				upgrade_split_type(info);
				if (info.restricted) {
					label_div.append(create_link(`https://www.compart.com/en/unicode/scripts/${script}`, `<span>${info.type.slice(11, -1)}</span>⚠️`, 'restricted'));
				} else {
					let span = document.createElement('span');
					span.classList.add('group');
					span.innerHTML = info.type;
					if (info.emoji && info.type !== 'Emoji') {
						span.innerHTML += '+';
					}
					if (info.confusing) {
						span.style.color = '#d47';
					}
					label_div.append(span);
				}
			}

			let label_span = document.createElement('span');
			label_span.classList.add('text', 'long');
			label_span.innerText = label; // this will <br> CR LF, disabled with css
			label_div.append(label_span);

			let code = document.createElement('code');
			let len_span = document.createElement('span');

			const update_code = () => {
				let {mode} = code.dataset;
				let text;
				if (code.dataset.mode !== 'cp') {
					code.dataset.mode = 'cp';
					code.title = 'Unicode Codepoints';
					text = cps.map(hex_cp).join(' ');
					set_length(len_span, cps.length);
				} else {
					code.dataset.mode = 'byte';
					code.title = 'Encoded UTF-8 Bytes';
					let bytes = bytes_from_utf8(label);
					text = [...bytes].map(hex_cp).join(' ');
					set_length(len_span, bytes.length, 'bytes');
				}
				code.innerText = text + ' ';
				code.append(swap_btn);
			};

			let swap_btn = document.createElement('button');
			swap_btn.innerText = `⇄`;
			swap_btn.title = `Swap Codepoints/Bytes`;
			swap_btn.addEventListener('click', update_code);

			update_code();
			if (cps.every(cp => cp < 0x80)) {
				swap_btn.remove();
			}

			row.append(label_div, len_span, code);
		
			footer_span.classList.add('sep');
		}

		let footer = [`<a target="_blank" class="hashproof" href="../../keccak.js/test/demo.html#algo=keccak-256&s=${encode_uri_component_surrogate_escaped(label)}&escape=1">Labelhash:</a> <code>${hash}</code>`];
		
		let domain = split.slice(i+1).map(x => x.label).join('.');
		if (NFT_DOMAINS.has(domain)) {
			footer.push(`<b>Token:</b> <code>${ethers.BigNumber.from(labelhash(label))}</code>`);
		}
		if (info.error) { 
			footer.unshift(`<span class="error">❌️ ${info.error}</span>`);
		}
		footer_span.innerHTML = footer.join('<br>');
		row.append(footer_span);
	}
	return row;
}

function create_row(label, waiting) {
	let row = document.createElement('div');
	row.classList.add('row');
	if (label) {
		let span = document.createElement('span');
		span.classList.add('row-label');
		if (typeof label === 'string') {
			span.innerHTML = `${label}:`;
		} else {
			span.append(label);
		}
		row.append(span);
	}
	if (waiting) {
		let div = document.createElement('div');
		div.classList.add('temporary');
		div.innerHTML = '<div class="spinner"></div>';
		row.append(div);
	}
	return row;
}

function remove_temporary(row) {
	for (let x of row.querySelectorAll('.temporary')) {
		x.remove();
	}
}

function add_row_tag(row, tag) {
	if (!tag) return;
	if (typeof tag === 'string') {
		let span = document.createElement('span');
		span.innerHTML = tag;
		tag = span;
	}
	tag.classList.add('tags');
	row.append(tag);
	return true;
}

function trim_trailing_decimal_zeros(s) {
	return s.includes('.') ? s.replace(/\.?0*$/, '') : s;
}
function format_dur(t) {
	if (t < 1000) return `${Math.ceil(t)}ms`;
	t /= 1000;
	let unit;
	if (t < 60) {
		unit = 's';
	} else {
		t /= 60;
		if (t < 60) {
			unit = 'm';
		} else {
			t /= 60;
			if (t < 24) {
				unit = 'h';
			} else {
				t /= 24;
				if (t < 365) {
					unit = 'd';
				} else {
					t /= 365;
					unit = 'y';
				}
			}
		}
	}
	return trim_trailing_decimal_zeros(t.toFixed(1)) + unit;
}

function is_working() {
	return resolve_btn.disabled || !registry_contract;
}
function resolve() {
	if (!registry_contract) return;
	if (is_working()) {
		//parse(); // is this needed?
		resolve_timer = [0]; // ASAP
		return;
	}
	clearTimeout(resolve_timer);
	resolve_timer = RESOLVE_MODE_IDLE;
	ADDRESS_MAP.clear();
	let input = input_field.value;
	let skip = skip_norm_check.checked;
	// replace marketplace URL with token:XXX
	if (input.includes('://')) {
		try {	
			let url = new URL(input);
			if (url.host === 'ens.vision' || url.host === 'www.ens.vision') {
				// https://ens.vision/name/%F0%9F%91%A9%F0%9F%8F%BC%E2%80%8D%F0%9F%A6%BC%E2%80%8D%E2%AC%85
				let v = url.pathname.toLowerCase().split('/').filter(x => x);
				if (v.length >= 2 && v[0] === 'name') {
					input = decodeURIComponent(v[1]);
					if (!input.endsWith('.eth')) input += '.eth';
					input_field.value = input;
				}
			} else { 
				// generalized handler
				// https://opensea.io/assets/ethereum/0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401/65925476150180752387929572463320899353544457962160224303512375154243473029563
				// https://opensea.io/assets/ethereum/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				// https://www.gem.xyz/asset/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				// https://element.market/assets/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				let v = url.pathname.toLowerCase().split('/').filter(x => x);
				if (v.length >= 2 && /^[a-f0-9]+$/i.test(v[v.length-1])) {
					// TODO: fix this, use ensure_nft() and ensure_wrapper() 
					if (v[v.length-2] === '0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85') {
						input_field.value = input = `token:${v[v.length-1]}`;
					} else if (v[v.length-2] === '0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401') {
						input_field.value = input = `wrapped:${v[v.length-1]}`;
					}
				}
			}
		} catch (err) {
		}
	}
	let match;
	// replace token:XXX with ens subgraph label (or fail)
	if (match = input.match(/^(?:labelhash|token):(0x[a-f0-9]+|[0-9]+)$/i)) {
		let hash = ethers.BigNumber.from(match[1]).toHexString();
		resolve_btn.disabled = true;
		return (async() => {
			try {
				if (!active_chain.is_mainnet) throw new Error(`token: only works on mainnet`);
				let res = await fetch('https://api.thegraph.com/subgraphs/name/ensdomains/ens', {
					method: 'POST',
					body: JSON.stringify({
						query: `{domains(where:{labelhash:"${hash}"}){labelName}}`
					})
				});
				if (!res.ok) throw new Error(`HTTP Error ${r.status}`);
				let {data: {domains}} = await res.json();
				if (!domains.length) throw new Error(`Unknown labelhash preimage: ${hash}`);
				let label = domains[0].labelName;
				if (!label) throw new Error(`Unknown labelhash preimage: ${hash}`);
				let hash0 = labelhash(label);
				if (hash0 !== hash) throw new Error(`Incorrect labelhash preimage: "${label}")\n\nExpected: ${hash}\nComputed: ${hash}`);
				input_field.value = `${label}.eth`;
				setTimeout(resolve, 0);
			} catch (err) {
				window.alert(err.message);
				stop_resolving();
			}
			resolve_btn.disabled = false;
		})();
	} else if (match = input.match(/^(?:namehash|wrapped):(0x[a-f0-9]+|[0-9]+)$/i)) {
		resolve_btn.disabled = true;
		return (async () => {
			try {
				await ensure_wrapper();
				let hash = ethers.utils.hexZeroPad(ethers.BigNumber.from(match[1]).toHexString(), 32);
				let bytes = ethers.utils.arrayify(await wrapper_contract.callStatic.names(hash));
				if (!bytes.length) throw new Error(`Unknown namehash preimage: ${hash}`);
				input_field.value = name_from_wrapper_bytes(bytes);
				resolve_btn.disabled = false;
				setTimeout(resolve, 0);
			} catch (err) {
				window.alert(err.message);
				stop_resolving();
			}
			resolve_btn.disabled = false;
		})();
	}
	// input convenience: expand range
	if (match = input.match(/^range:([0-9a-f]+)\.\.([0-9a-f]+)$/i)) {
		let lo = parseInt(match[1], 16);
		let hi = parseInt(match[2], 16);
		if (hi >= lo) {
			input = str_from_cps(Array(1 + hi - lo).fill().map((_, i) => lo + i));
		}
	}
	// input convenience: HEX HEX HEX => {HEX}{HEX}
	if (/^\s*[0-9a-f]{2,}(\s+[0-9a-f]{2,})+\s*$/i.test(input)) { 
		input = input.trim().split(/\s+/).map(x => `{${x}}`).join('');	
	}
	// input convenience: entities
	input = input.replace(/&#?[0-9a-z]+;/gui, x => {
		entity_span.innerHTML = x;
		return apply_escapes(entity_span.innerText);
	});
	input_field.value = input;
	let name = replace_name(replace_escapes(input));
	add_recent(name);
	if (!parse() && (!input || !skip)) {
		primary_loader.classList.add('hide');
		return;
	}
	resolve_btn.disabled = true;
	primary_loader.classList.remove('hide');
	resolve_date0 = new Date();
	resolve1(name, skip).then(() => {
		resolve_btn.disabled = false;
		if (Array.isArray(resolve_timer)) {
			setTimeout(resolve, Math.max(0, resolve_timer[0] - Date.now()));
		} else {
			primary_loader.classList.add('hide');
		}
	});
}

function create_elapsed() {
	let now = new Date();
	let delta = now - resolve_date0;
	if (delta < 1) return; // 0ms is stupid
	let span = document.createElement('span');
	span.classList.add('elapsed');
	span.innerHTML = format_dur(delta);
	resolve_date0 = now;
	return span;
}

async function resolve1(input, skip_norm) {
	output_div.innerHTML = '';
	//output_div.append(links_copy);

	let input_is_address = is_checksum_address(input);
	let input_row;
	let normed_row;
	let reverse_row;
	let name_norm;
	let norm_err;

	if (input_is_address) {
		input_row = create_row('Address');
		input_row.append(create_jazz_icon(input));
		input_row.append(create_etherscan_address_link(input));
		add_row_tag(input_row, create_copy_btn(input));
		add_row_tag(input_row, create_reverse_resolve_btn(input));
		add_owner_links(input_row, input);

		// doesn't give enough information
		// primary = await active_provider.lookupAddress(input);

		let rev_name = reverse_name(input);
		let rev_node = namehash(rev_name);

		let rev_details = create_namehash_row(rev_name);
		let rev_name_span = document.createElement('span');
		rev_name_span.classList.add('wide');
		rev_name_span.innerHTML = `<b>Reverse Name:</b> ${rev_name}`;
		rev_details.prepend(rev_name_span);

		output_div.append(input_row, rev_details);

		let resolver_row = create_row('Reverse Resolver', true); // ↺ 
		output_div.append(resolver_row);

		if (await is_contract(input)) {
			make_contract(input_row);
		}
		if (should_stop_resolving()) return;

		let resolver, last_err;
		try {
			resolver = await registry_contract.callStatic.resolver(rev_node);
			if (is_null_hex(resolver)) resolver = false;
		} catch (err) {	
			if (!is_address_type_error(err)) {
				last_err = err;
			}
		} 
		if (should_stop_resolving()) return;
		remove_temporary(resolver_row);	
		add_row_tag(resolver_row, create_elapsed());

		if (reverse_registrar === null) {
			try {
				reverse_registrar = await registry_contract.callStatic.owner(namehash(REVERSE_DOMAIN));
			} catch (err) {
				reverse_registrar = false;
			}
			if (should_stop_resolving()) return;
		}

		if (reverse_registrar) {
			add_row_tag(input_row, create_etherscan_address_link(reverse_registrar, {
				contract: true, 
				anchor: '#writeContract#F7',
				title: '<button class="glow">✍️ Set Name</button>'
			}));
		}

		if (last_err) {
			resolver_row.classList.add('error');
			add_row_tag(resolver_row, create_typed_tag('warn', last_err));
			return;
		} else if (!resolver) {
			add_row_tag(resolver_row, create_typed_tag('stop', 'Primary Not Set'));
			return;
		}

		resolver_row.append(create_etherscan_address_link(resolver, {contract: true}));
		await add_contract_name(resolver_row, resolver);
		if (should_stop_resolving()) return;
		add_row_tag(resolver_row, create_copy_btn(resolver));

		reverse_row = normed_row = create_row('Reverse', true);
		output_div.append(reverse_row);
			
		let primary;
		try {
			let contract = new ethers.Contract(resolver, [
				`function name(bytes32 node) view returns (string)`
			], active_provider);
			primary = await contract.callStatic.name(rev_node);
		} catch (err) {	
			last_err = err;
		} 
		if (should_stop_resolving()) return;
		remove_temporary(reverse_row);
		add_row_tag(reverse_row, create_elapsed());
		if (last_err) {
			reverse_row.classList.add('error');
			add_row_tag(reverse_row, create_typed_tag('warn', last_err));
			return;
		} else if (!primary) {
			add_row_tag(reverse_row, create_typed_tag('stop', 'Primary is Null'));
			return;
		}

		make_exploded(reverse_row, primary, false);
		add_row_tag(reverse_row, create_copy_btn(primary));
		add_row_tag(reverse_row, create_ens_link(primary));
		//add_nft_links(reverse_row, primary);
		output_div.append(create_details_row(primary, true));
			
		try {
			name_norm = ens_normalize(primary);
		} catch (err) {
			reverse_row.classList.add('error');
			add_row_tag(reverse_row, create_typed_tag('norm', err));
			if (!skip_norm) return;
			name_norm = primary;
			norm_err = err;
		}
		if (!norm_err) {
			if (name_norm === primary) {
				add_row_tag(reverse_row, create_resolve_btn(primary));
				make_normalized(reverse_row, name_norm);
			} else {
				add_row_tag(reverse_row, create_typed_tag('fail', 'Normalized'));
				let row = normed_row = create_row('Normalized Reverse');
				make_exploded(row, name_norm, true);
				add_row_tag(row, create_copy_btn(name_norm));
				add_row_tag(row, create_resolve_btn(name_norm));
				make_normalized(row, name_norm);
				output_div.append(row);
				output_div.append(create_details_row(name_norm));
			}	
		}
	} else {
		
		// the input is a name
		input_row = normed_row = create_row(INPUT_NAME);
		input_row.classList.add('input');
		make_exploded(input_row, input, false);
		add_row_tag(input_row, create_ens_link(input));
		output_div.append(input_row);
		output_div.append(create_details_row(input, true));
		add_row_tag(input_row, create_copy_btn(input));

		if (/^0x[0-9a-f]{40}$/i.test(input)) {
			add_row_tag(input_row, create_resolve_btn(ethers.utils.getAddress(input.toLowerCase()), '🛠️ Fix Checksum'));
		}
		if (!input.includes('.')) {
			add_row_tag(input_row, create_resolve_btn(`${input}.eth`, '🔄️ Add <b>".eth"</b>'));
		}

		try {
			name_norm = ens_normalize(input);
		} catch (err) {
			input_row.classList.add('error');
			add_row_tag(input_row, create_typed_tag('norm', err));
			if (!skip_norm) return; // i think this is always true
			name_norm = input;
			norm_err = err;
		}	

		if (norm_err) {
			//add_nft_links(input_row, input);
		} else {
			if (name_norm === input) {
				make_normalized(input_row, name_norm);
				//add_nft_links(input_row, input);
			} else  { 
				add_row_tag(input_row, create_typed_tag('fail', 'Normalized'));
				if (skip_norm) {
					name_norm = input;
				} else {
					add_transformed_row(input);
					let row = normed_row = create_row('Normalized');
					make_exploded(row, name_norm, true);
					make_normalized(row, name_norm);
					add_row_tag(row, create_copy_btn(name_norm));
					add_row_tag(row, create_resolve_btn(name_norm));
					add_row_tag(row, create_ens_link(name_norm));
					//add_nft_links(row, name_norm);
					add_old_tag(row, name_norm, true);
					output_div.append(row);
					output_div.append(create_details_row(name_norm));
				}
			}
		}
		add_old_tag(input_row, input);
	}

	let sep_pos = name_norm.indexOf('.');
	if (sep_pos == -1) sep_pos = name_norm.length;
	if (sep_pos > 0) {
		let prefix = name_norm.slice(0, sep_pos);
		let suffix = name_norm.slice(sep_pos); 
		let tokens = ens_tokenize(prefix);
		if (tokens.every(t => t.type === 'emoji')) {
			input_row.after(create_ethmoji_row(tokens, suffix));
			let negative = str_from_cps(tokens[0].emoji) == KEYCAP_MINUS;
			if (negative) tokens = tokens.slice(1);
			let values = tokens.map(x => x.emoji[0] - 0x30);
			if (values.every(x => x >= 0 && x < 10)) {
				input_row.after(create_digits_row(name_norm, KEYCAP_NAME, values, negative, suffix));
			}
		} else {
			let negative = prefix.startsWith('-');
			if (negative) prefix = prefix.slice(1);
			if (prefix) {
				let cps = explode_cp(prefix);
				let digits = cps.map(cp => DIGIT_MAP.get(cp));
				if (digits.every(x => x)) {
					let values = digits.map(x => x.i);
					let name0 = digits[0].name;
					if (digits.every(x => x.name === name0)) {
						//if (digits[0].reversed) values.reverse(); // LTR
						input_row.after(create_digits_row(name_norm, name0, values, negative, suffix));
					} else {
						let first = digits[0].mixed;
						if (first && digits.every(x => x.mixed == first)) {
							let row = create_digits_row(name_norm, 'Arabic', values, negative, suffix); //values.reverse()); // LTR
							add_row_tag(row, create_typed_tag('warn', 'Mixed Digits'));
							input_row.after(row);
						} else {
							let row = create_digits_row(name_norm, 'Numeric', values, negative, suffix);
							add_row_tag(row, create_typed_tag('warn', 'Multiple Scripts'));
							input_row.after(row);
						}
					}
				}
			}
		}
	}

	if (!skip_norm && !norm_err) {
		let pretty = ens_beautify(name_norm);
		let row = create_row(`Beautified`);
		row.classList.add('pretty');
		row.append(create_main_span(pretty));
		add_row_tag(row, create_copy_btn(pretty));
		if (input !== pretty) {
			add_row_tag(row, create_resolve_btn(pretty));
		}
		add_row_tag(row, create_pretty_tag());
		if (input === pretty) { 
			add_row_tag(input_row, create_pretty_tag());
			add_row_tag(row, create_typed_tag('good', 'Same as Input'));
		} else if (name_norm === pretty) {			
			add_row_tag(normed_row, create_pretty_tag());
			add_row_tag(row, create_typed_tag('good', 'Same as Norm'));
		}
		add_old_tag(row, pretty);
		output_div.append(row);
	}

	output_div.append(create_dns_row(name_norm));

	// at this point, we have a name
	// lookup the name
	let resolver, resolver_err;
	let is_wildcard, wildcard_domain;
	let resolver_row = create_row('Resolver', true);
	output_div.append(resolver_row);
	try {
		resolver = await active_provider.getResolver(name_norm);
	} catch (err) {
		if (!is_address_type_error(err)) {
			resolver_err = err;
		}
	}
	if (should_stop_resolving()) return;
	if (resolver) {
		try {
			is_wildcard = await resolver.supportsWildcard(); // this can throw
		} catch (err) {
		}
		if (should_stop_resolving()) return;
		if (is_wildcard) { 
			// ethers doesn't expose this information
			// https://github.com/ethers-io/ethers.js/issues/3398
			let v = name_norm.split('.');
			try {
				while (true) {
					let parent = v.join('.');
					let address = await registry_contract.callStatic.resolver(namehash(parent));
					if (should_stop_resolving()) return;
					if (address === resolver.address) {
						wildcard_domain = parent;
						break;
					}	
					v.shift();
				}
			} catch (ignored) {
			}
		}
		await add_avatar(normed_row, resolver);	
		if (should_stop_resolving()) return;
	}
	remove_temporary(resolver_row);	
	add_row_tag(resolver_row, create_elapsed());
	
	if (resolver_err) {
		resolver_row.classList.add('error');
		add_row_tag(resolver_row, create_typed_tag('warn', resolver_err));
	} else if (resolver) { 
		resolver_row.append(create_etherscan_address_link(resolver.address, {contract: true}));
		add_row_tag(resolver_row, create_copy_btn(resolver.address));
		if (is_wildcard) {
			add_row_tag(resolver_row, create_typed_tag('special', 'Wildcard'));
			if (wildcard_domain === name_norm) {
				add_row_tag(resolver_row, 'Basename');
			} else if (wildcard_domain) {
				add_row_tag(resolver_row, create_resolve_btn(wildcard_domain, `↩️ ${wildcard_domain}`));
			} else {
				add_row_tag(resolver_row, create_typed_tag('warn', 'Unknown Parent'));
			}
		} else {
			add_contract_name(resolver_row, resolver.address);
			if (should_stop_resolving()) return;
		}
	} else {
		add_row_tag(resolver_row, create_typed_tag('warn', `Not Set`));	
	}

	let parent_domain = name_norm.slice(sep_pos+1);
	let nft_backed = NFT_DOMAINS.has(name_norm.slice(sep_pos+1));
	let nft_contract;
	let nft_token;

	let avail_row;
	let available;	
	if (parent_domain === 'eth') {
		let eth_label = name_norm.slice(0, sep_pos);
		nft_token = ethers.utils.id(eth_label);
		let avail_err;
		let expiry;
		let len = Array.from(eth_label).length;
		avail_row = create_row('Availability', true);
		let premium;
		output_div.append(avail_row);
		try {
			await ensure_eth_nft();
			if (should_stop_resolving()) return;
			nft_contract = eth_nft_contract;
			if (len >= MIN_ETH_LENGTH) {
				available = await eth_nft_contract.callStatic.available(nft_token);
				if (should_stop_resolving()) return;
				expiry = (await eth_nft_contract.callStatic.nameExpires(nft_token)).toNumber();
				if (available) {
					if (should_stop_resolving()) return;
					premium = await price_oracle_contract.callStatic.premium(eth_label, expiry, 0);
				}
			}
		} catch (err) {
			avail_err = err;
		}
		remove_temporary(avail_row);
		if (should_stop_resolving()) return;
		add_row_tag(avail_row, create_elapsed()); 
		add_row_tag(avail_row, set_length(document.createElement('span'), len));

		if (avail_err) {
			avail_row.classList.add('error');
			add_row_tag(avail_row, create_typed_tag('warn', avail_err));
		} else if (available === undefined) {
			add_row_tag(avail_row, create_typed_tag('fail', `Too Short`));
			let padded = Array(1 + Math.max(0, MIN_ETH_LENGTH - len)).fill(eth_label).join('');
			add_row_tag(avail_row, create_resolve_btn(`${padded}.eth`, '↩️ Repeat until 3+'));
		} else if (available) {
			add_row_tag(avail_row, create_ens_link(name_norm, '<button class="glow">👌️ Available to Register</button>'));
			let ether = parseFloat(ethers.utils.formatEther(premium));
			if (ether) {
				add_row_tag(avail_row, create_typed_tag('warn', `${ether.toFixed(ether < 1 ? 4 : 2)}Ξ Premium`));
			}
			//add_row_tag(avail_row, create_typed_tag('fire', 'Available'));
			//add_row_tag(avail_row, create_ens_link(name_norm, {title: 'Register'}));
		} else {
			let exp = expiry * 1000;
			let end = exp + eth_nft_contract.grace_period;
			let now = Date.now();
			if (now >= exp && now <= end) {
				add_row_tag(avail_row, create_typed_tag('warn', `Grace period (${format_dur(eth_nft_contract.grace_period)}) ends in ${format_dur(end - now)}`));
			} else {
				let span_reg = document.createElement('span');
				span_reg.innerText = `✍️ Registered until ${new Date(exp).toLocaleDateString()}`;
				span_reg.style.backgroundColor = '#def';
				add_row_tag(avail_row, span_reg);
				if (exp - now < eth_nft_contract.warning_period) {
					add_row_tag(avail_row, create_typed_tag('warn', `Expires in ${format_dur(exp - now)}`));
				} else {
					span_reg.innerHTML += ` (${format_dur(exp - now)})`;
				}
			}
		}
		if (nft_contract) {
			let span = avail_row.querySelector('.row-label');
			span.title = `Grace: ${format_dur(nft_contract.grace_period)}\nPremium: ${format_dur(price_oracle_contract.premium_period)}`;
		}
		//add_row_tag(avail_row, create_etherscan_address_link(price_oracle_contract.address, {title: 'Price Oracle', contract: true}));
	} else if (nft_backed) {
		let label = name_norm.slice(0, sep_pos);
		nft_token = ethers.utils.id(label);
		let avail_url;
		let avail_err;
		avail_row = create_row('Availability', true);
		output_div.append(avail_row);
		try {
			let address = await registry_contract.callStatic.owner(namehash(parent_domain));
			if (should_stop_resolving()) return;
			if (is_null_hex(address)) throw new Error('Missing backing contract');
			nft_contract = new ethers.Contract(address, [
				'function available(uint256 id) external view returns(bool)',
				'function ownerOf(uint256 id) external view returns (address)',
			], active_provider);
			available = await nft_contract.callStatic.available(nft_token); //.catch(() => {});
			if (active_chain.is_mainnet && parent_domain === 'art') {
				avail_url = `https://protocol.art/api/art-tokens?exact=${encodeURIComponent(label)}`;
				if (available) {
					try {
						let res = await fetch(avail_url);
						let {Items} = await res.json();
						available = !Items.length;
					} catch (ignored) {
					}
				}
			}
		} catch (err) {
			avail_err = err;
		}
		remove_temporary(avail_row);
		if (should_stop_resolving()) return;
		add_row_tag(avail_row, create_elapsed()); 
		add_row_tag(avail_row, set_length(document.createElement('span'), Array.from(label).length));
		if (nft_contract) {
			let label = avail_row.querySelector('.row-label');
			let title = label.innerHTML;
			label.innerHTML = '';
			label.append(create_etherscan_address_link(nft_contract.address, {title, contract: true}));
		}
		if (avail_err) {
			avail_row.classList.add('error');
			add_row_tag(avail_row, create_typed_tag('warn', avail_err));
		} else {
			add_row_tag(avail_row, create_typed_tag(available ? 'good' : 'fail', 'Available'));
			if (avail_url) {
				add_row_tag(avail_row, create_link(avail_url, 'Details', 'external'));
			}
		}
	}
	
	// get the owner
	let is_wrapped, owner, nft_owner;
	if ((!nft_backed || available !== undefined) && (!is_wildcard || wildcard_domain === name_norm)) { 
		let node = namehash(name_norm);
		let wrapped_row = create_row('Wrapper', true);

		if (!available) {
			output_div.append(wrapped_row);

			let wrapped_err;
			let unwrappable = name_norm.split('.').some(x => bytes_from_utf8(x).length > 255);
			try {
				await ensure_wrapper();
				if (should_stop_resolving()) return;
				if (!unwrappable) {
					is_wrapped = await wrapper_contract.callStatic.isWrapped(node);
				}
			} catch (err) {
				wrapped_err = err;
			}
			remove_temporary(wrapped_row);
			if (should_stop_resolving()) return;
			add_row_tag(wrapped_row, create_elapsed());
			if (wrapped_err) {
				wrapped_row.classList.add('error');
				add_row_tag(wrapped_row, create_typed_tag('warn', wrapped_err));
			} else if (unwrappable) {
				add_row_tag(wrapped_row, create_typed_tag('warn', 'Unwrappable'));
			} else {
				add_row_tag(wrapped_row, is_wrapped ? create_typed_tag('good', '🎁 Wrapped') : '🎉 Unwrapped');
				if (nft_backed && !is_wrapped) {
					// let tag = document.createElement('span');
					// tag.classList.add('tags', 'second');
					// tag.innerHTML = '🪙️ ';
					// tag.append(create_etherscan_address_link(nft_contract.address, {title: 'Tokenized', contract: true}));
					add_row_tag(wrapped_row, create_typed_tag('second', `Tokenized`));
				}
			}
			if (wrapper_contract) {
				let label = wrapped_row.querySelector('.row-label');
				let title = label.innerHTML;
				label.innerHTML = '';
				label.append(create_etherscan_address_link(wrapper_contract.address, {title, contract: true}));
			}
			if (is_wrapped) {
				add_nft_links(normed_row, name_norm, wrapper_contract.address, node);
				/*if (nft_contract) {
					add_row_tag(wrapped_row, create_etherscan_nft_link(nft_contract.address, nft_token));
					add_row_tag(wrapped_row, create_opensea_link(nft_contract.address, nft_token));
				}*/
			} else if (nft_contract) {
				add_nft_links(normed_row, name_norm, nft_contract.address, nft_token);
			}
		}
		// there doesn't seem to be an "owner"
		//owner = await resolver._fetch('0x02571be3'); // owner(bytes32)
		//owner = await resolver._fetch('0x38a699a4'); // exists(bytes32)
		//owner = await resolver._fetch('0x7dd56411'); // ownerOf(bytes32)
		let owner_row = create_row(available ? 'Previous Owner' : 'Owner', true);
		let owner_err;
		let checked_nft;
		output_div.append(owner_row);
		try {
			if (is_wrapped) {
				let data = await wrapper_contract.callStatic.getData(node);
				if (should_stop_resolving()) return;
				owner = data.owner;
				let {fuses} = data;
				if (!(fuses & (1 << 17))) { // eth
					await ensure_eth_nft(); 
					if (should_stop_resolving()) return;
					let exp = data.expiry * 1000 - eth_nft_contract.grace_period; // includes grace
					let now = Date.now();
					if (exp > now) {
						add_row_tag(wrapped_row, create_typed_tag('warn', `Expires in ${format_dur(exp - now)}`));
					}
				}
				if (fuses == 0) add_row_tag(wrapped_row, '👊️ Can Do Everything');
				if (fuses & 0x00001) add_row_tag(wrapped_row, '🚫️ Unwrap');
				if (fuses & 0x00002) add_row_tag(wrapped_row, '🚫️ Burn Fuses');
				if (fuses & 0x00004) add_row_tag(wrapped_row, '🚫️ Transfer');
				if (fuses & 0x00008) add_row_tag(wrapped_row, '🚫️ Set Resolver');
				if (fuses & 0x00010) add_row_tag(wrapped_row, '🚫️ Set TTL');
				if (fuses & 0x00020) add_row_tag(wrapped_row, '🚫️ Subdomains');
				if (fuses & 0x00040) add_row_tag(wrapped_row, '🚫️ Approve');
				if (fuses & 0x10000) add_row_tag(wrapped_row, create_typed_tag('warn', 'Parent Controlled'));
				if (fuses & 0x40000) add_row_tag(wrapped_row, '☑️ Extend Expiry');
			} else {
				owner = await registry_contract.callStatic.owner(node);
				if (should_stop_resolving()) return;
				if (is_null_hex(owner)) owner = false;
				if (!owner && nft_contract) {
					checked_nft = true;
					owner = await nft_contract.callStatic.ownerOf(nft_token).catch(() => {});
					if (is_null_hex(owner)) owner = false;
				}
			}
		} catch (err) {
			owner_err = err;
		}
		if (should_stop_resolving()) return;
		if (await is_contract(owner)) make_contract(owner_row);
		remove_temporary(owner_row);
		if (should_stop_resolving()) return;
		add_row_tag(owner_row, create_elapsed());
		if (owner_err) {
			owner_row.classList.add('error');
			owner_row.append(create_typed_tag('warn', owner_err));
		} else if (!owner) {
			if (available) {
				add_row_tag(owner_row, create_typed_tag('fresh', '<i>None</i>'));
			} else {
				add_row_tag(owner_row, create_typed_tag('warn', 'Not Set'));
			}
		} else {
			owner_row.classList.add(available ? 'old' : 'owner');
			owner_row.append(create_etherscan_address_link(owner));
			add_row_tag(owner_row, create_copy_btn(owner));
			//owner_row.classList.toggle('old', available);
			// if the input was an address, we can validate
			if (input_is_address) {
				add_row_tag(reverse_row, create_typed_tag(owner === input ? 'good' : 'fail', 'Owned'));
				if (owner === input) {
					add_row_tag(owner_row, 'Same as Input');
				}
			}
			if (owner !== input) {
				add_row_tag(owner_row, create_resolve_btn(owner));
				add_owner_links(owner_row, owner);
			}
			if (active_chain.is_mainnet && parent_domain === 'art') {
				add_row_tag(avail_row, create_link(`https://protocol.art/account/${owner}`, 'Configure', 'external'));
			}
			if (!is_wrapped && !available && !checked_nft && nft_contract) {
				let nft_row = create_row(create_etherscan_address_link(nft_contract.address, {title: `${NFT_OWNER_NAME}:`, contract: true}), true);
				nft_row.classList.add('nft');
				output_div.append(nft_row);
				try {
					await ensure_eth_nft();
					nft_owner = await nft_contract.callStatic.ownerOf(nft_token);
					if (is_null_hex(nft_owner)) nft_owner = false;
				} catch (err) {
				}
				if (should_stop_resolving()) return;
				if (nft_owner && nft_owner !== owner) {
					owner_row.querySelector('.row-label').innerText = `${MANAGER_NAME}:`;
					owner_row.insertAdjacentElement('beforebegin', nft_row); // move up
					let a = create_etherscan_address_link(nft_owner);
					nft_row.append(create_jazz_icon(nft_owner));
					nft_row.append(a);
					//if (await is_contract(nft_owner)) make_contract(nft_row);
					//if (should_stop_resolving()) return;
					try {
						let norm = await get_safe_primary(nft_owner, owner);
						if (should_stop_resolving()) return;
						if (norm.endsWith('.' + name_norm)) { // proper subdomain
							nft_owner = norm; // swap
							let sub = norm.slice(0, -(name_norm.length + 1));
							a.innerHTML = `<b>${ens_beautify(sub)}</b>.${ens_beautify(name_norm)}`;
							add_row_tag(nft_row, create_typed_tag('good', 'Subdomain'));
						} else {
							a.innerHTML = ens_beautify(norm);
							//add_row_tag(nft_row, create_typed_tag('good', 'Owned'));
						}
					} catch (err) {
					}
					add_row_tag(nft_row, create_copy_btn(nft_owner));
					if (nft_owner !== input) {
						add_row_tag(nft_row, create_resolve_btn(nft_owner));
					}
					add_owner_links(nft_row, nft_owner);
					add_row_tag(nft_row, create_elapsed());
					remove_temporary(nft_row);
					nft_row.classList.toggle('old', !!available);
				} else {
					nft_row.remove();
				}
			}
			owner_row.append(create_jazz_icon(owner));
		}
	}

	if (resolver && !NOT_IFACE_RESOLVER.has(resolver.address)) {
		let row = create_row('<a href="https://docs.ens.domains/contract-api-reference/.eth-permanent-registrar#discovery">Interfaces</a>', true);
		output_div.append(row);	
		let contract = contract_for_resolver(resolver);
		// https://docs.ens.domains/contract-api-reference/.eth-permanent-registrar	
		const TITLE_WRAPPER = '<b>Wrapper</b> ERC-1155';
		const TITLE_NFT = '<b>NFT</b> ERC-721';
		let interfaces = [
			//{iface: IFACE_ETH_NFT, name: 'NFT'},  
			{iface: '0x019a38fe', title: TITLE_WRAPPER},
			{iface: IFACE_ETH_CONTROLLER, title: '<b>Controller</b>'},
			{iface: '0x018fac06', title: '<b>Old Controller</b>'},
			{iface: '0x6ccb2df4', name: TITLE_NFT},
			{iface: '0x7ba18ba1', title: '<b>Migration</b>'},
		];
		let discovered = new Set();
		function add_iface(html, addr) {
			if (is_null_hex(addr)) return;
			if (discovered.has(addr)) return;
			discovered.add(addr);
			html += ` <code class="prefix">${addr.slice(0, 6)}</code>`;
			let a = create_etherscan_address_link(addr, {title: html, contract: true});
			a.classList.add('iface');
			add_row_tag(row, a);
		}
		try {
			// https://github.com/ensdomains/ens-contracts/blob/dev/contracts/resolvers/profiles/IInterfaceResolver.sol
			if (!await contract.callStatic.supportsInterface('0x124a319c')) {
				throw new Error('not EIP-165');
			}
			for (let {iface, title} of interfaces) {
				let addr = await contract.get_interface(iface);
				if (is_null_hex(addr)) continue;
				if (!discovered.size) {
					add_iface(TITLE_NFT, owner);
				}
				add_iface(`${title} <code>${iface.slice(2)}</code>`, addr);
				if (iface === IFACE_ETH_CONTROLLER) {
					let controller = contract_for_controller(addr);
					let oracle = contract_for_price_oracle(await controller.callStatic.prices());
					add_iface('<b>Price Oracle</b>', oracle.address);
					add_iface('<b>USD Oracle</b>', await oracle.callStatic.usdOracle());
					add_iface(TITLE_WRAPPER, await controller.callStatic.nameWrapper());
					//add_iface('DAO Wallet', await contract.callStatic.owner().catch(() => ''));
				}
			}
		} catch (err) {
			if (discovered.size) {
				add_row_tag(row, create_typed_tag('warn', err));
			}
		}
		if (should_stop_resolving()) return;
		if (discovered.size) {
			remove_temporary(row);
			add_row_tag(row, create_elapsed()); 
		} else {
			row.remove();
			NOT_IFACE_RESOLVER.add(resolver.address);
		}
	}

	// add address
	let address;
	if (resolver) {
		let address_err;
		let address_row = create_row(`ETH Address`, true);
		address_row.classList.add(available ? 'old' : 'addr');
		output_div.append(address_row);	
		try {
			address = await resolver.getAddress();
			if (is_null_hex(address)) address = false;
		} catch (err) {
			if (!is_address_type_error(err)) {
				address_err = err;
			}
		}
		if (should_stop_resolving()) return;
		if (await is_contract(address)) make_contract(address_row);
		if (should_stop_resolving()) return;
		if (address_err) {
			address_row.classList.add('error');
			add_row_tag(address_row, create_typed_tag('warn', address_err));
		} else if (!address) {
			add_row_tag(address_row, create_typed_tag('warn', 'Not Set'));
		} else {
			address_row.append(create_jazz_icon(address));
			address_row.append(create_etherscan_address_link(address));
			address_row.append(create_copy_btn(address));
			if (input_is_address) {
				if (address === input) {
					add_row_tag(input_row, create_typed_tag('fire', 'Primary'));
					add_row_tag(address_row, 'Same as Input');
				} else if (address) {
					add_row_tag(address_row, create_resolve_btn(address));
					add_row_tag(address_row, create_typed_tag('warn', 'Different from Owner'));	
				}
			// } else if (owner !== address && nft_owner !== address) {
			// 	add_row_tag(address_row, create_resolve_btn(address));
			// 	if (owner) {
			// 		add_row_tag(address_row, create_typed_tag('fail', 'Owner'));	
			// 	}
			// 	add_owner_links(address_row, address); 
			} else if (owner === address) {
				if (nft_owner && nft_owner !== address) {
					add_row_tag(address_row, create_typed_tag('good', `Same as ${MANAGER_NAME}`));	
				} else {
					add_row_tag(address_row, create_typed_tag('good', 'Same as Owner'));
				}
			} else if (nft_owner === address) {
				add_row_tag(address_row, create_typed_tag('good', `Same as ${NFT_OWNER_NAME}`));
			} else {
				add_row_tag(address_row, create_resolve_btn(address));
				if (owner) {
					add_row_tag(address_row, create_typed_tag('fail', 'Owner'));	
				}
				add_owner_links(address_row, address);
			}
		}
		remove_temporary(address_row);
		add_row_tag(address_row, create_elapsed());	

		if (show_records_check.checked) {
			let records_row = create_row(`Records`, true);
			records_row.classList.add('records');
			if (available) records_row.classList.add('old');
			output_div.append(records_row);	
			let any;
			for (let {rec, data, error} of await fetch_records(resolver, is_wildcard)) {
				if (!data) continue;
				if (error) continue;
				//if (error) return create_typed_tag('warn', error);
				let a = document.createElement('a');
				a.classList.add('record');
				if (rec.url) {
					a.href = rec.url(data);
					a.target = '_blank';
				} else {
					make_copier(a, data);
				}
				switch (rec.type) {
					case 'addr': {
						a.title = `Encoded CoinType: ${rec.coin}`;
						a.innerHTML = rec.icon || `<b>coin(${rec.coin})</b>`;
						if (rec.format) {
							let span = document.createElement('span');
							span.innerText = rec.format(data);
							a.append(span);
						}
						break;
					}
					case 'text': {
						a.title = rec.key;
						a.innerHTML = rec.icon || `<b>${rec.key}</b>`;
						let text = rec.format ? rec.format(data) : data;
						if (text) {
							let span = document.createElement('span');
							span.innerText = text;
							a.append(span);
						}
						break;
					}
					case 'contenthash': {
						a.innerHTML = `<b>${rec.type}</b>`;
						a.title = 'Encoded Content Hash';
						break;
					}
				}
				//if (rec.customize) rec.customize(a);
				records_row.append(a);
				any = true;
			}
			if (!any) {
				add_row_tag(records_row, 'None');
			}
			if (should_stop_resolving()) return;
			remove_temporary(records_row);
			add_row_tag(records_row, create_elapsed());	
		}
	}

	if (input_is_address || !address) return; // nothing more to do

	// lookup primary from eth address 
	let primary, primary_err;
	let primary_row = create_row('Primary', true);	
	output_div.append(primary_row);
	primary_row.append(create_jazz_icon(address));
	try {
		primary = await active_provider.lookupAddress(address);
		if (debug) primary = primary.toUpperCase();
	} catch (err) {
		primary_err = err;
	}
	remove_temporary(primary_row);
	if (should_stop_resolving()) return;
	add_row_tag(primary_row, create_elapsed());

	primary_row.classList.toggle('old', !!available);
	
	if (primary_err) {
		primary_row.classList.add('error');
		add_row_tag(primary_row, create_typed_tag('warn', primary_err));
		return;
	}
	if (!primary) {
		add_row_tag(primary_row, create_typed_tag('warn', 'Not Set'));
		return;
	}

	// primary exists
	make_exploded(primary_row, primary, false);

	// lets check if it's normalized
	let primary_norm;
	try {
		primary_norm = ens_normalize(primary);
		if (primary === primary_norm) {
			make_normalized(primary_row, primary_norm);
		}
		// note: dont add extra junk if its the same
		if (primary === input) {
			add_row_tag(primary_row, 'Same as Input');
		} else if (primary === name_norm) {		
			add_row_tag(primary_row, 'Same as Norm');
		} else {
			if (primary === ens_beautify(primary)) {
				add_row_tag(primary_row, create_pretty_tag());
			}
			add_row_tag(primary_row, create_copy_btn(primary_norm));
			add_row_tag(primary_row, create_resolve_btn(primary));
			add_old_tag(primary_row, primary);
			//add_row_tag(primary_row, create_ens_link(primary_norm));
			let details_row = create_details_row(primary, true);
			details_row.classList.toggle('old', !!available);
			output_div.append(details_row);
		}
	} catch (err) {
		primary_row.classList.add('error');
		add_row_tag(primary_row, create_typed_tag('norm', err));
		add_old_tag(primary_row, primary);
	}

	// primary was valid but not normalized
	if (primary_norm && primary !== primary_norm) {
		add_row_tag(primary_row, create_typed_tag('fail', 'Normalized'));
		// create norm row
		let row = create_row('Normalized Primary');
		row.classList.toggle('old', !!available);
		make_exploded(row, primary_norm, true);
		make_normalized(row, primary_norm);
		//add_row_tag(row, create_ens_link(primary_norm));
		//add_nft_links(row, primary_norm);
		if (primary_norm === input) {
			add_row_tag(row, 'Same as Input');
		} else {
			if (name_norm !== primary_norm) {
				add_row_tag(row, create_resolve_btn(primary_norm));
			}
			add_row_tag(row, create_copy_btn(primary_norm));
			add_old_tag(row, primary_norm, true);
			if (primary_norm === ens_beautify(primary_norm)) {
				add_row_tag(row, create_pretty_tag());
			}
		}
		output_div.append(row);
		let details_row = create_details_row(primary_norm);
		details_row.classList.toggle('old', !!available);
		output_div.append(details_row);
	}	

	if (primary_norm && name_norm === primary_norm) {
		if (owner === address) {
			add_row_tag(normed_row, create_typed_tag('fire', 'Primary Owner'));
		} else {
			add_row_tag(normed_row, create_typed_tag('good', 'Primary'));
		}
	}
}

function add_owner_links(row, owner) {	
	add_row_tag(row, create_link(`${active_chain.is_mainnet ? 'https://opensea.io/' : 'https://testnets.opensea.io/'}${owner}?tab=collected`, OPENSEA_NAME, 'external'));
	if (active_chain.is_mainnet) {
		add_row_tag(row, create_link(`https://ens.vision/0x/${owner}`, VISION_NAME, 'external'));	
		add_row_tag(row, create_link(`https://rainbow.me/${owner}`, 'Rainbow', 'external'));
	}
	add_row_tag(row, create_link(`https://debank.com/profile/${owner}`, 'Debank', 'external'));
}

async function fetch_records(resolver, is_wildcard) {
	if (!is_wildcard) { 
		if (multicall_contract === null) {
			const MULTICALL3 = '0xcA11bde05977b3631167028862bE2a173976CA11';
			if (await is_contract(MULTICALL3)) {
				multicall_contract = new ethers.Contract(MULTICALL3, [
					`function tryAggregate(bool requireSuccess, tuple(address target, bytes data)[] memory calls) public returns (tuple(bool success, bytes data)[] memory returnData)`
				], active_provider);
			} else {
				multicall_contract = false;
			}
		}
		if (multicall_contract) {
			const target = resolver.address;
			const node = namehash(resolver.name);
			try {
				let res = await multicall_contract.callStatic.tryAggregate(false, RECORDS.map(rec => {
					switch (rec.type) {
						case 'text': return {target, data: ethers.utils.hexConcat([ethers.utils.id('text(bytes32,string)').slice(0, 10), ethers.utils.defaultAbiCoder.encode(['bytes32', 'string'], [node, rec.key])])};
						case 'addr': return {target, data: ethers.utils.hexConcat([ethers.utils.id('addr(bytes32,uint256)').slice(0, 10), ethers.utils.defaultAbiCoder.encode(['bytes32', 'uint256'], [node, rec.coin])])};
						case 'contenthash': return {target, data: ethers.utils.hexConcat([ethers.utils.id('contenthash(bytes32)').slice(0, 10), ethers.utils.defaultAbiCoder.encode(['bytes32'], [node])])};
						default: new Error('bug');
					}
				}));
				return RECORDS.map((rec, i) => {
					let {success, data} = res[i];
					if (!success) return {rec, error: 'eth_call failure'};
					try {
						if (rec.type === 'text') {
							[data] = ethers.utils.defaultAbiCoder.decode(['string'], data);
							if (data) return {rec, data};
						} else {
							[data] = ethers.utils.defaultAbiCoder.decode(['bytes'], data);
							if (data !== '0x') return {rec, data};
						}
					} catch (err) {
						return {rec, error: err.message};
					}
				}).filter(Boolean);
			} catch (err) {				
			}
		}
	}
	return (await Promise.all(RECORDS.map(async rec => {
		try {
			let data = rec.cached ? resolver[rec.cached] : await resolver.getText(rec.key);
			if (data) return {rec, data};
		} catch (err) {
			return {rec, error: err.message};
		}
	}))).filter(Boolean);
}

async function ensure_eth_resolver() {
	if (eth_resolver_contract) return;
	if (eth_resolver_contract === false) throw new Error(`No "eth" resolver`);	
	let resolver = await active_provider.getResolver('eth');
	if (!resolver) {
		eth_resolver_contract = false;
		return ensure_eth_resolver(); 
	}
	eth_resolver_contract = contract_for_resolver(resolver);
}
function contract_for_resolver(resolver) {
	let contract = new ethers.Contract(resolver.address, [
		'function supportsInterface(bytes4 interfaceID) external view returns (bool)',
		'function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address)',
	], active_provider);
	contract.node = namehash(resolver.name);
	contract.get_interface = hash => contract.callStatic.interfaceImplementer(contract.node, hash);
	return contract;
}
function contract_for_controller(address) {
	return new ethers.Contract(address, [
		'function owner() external view returns (address)',
		'function prices() external view returns (address)',
		'function nameWrapper() external view returns (address)',
	], active_provider);
}
function contract_for_price_oracle(address) {
	let contract = new ethers.Contract(address, [
		'function premium(string calldata name, uint256 expires, uint256 duration) external view returns (uint256)',
		'function price(string calldata name, uint256 expires, uint256 duration) external view returns (uint256)',
		'function usdOracle() external view returns (address)',
	], active_provider);
	/*
	totalDays = 21; // FromDigits["15"]
	price0 = 10^(8 + 18) // FromDigits["52b7d2dcc80cd2e4000000", 16]
	price1 = BitShiftRight[price0, totalDays]
	dur = 1814400;  // t /. First@Solve[price0*(1/2)^(t/86400) == price1, t, Reals]
	*/
	contract.premium_period = 21*86400*1000;
	return contract;
}
async function ensure_wrapper() {
	if (wrapper_contract) return;
	if (wrapper_contract === false) throw new Error(`Not implementated`);
	await ensure_eth_resolver();
	let wrapper_address = await eth_resolver_contract.get_interface('0x019a38fe');
	if (is_null_hex(wrapper_address)) {
		wrapper_contract = false;
		return ensure_wrapper();
	}
	wrapper_contract = new ethers.Contract(wrapper_address, [
		'function isWrapped(bytes32 node) public view returns (bool)',
		'function getData(uint256 id) external view returns (address owner, uint32 fuses, uint64 expiry)',
		'function names(bytes32 node) public view returns (bytes)',	
	], active_provider);
}
async function ensure_eth_nft() {
	if (eth_nft_contract) return;
	if (eth_nft_contract === false) throw new Error(`Not implemented`);
	await ensure_eth_resolver();
	let nft_address = await registry_contract.callStatic.owner(eth_resolver_contract.node);
	//let nft_address = await eth_resolver_contract.get_interface(IFACE_ETH_NFT);
	if (is_null_hex(nft_address)) {
		eth_nft_contract = false;
		return ensure_eth_nft();
	}
	eth_nft_contract = new ethers.Contract(nft_address, [
		'function available(uint256 id) external view returns(bool)',
		'function nameExpires(uint256 id) external view returns(uint256)',
		'function ownerOf(uint256 id) external view returns (address)',
		'function GRACE_PERIOD() external view returns (uint256)',
	], active_provider);
	eth_nft_contract.grace_period = (await eth_nft_contract.callStatic.GRACE_PERIOD().then(x => 1000 * x.toNumber()).catch(() => 90*86400*1000));
	eth_nft_contract.warning_period = Math.round(eth_nft_contract.grace_period / 2); // when to show warning in interface
	eth_controller_contract = contract_for_controller(await eth_resolver_contract.get_interface(IFACE_ETH_CONTROLLER));
	price_oracle_contract = contract_for_price_oracle(await eth_controller_contract.callStatic.prices());
}
async function get_safe_primary(owner, alt_owner) {
	// return normalized primary if resolve(reverse(owner)) is owner or alt_owner
	let rev_name = reverse_name(owner);
	let rev_node = namehash(rev_name);
	let rev_resolver = await registry_contract.callStatic.resolver(rev_node);
	if (!rev_resolver || is_null_hex(rev_resolver)) {
		throw new Error('Primary not set');
	}
	let contract = new ethers.Contract(rev_resolver, [
		`function name(bytes32 node) view returns (string)`
	], active_provider);	
	let primary = await contract.callStatic.name(rev_node);
	if (!primary) {
		throw new Error('Primary is Null');
	}
	let name = ens_normalize(primary);
	let resolver = await active_provider.getResolver(name);
	if (!resolver) {
		throw new Error('Resolver not set');
	}
	let address = await resolver.getAddress();
	if (!address || is_null_hex(address)) {
		throw new Error('Address not set');
	}
	if (owner.localeCompare(address, undefined, {sensitivity: 'base'})) {
		if (!alt_owner || alt_owner.localeCompare(address, undefined, {sensitivity: 'base'})) {
			throw new Error(`Address mismatch`);
		}
	}
	return name;
}
async function is_contract(address) {
	if (typeof address !== 'string') return;
	address = address.toLowerCase();
	let is = IS_CONTRACT.get(address);
	if (typeof is === 'boolean') return is;
	try {
		is = !is_null_hex(await active_provider.getCode(address));
		IS_CONTRACT.set(address, is);
		return is;
	} catch (err) {
	}	
}

function is_address_type_error(err) {
	return err.code === 'INVALID_ARGUMENT' && err.argument === 'value' && err.value === '0x';
}
function is_checksum_address(s) {
	try {
		return s === ethers.utils.getAddress(s);
	} catch (ignored) {
	}
}
function is_null_hex(s) {
	return !s || /^0x0*$/.test(s);
}
function labelhash(s) {
	//return ethers.utils.id(s);
	return ethers.utils.keccak256(bytes_from_utf8(s));
}
function namehash(s) {
	const N = 66;
	let hash = '0x'.padEnd(N, '0');
	if (s) hash = s.split('.').reduceRight((h, x) => ethers.utils.keccak256(h + labelhash(x).slice(2)), hash);
	return hash.slice(0, N);
}

function read_local_storage(key, fn, def) {
	let value = localStorage[key];
	if (typeof value === 'string') {
		try {
			return fn(JSON.parse(value));
		} catch (err) {
		}
	}
	if (def !== undefined) {
		fn(def);
	}
}
</script>
</body>
</html>
