<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ENS Resolver</title>
<style>
:root {
	--btn-fill-color: #eee;
	--btn-hover-fill-color: #ccc;
	--btn-border-color: #888;
	--copied-color: #8f8;
	--confusing-color: #d47;
}
.hide {
	display: none !important;
}
.balloon {
	flex: 1;
}
.long {
	white-space: pre-wrap !important;
	word-break: break-word;
}
.force-ltr {
	direction: ltr;
	unicode-bidi: bidi-override;
}
a, button {
	cursor: pointer;
}
button {
	appearance: none;
	margin: 0;
	padding: 4px 8px;
	border: 1px solid var(--btn-border-color);
	border-radius: 4px;
	background-color: var(--btn-fill-color);
	color: #000;
	font-size: 100%;
}
button:disabled {
	opacity: 50%;
	pointer-events: none;
}
button:hover {
	background-color: var(--btn-hover-fill-color);
}
button:hover:active {
	background-color: #aaa;
	/*transform: translate(0px, 1px);*/
}
body { 
	margin: 3rem; 
	background: #eee;
	display: flex;
	flex-direction: column;
	gap: 8px;
	overflow-y: scroll;
}
header {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	gap: 4px 8px;
}
h1 {
	margin: 0;
}
#provider {
	font-size: 11pt;
	font-weight: normal;
	color: #666;
	display: flex;
	flex-direction: column;
	flex-wrap: wrap;
	align-items: start;
	align-self: end;
}
#provider button {
	margin-left: 5px;
	font-size: 9pt;
	padding: 2px 6px;
}
#provider .error {
	background-color: #fcc;
	color: #000;
	padding: 1px 4px;
	border-radius: 4px;
	font-size: 90%;
}
#provider a {
	font-weight: bold;
}
#github {
	flex: 1;
	text-align: right;
	display: flex;
	flex-direction: column;
	gap: 2px;
	order: 2;
	align-items: end;
}
#github a {	
	white-space: pre;
}
body.testnet {
	background: #fef;
}
body.testnet #provider a {
	background: #f3f;
	color: #fff;
	border-radius: 4px;
	padding: 2px 4px;
	margin: -2px 0;
	text-decoration: none;
}
.spinner {
	width: 32px;
	height: 32px;
	box-sizing: border-box;
	animation: spin 2s infinite linear;
	border: 5px solid #000;
	border-bottom-color: transparent;
	border-radius: 100%;
}
@keyframes spin {
	to { transform:rotate(360deg); }
}
#examples {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 4px;
	font-size: 11pt;
	padding-bottom: 6px;
	border-bottom: 2px solid #fff;
}
#examples b {
	font-size: 12pt;
}
#examples button:not([id]) {
	background: #fff;
	padding: 2px 4px;
	border: 2px solid transparent;
	transition: transform 0.1s;
	font-size: 10pt;
}
#examples button:not([id]):hover {
	border-color: #aaa;
	transform: scale(1.5);
}
#examples button:not([id]):hover:active {
	border-color: #000;
}
#examples button.mapped:not([id]) {
	border-color: #ccf;
}
#examples button.error:not([id]) {
	border-color: #fcc;
}
#examples a {
	background-color: #ffc;
}
#examples_btn {
	font-weight: bold;
}
#input {
	display: flex;
	align-items: stretch;
	gap: 8px;
}
#input input {
	box-sizing: border-box;
	width: 100%;
	padding: 8px;
	font-size: 20pt;
}
#actions {
	min-height: 32px; /* spinner */
	display: flex;
	flex-wrap: wrap;
	justify-content: flex-end;
	align-items: stretch;
	gap: 8px;
}
.segmented {
	display: flex;
}
.segmented button:not(:last-child) {
	border-top-right-radius: 0;
	border-bottom-right-radius: 0;
}
.segmented button:not(:first-child) {
	border-left: 0;
	border-top-left-radius: 0;
	border-bottom-left-radius: 0;
}
#options {
	display: flex;
	flex-wrap: wrap;
	align-items: stretch;
	gap: 6px;
}
#options input {
	display: none;
}
#options label {
	display: flex;
	gap: 4px;
	align-items: center;
	padding: 2px 4px;
	border-radius: 4px;
	border: 2px solid #ccc;
	user-select: none;
	color: #666;
	background-color: #fff;
}
#options :disabled + label {
	opacity: 0.5;
}
#options :not(:disabled) + label {
	cursor: pointer;
}
#options :not(:disabled) + label:hover {
	outline: 2px solid #000;
}
#options :checked + label {	
	color: #000;
}
#auto_resolve_check:checked + label {
	border-color: #5c5;
	background: linear-gradient(90deg, #fff, #cfc);
}
#show_details_check:checked + label {
	border-color: #ca4;
	background-color: #edb;
	/* font: 85% monospace; */
	color: #432;
}
#show_components_check:checked + label {
	border-color: #0aa;
	background-color: #cff;
}
#show_records_check:checked + label {
	border-color: #aa0;
	background-color: #ffa;
}
#skip_norm_check:checked + label {
	border-color: #f00;
	background-color: #f00;
	color: #fff;
}
#force_ltr_check:checked + label {	
	border-color: #555;
	background-color: #555;
	color: #fff;
}
#force_mainnet_check:checked + label {
	border-color: #58f;
	background-color: #58f;
	color: #fff;
}
#resolve_btn {
	font-weight: bold;
}
#output {
	display: flex;
	flex-direction: column;
	gap: 8px;
	font-size: 14pt;
}
.row button {
	font-size: 11pt;
}
.row-label {
	order: -10;
	text-align: right;
	font-weight: bold;
	white-space: pre-wrap;
}
.row-label a {	
	color: #000;
}
.row.locked .row-label {
	opacity: 65%;
}
.row.locked .row-label:before {
	content: 'üîíÔ∏è';
}
.row {
	padding: 8px;
	background: #fff;
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 8px;
}
.row.display {
	background: #eff;
}
.row.normalized {
	background: #efe;
	outline: 1px solid #cdc;
}
.row.addr {
	background: #fffff0;
}
.row.dns {
	background:#f5faff; 
}
.row.old {
	opacity: 65%;
}
.row.dns .main {
	border-bottom-style: dotted;
}
.row.dns.invalid {
	background: #fff0f0;	
	outline: 3px dashed #fcc;
}
.row.pretty {
	background: linear-gradient(90deg, #fff, #fff0fc);
}
.row.category {
	background: #ffe;
}
.row.category .row-label {
	color: #654;
}
.row.category + .row.category {
	margin-top: -6px;
}
.formula {
	display: flex;
	flex-wrap: wrap;
	gap: 4px;
}
.formula a {
	padding: 4px;
	cursor: pointer;
	color: #000;
	text-decoration: none;
}
.formula a:hover {
	background: #cff;
}
.formula a sup {
	font-family: monospace;
}
.row .main {
	display: inline;
	font-size: 16pt;
	border-bottom: 2px solid #000;
	line-height: 130%;
}
ul.row {
	margin: 0;
	margin-top: 4px;
	padding: 16px 16px 16px 36px;
	flex-direction: column;
	align-items: start;
	gap: 4px;
}
ul .tokens {
	display: inline-flex;
}
.row.readme {
	background: #ffc;
}
.row.readme code {
	background: #cff;
	padding: 1px;
}
a.internal {
	font-weight: bold;
}
.row.legend {
	background: #fff;
	list-style: disclosure-closed;
}
.row.legend .tokens {
	min-height: 32px;
}
.row.links {
	display: grid;	
	gap: 8px;
	grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
	background: #eff;
	order: 100;
}
a.addr {
	line-break: anywhere;
	font: 85% monospace;
}
span.tags {
	background: #ddd;
	color: #555;
	padding: 4px 8px;
	font-size: 12pt;
	border-radius: 4px;
	/* border: 1px solid #ccc; */
	white-space: pre;
}
button.copy {
	flex: 0 0 auto;
	align-self: center;
	padding: 0;
	border: none;
	width: 28px;
	height: 28px;
	border-radius: 4px;
	background-color: inherit;
	background-position: center;
	background-repeat: no-repeat;
	background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='24' shape-rendering='geometricPrecision' stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' viewBox='0 0 24 24' width='24' style='color:var(--geist-foreground)'%3E%3Cpath d='M6 17C4.89543 17 4 16.1046 4 15V5C4 3.89543 4.89543 3 6 3H13C13.7403 3 14.3866 3.4022 14.7324 4M11 21H18C19.1046 21 20 20.1046 20 19V9C20 7.89543 19.1046 7 18 7H11C9.89543 7 9 7.89543 9 9V19C9 20.1046 9.89543 21 11 21Z'/%3E%3C/svg%3E");
}
button.copy.small {
	width: 20px;
	height: 20px;
	background-size: 18px;
	opacity: 35%;
}
button.copy:hover {
	opacity: 1;
	background-color: var(--copied-color);
}
button.copy.copied {
	opacity: 1;
	background-color: var(--copied-color);
	background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='24' shape-rendering='geometricPrecision' stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' viewBox='0 0 24 24' width='24' style='color:var(--geist-foreground)'%3E%3Cpath d='M20 6L9 17l-5-5'/%3E%3C/svg%3E");
}
.tags.long { order: 30; }
.tags.old {
	background-color: #df8;
	order: 8;
}
.tags.index {
	font: 9pt monospace;
	background-color: unset;
	opacity: 50%;
	user-select: none;
}
.tags.ens { order: 9; }
.tags.metadata { order: 10; }
.tags.external { order: 11; font-size: 80%; }
.tags.invalid { color: #f00; }
.tags.elapsed {
	background: #f0f0f0;
	font: 9pt sans-serif;
	order: 50;
}
.tags.confusing {
	color: #fff;
	background-color: var(--confusing-color);
	text-align: center;
}
.normalized .confusing {
	margin: -8px 0;
	font-size: 75%;
}
.tags.normalized { background: #8f8; }
.tags.normalized.ascii {
	background: #00f;
	color: #fff;
	font: 11pt monospace;
}
.tags.length {
	background: #f8eedd;	
}
.tags.length:after {
	content: 'ch';
	padding-left: 1px;
	font-size: 70%;
}
.tags.bytes {
	background-color: #e8e8e8;
}
.tags.bytes:after {
	content: 'bytes';
	padding-left: 1px;
	font-size: 70%;
}
.tags.iface {
	display: flex;
	align-items: center;
	gap: 4px;
	text-decoration: none;
	background-color: #dde;
	padding: 4px 8px;
	border-radius: 4px;
	white-space: pre;
	color: #000;
}
.tags.iface:hover {
	outline: 2px solid #00f;
}
.tags.iface code {
	font-size: 13px;
	color: #666;
}
.tags.iface code.prefix {
	color: #00f;
}
.tags.good {
	color: #060;
	background: #cfc;
}
.tags.fire {
	color: #000;
	background: #fdb;
}
.tags.note {
	background: #ffc;
}
.tags.reg {
	background-color: #def;
}
.tags.attn {
	background: #fff0dd;
}
.tags.fail {
	background: #fcc;
	color: #600;
}
.tags.type {
	background: #cff;
}
.tags.emoji {
	background-color: #fe0;
}
.tags.special {
	background: #f84;
	border: none;
	color: #fff;
}
.tags.clean {
	background: none;
	border: none;
	padding: 0;
	font-size: 110%;
	order: 7;
}
.tags.white {
	color: #000;
	background: #fff;
}
.jazz {
	order: -9;
	width: 1.2rem;
	height: 1.2rem;
	border-radius: 4px;
	display: flex;
	align-items: center;
	justify-content: center;
	color: #fff;
	font: bold 12px monospace;
}
.jazz.addr1 { background-color: #66f; }
.jazz.addr2 { background-color: #c4c; }
.jazz.addr3 { background-color: #0a8; }
.jazz.addr4 { background-color: #0a8; }
.avatar {
	order: -1;
} 
.avatar img {
	position: relative;
	z-index: 1;
	display: block;
	border-radius: 4px;
	width: 32px;
	height: 32px;
	transition: transform 0.2s;
}
.avatar img:hover {
	transform: scale(3);
}
button.glow {
	border: 2px solid #2c2;
}
.breakdown {
	font-size: 12pt;
}
.breakdown.reverse > * + * {
	margin-top: 4px;
	border-top: 2px solid #fff;	
	padding-top: 4px;
}
.breakdown .tags {
	padding: 2px 4px;
	border-radius: 4px;
	border: 1px solid #fff;
}
.breakdown .hash {
	display: flex;
	gap: 4px;
	align-items: center;
	justify-content: center;
}
.breakdown .hash code {
	font-size: 90%;
}
.breakdown .hash :first-child {
	white-space: pre;
}
.breakdown .hash a {
	font-weight: bold;
	color: #000;
	text-decoration: none;
}
.breakdown .hash a:hover {
	text-decoration: underline;
}
.breakdown .hash.minor {
	font-size: 90%;
	color: #666;
}
.breakdown .label {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	justify-content: center;
	gap: 4px 8px;
	margin: 2px 0;
	border-top: 2px solid #fff;
	padding: 3px 6px;
	border-bottom: 1px dotted #aaa;
}
.breakdown .label.valid {
	background: linear-gradient(90deg, #efea, #0000);
}
.breakdown .label.error {
	background: linear-gradient(90deg, #fcca, #0000);
}
.breakdown .label.mapped {
	background: linear-gradient(90deg, #ccf6, #0000);
}
.breakdown .name {
	margin: 0 4px;
	border: 1px solid #aaa;
	border-radius: 4px;
	padding: 1px 4px;
	font: 13pt monospace;	
  	color: #000;
}
.breakdown .restricted {
	text-decoration: none;
	background-color: #fcf;
	color: #000;
}
.breakdown .restricted:hover {
	outline: 2px solid #00f;
}
.breakdown .error {
	order: 1;
}
.tokens {
	font-size: 16pt;
}
.exploded > .error {
	background-color: #f97;
	padding: 3px;
	border-radius: 5px;
}
.exploded > .error.first {
	background: #f77;
}
.row.records {
	background-color: #ffc;
}
.record {
	display: flex;
	color: #000;
	font-size: 90%;
	text-decoration: none;
	align-items: center;
	background: #fff;
	padding: 4px 8px;
	border-radius: 4px;
	border: 1px solid #ccc;
	gap: 4px;
}
.record button {
	white-space: pre;
}
.record.rtrim {
	padding-right: 4px;
}
.record.copied {
	background-color: var(--copied-color);
}
.record b {
	font: 11px sans-serif;
	color: #666;
}
.record:not([href]):hover {
	border-color: #000;
}
.record[href]:hover {
	border: 2px solid #00f;
	margin: -1px;
}
.record img,
.record svg {
	width: 18px;
	height: auto;
}
.record span.addr {
	font: 80% monospace;
}
.row.error {
	background: #fcc;
	outline: 3px dashed #d00;
	border-radius: 0;
}
.row.contract:not(.error) {
	background-color: #fffcf6;
	outline: 2px dashed #cc0;
}
.row.contract {
	position: relative;
}
.row.contract::before {
	position: absolute;
	top: 3px;
	right: 6px;
	content: 'Contract';
	font: 11px monospace;
	color: #999;
}
.transform {
	background: #fffaf0;
}
#recent_select {
	outline: none;
	width: 37px;
	padding: 0;
	margin: 0;
	border: 1px solid var(--btn-border-color);
	border-radius: 4px;
	cursor: pointer;
	font-size: 100%;
	appearance: none;
	background: no-repeat center url("data:image/svg+xml,%3Csvg height='21' width='20' version='1.1' viewBox='0 0 20 21' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10.5,0 C7,0 3.9,1.9 2.3,4.8 L0,2.5 L0,9 L6.5,9 L3.7,6.2 C5,3.7 7.5,2 10.5,2 C14.6,2 18,5.4 18,9.5 C18,13.6 14.6,17 10.5,17 C7.2,17 4.5,14.9 3.4,12 L1.3,12 C2.4,16 6.1,19 10.5,19 C15.8,19 20,14.7 20,9.5 C20,4.3 15.7,0 10.5,0 L10.5,0 Z M9,5 L9,10.1 L13.7,12.9 L14.5,11.6 L10.5,9.2 L10.5,5 L9,5 L9,5 Z'/%3E%3C/svg%3E"), no-repeat bottom 3px right 2px url("data:image/svg+xml,%3Csvg style='fill: currentColor' width='8' height='4' viewBox='0 0 8 4' version='1.1' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h8l-4 4Z' /%3E%3C/svg%3E") var(--btn-fill-color);
}
#recent_select:hover,
#recent_select:active {
	background-color: var(--btn-hover-fill-color);
}
footer {
	margin: 16px 0;
	text-align: center;
	color: #666;
}
footer span {
	cursor: help;
}
footer span:hover {	
	color: #000;
}
@media only screen and (max-width: 800px) { 
	body {
		margin: 0;
	}
	button {
		font-size: 100%;
	}
	header {
		margin: 16px;
		margin-bottom: 0;
	}
	#provider {
		order: 3;
		flex-direction: row;
		align-items: center;
		gap: 4px;
		width: 100%;
	}
	#input input {
		font-size: 20pt;
	}
	#input, #actions, #options, #examples {
		margin: 0 16px;
	}
	#content {
		font-size: 12pt;
	}
	a.wide {
		font-size: 95%;
	}
	.row {
		justify-content: center;
	}
	.breakdown .hash {
		padding-left: 8px;
		padding-right: 8px;
	}
	#examples_btn {
		display: block;
		width: 100%;
		margin-bottom: 4px;
		font-size: 14pt;
		padding: 4px;
	}
	#output {
		font-size: 13pt;
	}
}
@media only screen and (max-width: 400px) { 
	h1 a {
		display: none;
	}
}
</style>
</head>
<body>
<header>
	<h1><a href="https://ens.domains/">ENS</a> Resolver</h1>
	<div id="provider"></div>
	<div id="github">
		<a href="https://github.com/adraffy/ens-normalize.js">adraffy/ens-normalize.js</a>
		<a href="https://docs.ens.domains/ens-improvement-proposals/ensip-15-normalization-standard"><b>ENSIP-15</b></a>
	</div>
</header>
<div id="examples" class="hide">
<button>vitalik.eth</button>
<button>nIcK.eTh</button>
<button>brantly.cash</button>
<button>üè¥‚Äç‚ò†.art</button>
<button>..a..eth</button>
<button>√∂bb</button>
<button>√ñbb</button>
<button data-name="‚óåÃàbb">‚óåÃàbb</button>

<a href="https://adraffy.github.io/punycode.js/test/demo.html"><b>Punycode:</b></a>
<button>xn--ls8h</button>
<button>xn--üí©</button>
<button>üí∑pound</button>

<a href="https://github.com/ensdomains/ens-contracts/tree/master/contracts/wrapper#namewrapper-docs"><b>Wrapper:</b></a>
<button data-name="firstwrappedname">Emanicpated 2LD</button>
<button data-name="please.pumpdeezbags.eth">Emanicpated 3LD</button>
<button data-name="dessert3.menu.bestsushi7.eth">Wrapped</button>
<button data-name="loyal-eth-community">Locked</button>

<b>Subdomain:</b>
<button data-name="nowzad.loopring.eth">loopring</button>
<button data-name="239.chonksociety.eth">Chonk #239</button>
<button>raffy.antistupid.com</button>

<a href="https://docs.ens.domains/ens-improvement-proposals/ensip-10-wildcard-resolution"><b>Wildcard:</b></a>
<button>moo331.nft-owner.eth</button>
<button>üíé.gmcafe.eth</button>
<button>1.offchainexample.eth</button>
<button>barmstrong.cb.id</button>

<!--
<a href="./display.html"><b>Display:</b></a>
<button>ADRaffy</button>
-->

<b>Address:</b>
<button data-name="0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045">d8dA..6045</button>

<b>Contract:</b>
<button data-name="eth-usd.data.eth">Chainlink ETH-USD</button>

<b>Preimage:</b>
<button data-delay="1000" data-name="token:91842011529764390124322931916134555051359118325819011691525342013207339157209">Token#</button>
<button data-delay="1000" data-name="https://opensea.io/assets/ethereum/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209">OpenSea</button>
<button data-delay="1000" data-name="https://www.gem.xyz/asset/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209">Gem</button>

<a href="./chars.html"><b>Mapped:</b></a>
<button data-name="hyph{2D}{2010}{2011}{2012}{2013}{2014}{2015}{2043}{2212}{23AF}{23E4}{FE58}e{2E3A}n{2E3B}s">Hyphens</button>
<button>A.‚Ñ¢Ô∏è.–Æ</button>
<button>‚Öß</button>
<button>‚®å</button>

<b>Ignored:</b> 
<button data-name="{FE0E}{FE0F}">Emoji Style</button>

<b>Disallowed:</b>
<button data-name="{26}{3000}{E0061}{FFFFFF}{200D}">Types</button>
<button data-name="test .te st. test">Whitespace</button>
<button data-name="{3002}.{FF0E}.{FF61}">Alt Stops</button>
<button data-name="y{303}.{1EF9}">Invalid NFC</button>
<button data-name="{DF00}">Surrogate</button>
<button data-name="[ba967c160905ade030f84952644a963994eeaed3881a6b8a4e9c8cbe452ad7a2].eth" data-skip="1">"üí©.eth"</button>

<b>Deviation:</b> 
<button>√ü</button>
<button>·∫û</button>
<button>œÇ</button>

<b>Complex:</b>
<button data-name="_1{FE0F}E{FE0E}{303}{AD}{1F4A9}{24C2}{FE0E}{2E3B}a{301}"></button>

<b>Combining Marks:</b>
<button data-name="{300}">Leading</button>
<button data-name="üí©{300}">Emoji</button>
<button data-name="x{300}{300}">Whitelisted</button>
<button data-name="{622}{64D}{64E}.{929}{901}{902}">NFD w/CM</button>

<b>NSM:</b>
<button data-name="{625}{610}{610}">Repeated</button>
<button data-name="{625}{610}{611}{612}{613}{614}">Too Many</button>

<a href="https://unicode.org/reports/tr46/#Validity_Criteria"><b>CheckHyphen:</b></a>
<button>-test.test-.t-e--s---t</button>
<button>te--st</button>

<b>Underscore:</b>
<button>__ab</button>
<button>a_b</button>

<a href="./emoji.html"><b>Emoji:</b></a>
<button>¬©</button>
<button>üïµ</button>
<button>üßô‚Äç‚ôÇ</button>
<button>üèãüèø‚Äç‚ôÇ</button>
<button data-name="üí©üí©üí©">üí©<sup>3</sup></button>
<button data-name="üçûüçûüçûüçûüçûüçûüçûüçûüçûüçûüçûüçûüçû">üçû<sup>13</sup></button>
<button data-name="üëÅüó®üëÅÔ∏è‚Äçüó®Ô∏è">üëÅÔ∏è‚Äçüó®Ô∏è</button>
<button data-name="üßüüßü‚ôÇüßü‚Äç‚ôÇ">üßü</button>
<button>üòµ‚Äçüí´üòµ‚Äçüí´üòµ‚Äçüí´</button>
<button>üòµüí´üòµüí´üòµüí´</button>
<button>üë©‚Äç‚öïüë©üèΩ‚Äç‚öïÔ∏è</button>
<button>üë™üë®‚Äçüë©‚Äçüë¶</button>
<button data-name="üö¥Ô∏èüöµÔ∏èüö¥üèªüö¥üèºüö¥üèΩüö¥üèæüö¥üèøüöµüèªüöµüèºüöµüèΩüöµüèæüöµüèøüö¥‚Äç‚ôÄÔ∏èüö¥‚Äç‚ôÇÔ∏èüöµ‚Äç‚ôÄÔ∏èüöµ‚Äç‚ôÇÔ∏èüö¥üèª‚Äç‚ôÄÔ∏èüö¥üèª‚Äç‚ôÇÔ∏èüö¥üèº‚Äç‚ôÄÔ∏èüö¥üèº‚Äç‚ôÇÔ∏èüö¥üèΩ‚Äç‚ôÄÔ∏èüö¥üèΩ‚Äç‚ôÇÔ∏èüö¥üèæ‚Äç‚ôÄÔ∏èüö¥üèæ‚Äç‚ôÇÔ∏èüö¥üèø‚Äç‚ôÄÔ∏èüö¥üèø‚Äç‚ôÇÔ∏èüöµüèª‚Äç‚ôÄÔ∏èüöµüèª‚Äç‚ôÇÔ∏èüöµüèº‚Äç‚ôÄÔ∏èüöµüèº‚Äç‚ôÇÔ∏èüöµüèΩ‚Äç‚ôÄÔ∏èüöµüèΩ‚Äç‚ôÇÔ∏èüöµüèæ‚Äç‚ôÄÔ∏èüöµüèæ‚Äç‚ôÇÔ∏èüöµüèø‚Äç‚ôÄÔ∏èüöµüèø‚Äç‚ôÇÔ∏è">üö¥Ô∏è Bikes (36)</button>
<button data-name="ü¶∞ü¶±ü¶≤ü¶≥">ü¶∞</button>
<button>üë®‚Äçüë©‚Äçüë¶üèø</button>
<button data-name="{1F3FB}{1F3FC}{1F3FD}{1F3FE}{1F3FF}">üèª</button>
<button data-name="üí©{200D}üí©">üí©+üí©</button>
<button data-name="{261D}{FE0F}{1F3FB}"></button>
<button>‚ÄºÔ∏è</button>
<button>‚ÅâÔ∏è</button>
<button data-name="‚Ñ¢‚Ñπ‚ìÇ„äó„äôüàÅüàÇüàöüàØüà≤üà≥üà¥üàµüà∂üà∑üà∏üàπüà∫üâêüâë">‚òπÔ∏è Demoted</button>

<b>Non-RGI:</b>
<button>üê±‚Äçüêâ</button>
<button>üë™üèª</button>
<button>ü§ºüèª‚Äç‚ôÄÔ∏è</button>
<button data-name="{1F469}{1F3FE}{200D}{1F91D}{200D}{1F469}{1F3FE}">Mod+Mod</button>

<b>Regional:</b>
<button>üá¶</button>
<button>üá¶üá¶</button>
<button>üá∫üá∏üá∫üá≤</button>

<b>Flag:</b>
<button>üè¥</button>
<button>üèÅÔ∏è</button>
<button>üè≥Ô∏è‚Äçüåà</button>

<a href="https://www.unicode.org/reports/tr51/#DisplayValidEmojiTagSeqs"><b>Tag:</b></a>
<button>{1F3F4}{E0067}{E0062}{E0065}{E006E}{E0067}{E007F}</button>
<button>{1F3F4}{E0067}{E0062}{E0073}{E0063}{E0074}{E007F}</button>
<button>{1F3F4}{E0067}{E0062}{E0077}{E006C}{E0073}{E007F}</button>
<button data-name="{1F3F4}{E0075}{E0073}{E0063}{E0061}{E007F}">usca</button>

<b>Circled/Squared:</b>
<button>i{2139}{2139}{FE0F}üõà</button>
<button data-name="‚í∂‚í∑‚í∏‚íπ‚í∫‚íª‚íº‚íΩ‚íæ‚íø‚ìÄ‚ìÅ‚ìÇ‚ìÉ‚ìÑ‚ìÖ‚ìÜ‚ìá‚ìà‚ìâ‚ìä‚ìã‚ìå‚ìç‚ìé‚ìè">‚í∂-‚ìè</button>
<button data-name="‚ìê‚ìë‚ìí‚ìì‚ìî‚ìï‚ìñ‚ìó‚ìò‚ìô‚ìö‚ìõ‚ìú‚ìù‚ìû‚ìü‚ì†‚ì°‚ì¢‚ì£‚ì§‚ì•‚ì¶‚ìß‚ì®‚ì©">‚ìê-‚ì©</button>
<button data-name="‚ì™‚ë†‚ë°‚ë¢‚ë£‚ë§‚ë•‚ë¶‚ëß‚ë®‚ë©‚ë™‚ë´‚ë¨‚ë≠‚ëÆ‚ëØ‚ë∞‚ë±‚ë≤‚ë≥„âë„âí„âì„âî„âï„âñ„âó„âò„âô„âö„âõ„âú„âù„âû„âü">‚ì™-„âü</button>
<button data-name="üÖ∞üÖ±üÖ≤üÖ≥üÖ¥üÖµüÖ∂üÖ∑üÖ∏üÖπüÖ∫üÖªüÖºüÖΩüÖæüÖøüÜÄüÜÅüÜÇüÜÉüÜÑüÜÖüÜÜüÜáüÜàüÜâ">üÖ∞-üÜâ</button>
<button data-name="üÖêüÖëüÖíüÖìüÖîüÖïüÖñüÖóüÖòüÖôüÖöüÖõüÖúüÖùüÖûüÖüüÖ†üÖ°üÖ¢üÖ£üÖ§üÖ•üÖ¶üÖßüÖ®üÖ©">üÖê-üÖ©</button>
<button data-name="‚ìø‚ù∂‚ù∑‚ù∏‚ùπ‚ù∫‚ùª‚ùº‚ùΩ‚ùæ‚ùø‚ì´‚ì¨‚ì≠‚ìÆ‚ìØ‚ì∞‚ì±‚ì≤‚ì≥‚ì¥">‚ìø-‚ùø</button>
<button data-name="üÑå‚ûä‚ûã‚ûå‚ûç‚ûé‚ûè‚ûê‚ûë‚ûí‚ûì">üÑå-‚ûì</button>
<button data-name="„âà„ââ„âä„âã„âå„âç„âé„âè">„âà-„âè</button>

<a href="https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.1"><b>ContextJ:</b></a>
ZWNJ:
<button data-name="‡¥®‡µç{200C}‡¥Æ"></button>
<button data-name="ŸÜ€åŸÖ‚ÄåŸÅÿßÿµŸÑŸá"></button>
<button data-name="a{200C}b"></button>

ZWJ:
<button data-name="‡¥£‡µç‚Äç"></button>
<button data-name="a{200D}b"></button>

<a href="https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.3"><b>ContextO:</b></a>
Middle Dot: 
<button data-name="{6C}{B7}{6C}"></button>

Katakana Dot:
<button data-name="Êúà„ÉªÊ∞¥"></button>
<button data-name="a„Éªa{300}"></button>

Greek Keraia: 
<button data-name="{375}Œ±"></button>

Hebrew Geresh:
<button data-name="{5D1}{5F3}"></button>

<a href="https://www.rfc-editor.org/rfc/rfc5893.html#section-2"><b>CheckBidi:</b></a>
<button>◊§◊¢◊ô◊ú◊ï◊™◊î◊ë◊ô◊†◊ê◊ï◊ù</button>
<button data-name="{0786}{07AE}{0782}{07B0}{0795}{07A9}{0793}{07A6}{0783}{07AA}">Dhivehi</button>
<button data-name="{05D9}{05B4}{05D5}{05D0}{05B8}">Yiddish</button>
<button data-name="{1F1F8}{1F1E6}{633}{644}{645}{627}{646}">Emoji+RTL</button>
<button data-name="{633}{644}{645}{627}{646}{1F1F8}{1F1E6}">RTL+Emoji</button>
<button data-name="bahrain.ŸÖÿµÿ±">LTR.RTL</button>
<button data-name="bahrainŸÖÿµÿ±">LTR+RTL in Label</button>
<button data-name="{202e}elgoog{202d}.eth">.ethgoogle</button>
<button data-name="{202e}hte.elgoog">google.eth</button>

<b>Keycaps:</b>
<button>1‚É£2Ô∏è‚É£üîü.eth</button>
<button data-name="0Ô∏è‚É£1Ô∏è‚É£2Ô∏è‚É£3Ô∏è‚É£4Ô∏è‚É£5Ô∏è‚É£6Ô∏è‚É£7Ô∏è‚É£8Ô∏è‚É£9Ô∏è‚É£üîü*Ô∏è‚É£#Ô∏è‚É£">*Ô∏è‚É£-üîü</button>

<a href="https://unicode-org.github.io/cldr-staging/charts/latest/by_type/core_data.alphabetic_information.main.html">Exemplars</a> /
<a href="https://util.unicode.org/UnicodeJsps/confusables.jsp"><b>Confusables:</b></a>
<button>aŒ±.…ë</button>
<button>‡Æ∂‡Øç‡Æ∞‡ØÄ.‡Æ∏‡Øç‡Æ∞‡ØÄ</button>
<button data-name="i.i{307}.{131}{307}">iÃá</button>
<button data-name="{E8}.e{300}.{450}.{435}{300}">√®</button>

<b>Mixed-Script:</b>
<button data-name="0a„Äá.Èªëa8">Digit+Latin+Han</button>
<button data-name="„ÅÇ„Ç¢„ÅÑ„Ç§„ÅÜ„Ç¶„Åà„Ç®„Åä„Ç™">Kana+Hira</button>
<button data-name="bitcoin.bitcŒøin.biÃátcoin.bit—Åoin">"bitcoin"</button>
<button>„Ç°Ìû£</button>

<b>Whole-Script:</b>
<button data-name="0x.0œá.0—Ö">"0x"</button>
<button data-name="apple.–¥—Ä—Ä”è–µ.–∞—Ä—Ä”è–µ.a—Ä—Ä”è–µ">"apple"</button>
<button data-name="ŒπŒøœÉœÅŒ≤œÖŒΩŒ≥">Greek</button>
<button data-name="o.Ÿ•.‡•¶.‡±¶.‡©¶.‡µ¶.Œø.÷Ö">"o"</button>
<button data-name="„ÅÇ„Éº.„Äá‰∏Ä.‰∏Ä„Éº.‰∏Ä.„Éº.·Ö≥">CJK Dash</button>

<a href="https://unicode.org/emoji/charts/emoji-released.html"><b>Unicode 15.0:</b></a>
<button data-name="{1F6DC}{1FA75}{1FA76}{1FA77}{1FA87}{1FA88}{1FAAD}{1FAAE}{1FAAF}{1FABB}{1FABC}{1FABD}{1FABF}{1FACE}{1FACF}{1FADA}{1FADB}{1FAE8}{1FAF7}{1FAF8}">Single Emoji (20)</button>
<button data-name="{1FAF7}{1F3FB}{1FAF7}{1F3FC}{1FAF7}{1F3FD}{1FAF7}{1F3FE}{1FAF7}{1F3FF}{1FAF8}{1F3FB}{1FAF8}{1F3FC}{1FAF8}{1F3FD}{1FAF8}{1F3FE}{1FAF8}{1F3FF}">Sequences (10)</button>
<button data-name="{1F426}{200D}{2B1B}">Black Bird</button>

<a href="https://unicode.org/reports/tr51/proposed.html"><b>Unicode 15.1:</b></a>
<button>‚â†.‚âÆ.‚âØ</button>
<button data-name="{26D3}{200D}{1F4A5}.{1F344}{200D}{1F7EB}.{1F34B}{200D}{1F7E9}.{1F426}{200D}{1F525}.{1F642}{200D}{2194}.{1F642}{200D}{2195}.{1F9D1}{200D}{1F9D2}.{1F9D1}{200D}{1F9D1}{200D}{1F9D2}.{1F9D1}{200D}{1F9D2}{200D}{1F9D2}.{1F9D1}{200D}{1F9D1}{200D}{1F9D2}{200D}{1F9D2}">ZWJ Sequences (10)</button>
<button data-name="{1F3C3}{1F3FB}{200D}{27A1}.{1F3C3}{1F3FB}{200D}{27A1}.{1F3C3}{1F3FC}{200D}{27A1}.{1F3C3}{1F3FD}{200D}{27A1}.{1F3C3}{1F3FE}{200D}{27A1}.{1F3C3}{1F3FF}{200D}{27A1}">Directional (108)</button>

<b>Fenced:</b>
<button>O'Brian</button>
<button data-name="¬º¬Ω¬æ‚Öê‚Öë‚Öí‚Öì‚Öî‚Öï‚Öñ‚Öó‚Öò‚Öô‚Öö‚Öõ‚Öú‚Öù‚Öû‚Öü‚Üâ">"¬Ω"</button>
<button>123‚ÅÑ456‚Äôs</button>
<button data-name="a'.‚Äôz.a'‚Äôb.a‚ÅÑ'.‚ÅÑa">Invalid</button>

<b>Misc:</b>
<button data-name="$¬¢¬£¬§¬•‚Ç°‚Ç¶‚Ç©‚Ç™‚Ç´‚Ç¨‚Ç≠‚ÇÆ‚Ç±‚Ç≤‚Ç¥‚Çµ‚Ç∏‚Çπ‚Ç∫‚Çº‚ÇΩ‚Çæ‚ÉÄ‚ÇøŒû.ÿã">Currency</button>
<button data-name="‚Ä¢-‚Ä¢¬¨.‚åê‚ó®-‚ó®.‚åê„Äá-„Äá¬¨">Glasses</button>
<button>360¬∞</button>
<button data-name="2œÄr.4œÄŒ∏.8–ø">"œÄ"</button>
<button>Œû.‚â°.‚ò∞</button>
<button>‚ô¢‚ü†‚ß´</button>
<button data-name="_‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà">‚ñÉ‚ñÖ‚ñá</button>
<button data-name="‚úì.‚úîÔ∏é.‚úîÔ∏è.‚úÖÔ∏è.‚òëÔ∏è">Checks</button>
<button data-name="·¥Ä ô·¥Ñ·¥Ö·¥áÍú∞…¢ ú…™·¥ä·¥ã ü·¥ç…¥·¥è·¥òÍûØ ÄÍú±·¥õ·¥ú·¥†·¥°x è·¥¢">Íú±·¥ç·¥Ä ü ü ·¥Ñ·¥Ä·¥òÍú±</button>
<button data-name="z éx ç ån ás…πbdou…ØÍûÅ û≈øÃ£·¥â…•·µ∑…ü«ùp‚ÜÑq…ê">p«ùu…πn á</button>
<button data-name="üí©ƒÖ√ßƒô≈ü√¨√≠√Æ√Ø«ê≈Ç">Rare Latin</button>

<b>Pure:</b>
Arabic:
<button>ÿ•ŸÜÿ™ÿ±ŸÜÿ™</button>
<button data-name="{660}{661}{662}{663}{664}{665}{666}{667}{668}{669}.{6F0}{6F1}{6F2}{6F3}{6F4}{6F5}{6F6}{6F7}{6F8}{6F9}.{6F0}{780}">Digits</button>
Hebrew:
<button>◊©◊ô◊®◊ï◊™÷æ◊©◊û◊ï◊™</button>

<a href="https://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers"><b>Restricted:</b></a>
<button data-name="ìÄÄìÄÅìÄÇ">Egyptian Hieroglyphs</button>
<button data-name="êå±êåªêçâêåºêå∞">Gothic</button>
<button>ìÜè‚û°üê∏Ô∏è</button>
<button data-name="aìÄÇ">Mixed</button>
<button>·èé·èÆ·èÇ·é•.eth</button>

<a href="https://adraffy.github.io/ens-norm-tests/test-compare/output/ens_normalize.git_1.9.0_vs_eth-ens-namehash_2.0.15.html#diff-norm"><b>Different Norm:</b></a>
<button data-name="‚Äë888">Remapped Hyphen</button>
<button data-name="€∞€±€≤€≥€∑€∏€π">Mapped Arabic</button>

</div>
<div id="options">
	<button id="examples_btn">üëÄ Examples</button>
	<input type="checkbox" id="auto_resolve_check" checked>
	<label for="auto_resolve_check"><svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" style="color:var(--geist-foreground);width:20px;height:20px"><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/></svg> <i>on Input</i></label>
	<input type="checkbox" id="show_details_check">
	<label for="show_details_check">Details</label>
	<input type="checkbox" id="show_components_check" checked>
	<label for="show_components_check">Emoji Components</label>
	<input type="checkbox" id="show_records_check" checked>
	<label for="show_records_check" title="Include common text and address records">Records</label>
	<input type="checkbox" id="skip_norm_check">
	<label for="skip_norm_check"  title="When active, normalization is not applied"><svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" style="color:var(--geist-foreground);width:20px;height:20px"><circle cx="12" cy="12" r="10" fill="var(--geist-fill)"></circle><path d="M15 9L9 15" stroke="var(--geist-stroke)" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path><path d="M9 9L15 15" stroke="var(--geist-stroke)" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path></svg>Norm</label>
	<input type="checkbox" id="force_mainnet_check">
	<label for="force_mainnet_check" title="Use mainnet regardless of selected browser provider network"><svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" style="color:var(--geist-foreground);width:20px;height:20px"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0110 0v4"/></svg> Mainnet</label>
	<input type="checkbox" id="force_ltr_check">
	<label for="force_ltr_check" title="Override Bidi Handling with Left-to-Right Direction&#10;(Applies only to Input)">LTR!</label>
</div>
<div id="input">
	<input id="input_field" size="20" placeholder="Name or Address or URL">
	<select id="recent_select" title="Recent Names" class="hide">
		<option value="reset">üóëÔ∏è Clear History</option>
		<optgroup label="Recent Names"></optgroup>
	</select>
</div>
<div id="actions">
	<div class="spinner"></div>
	<div class="balloon"></div>
	<div class="segmented">
		<button id="random_emoji_btn" title="Random Emoji&#10;[ALT] Only Use Singles">üé≤</button>
		<button id="find_emoji_btn">Emoji</button>
	</div>
	<div class="segmented">
		<button id="chars_btn" title="Lookup First/Selected Character">Chars</button>
		<button id="confused_btn" title="Explain Confusable Characters">Confused</button>
	</div>
	<div class="segmented">
		<button id="nf_btn">NFD‚ÜîNFC</button>
		<button id="escape_btn" title="[ALT] Unicode Escaped">Escape</button>
	</div>
	<button id="parent_btn" title="Drop the leading label">Parent</button>
	<button id="copy_link_btn">Copy Link</button>
	<button id="resolve_btn">Resolve</button>
</div>
<div id="output">
<ul class="row readme">
<li>Click an <button data-name="üëÅÔ∏è‚Äçüó®Ô∏èA{303}.Eth">Example</button> to see how it works.</li>
<li><code>token:__</code> lookup the <a href="../../keccak.js/test/demo.html#algo=keccak-256&s=raffy&escape=1&encoding=utf8">labelhash</a> (if known) <button data-name="token:91842011529764390124322931916134555051359118325819011691525342013207339157209" data-delay="1000">raffy.eth</button> or <a href="../../ens-labels/demo.html">search for it</a>.</li>
<li><code>wrapped:__</code> lookup the <a href="../../keccak.js/test/demo.html#algo=namehash&s=firstwrappedname.eth&escape=1&encoding=utf8">namehash</a> (if wrapped) <button data-name="wrapped:0xc44eec7fb870ae46d4ef4392d33fbbbdc164e7817a86289a1fe30e5f4d98ae85" data-delay="1000">firstwrappedname.eth</button></li>
<li>Use <code>{FF}</code> or <code>[255]</code> to include codepoints <button data-raw data-name="a{61}[97].eth">aaa</button></li>
<li><code>\uFFFF</code>, <code>\u{HEX}</code>, <code>&amp;#xFF;</code>, <code>&amp;#255;</code>, or <code>&amp;entity;</code> are shorthand for <code>{HEX}</code>.</li>
<li><code>HEX<sub>1</sub> HEX<sub>2</sub></code> is shorthand for <code>{HEX<sub>1</sub>}{HEX<sub>2</sub>}</code> <button data-name="65 74 68" data-meta data-delay="1000">eth</button></li>
<li><code>range:HEX<sub>1</sub>..HEX<sub>n</sub></code> expands to a range of characters <button data-name="range:61..7A" data-delay="1000">ASCII a-z</button></li>
<li><button id="copy_example_btn">Copy Link</button></a> to get a URL that resolves on page-load.</li>
<li>Many elements have tooltips with additional information.</li>
<li>Follows <a class="internal" href="https://docs.ens.domains/ens-improvement-proposals/ensip-15-normalization-standard">ENSIP-15</a> and <a href="https://docs.ens.domains/terminology">ENS Terminology</a>.</li>
<li class="req-window">Supports <button id="add_goerli_btn" class="chain">Goerli</button> and <button id="add_sepolia_btn" class="chain">Sepolia</button> testnets.</li>
</ul>
<ul class="row legend">
<li>This is a <b>valid</b> sequence of characters: <span data-tokenize="abc"></span> and <b>.eth</b> name: <span data-tokenize="abc.eth"></span></li>
<li>This is an <b>emoji</b>: <span data-tokenize="üë©üèΩ‚Äç‚öïÔ∏è"></span> and its corresponding <b>components</b>: <span data-tokenize="üë©üèΩ‚Äç‚öïÔ∏è" data-parts="1"></span></li>
<li>This is a <b>mapped</b> token: <span data-tokenize="‚Ñ¢"></span> which transforms into a <b>valid</b> sequence: <span data-tokenize="tm"></span></li>
<li>Characters not in canonical form require <b>NFC</b>: <span data-tokenize="a{303}"></span></li>
<li>These are <b>ignored</b> characters: <span data-tokenize="{AD}{FE0F}{E0100}"></span></li>
<li>These are <b>disallowed</b> characters: <span data-tokenize="#{00}{1FFFFF}{E0061}{200D}"></span></li>
</ul>
<ul class="row links">
<li><a class="internal" href="./emoji.html">Supported Emoji</a></li>
<li><a class="internal" href="./chars.html">Characters Viewer</a></li>
<li><a class="internal" href="./confused.html">Confused Explainer</a></li>
<li><a class="internal" href="./validate.html">Validation Test</a></li>
<li><a class="internal" href="./report-nf.html">Unicode NormalizationTest</a></li>
<li><a href="../../ens-norm-tests/test-breakdown/output-20230226/">ENSIP-1‚Üí15 Breakdown</a></li>
<li><a href="https://github.com/ensdomains/ens-contracts/tree/staging/deployments/">ENS Deployments</a></li>
<li><a href="../../ens-labels/demo.html">Labelhash‚Åª¬π</a></li>
<li><a href="https://github.com/adraffy/ens-labels/">Label Database</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-regs.html">Recent Registrations</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-renews.html">Recent Renews</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-exp.html">Expirations</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-emoji-freq.html">Emoji Frequency Browser</a></li>
<li><a href="../../emoji.js/test/demo.html">Emoji Parser</a></li>
<li><a href="../../keccak.js/test/demo.html">Keccak Hasher</a></li>
<li><a href="../../punycode.js/test/demo.html">Punycode Coder</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-batch-resolver.html">Batch Resolver</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-nft-matcher.html">ENS+NFT Matcher</a></li>
<li><a href="https://raffy.antistupid.com/eth/emoji-pixels.html">Emoji Pixel Maker</a></li>
</ul>
</div>
<footer>Created by <a href="https://x.com/adraffy">raffy.eth</a></footer>
<script type="module">
// to prepare this file for self-hosted deployment:
// * replace infura_provider with a public provider, eg. new ethers.CloudflareProvider();
// * replace "../../punycode.js" with https://cdn.jsdelivr.net/npm/@adraffy/punycode@latest/dist/index.min.js
// * replace "../../cid.js" with https://cdn.jsdelivr.net/npm/@adraffy/cid@latest/dist/index.min.js
// * replace "../../" with https://adraffy.github.io/
import {ethers} from 'https://cdnjs.cloudflare.com/ajax/libs/ethers/6.10.0/ethers.js';
import {
	ens_normalize, ens_split, ens_beautify, ens_tokenize, ens_emoji,
	nfc, nfd, hex_cp, quote_cp, explode_cp, str_from_cps, safe_str_from_cps,
	dom_from_tokens, use_default_style, versions, compare_arrays, should_escape,
} from '../dist/all.min.js';
import {puny_encoded, is_surrogate} from '../../punycode.js/dist/index.min.js'; 
import {CID, uvarint, convert, Bech32, Base36, Base58BTC, Base64URL} from '../../cid.js/dist/index.min.js';
import eth_ens_namehash from './eth-ens-namehash@2.0.15.min.js';
use_default_style();

const EMOJI = ens_emoji();
const emoji_url = './emoji.html#q=%s';

const input_field = document.querySelector('#input_field');
const resolve_btn = document.querySelector('#resolve_btn');
const auto_resolve_check = document.querySelector('#auto_resolve_check');
const show_components_check = document.querySelector('#show_components_check');
const show_records_check = document.querySelector('#show_records_check');
const skip_norm_check = document.querySelector('#skip_norm_check');
const show_details_check = document.querySelector('#show_details_check');
const force_ltr_check = document.querySelector('#force_ltr_check');
const force_mainnet_check = document.querySelector('#force_mainnet_check');
const recent_select = document.querySelector('#recent_select');
const recent_optgroup = document.querySelector('#recent_select optgroup');
const options_div = document.querySelector('#options');
const actions_div = document.querySelector('#actions');
const primary_loader = document.querySelector('#actions .spinner');
const output_div = document.querySelector('#output');
const readme_dom = [...output_div.childNodes]; // save initial ux
const examples_div = document.querySelector('#examples');
const examples_btn = document.querySelector('#examples_btn');
const provider_div = document.querySelector('#provider');
const nf_btn = document.querySelector('#nf_btn');
const escape_btn = document.querySelector('#escape_btn');
const parent_btn = document.querySelector('#parent_btn');

const RESOLVE_MODE_IDLE = 'idle';
const RESOLVE_MODE_EMPTY = 'empty';

const STORAGE_RECENT = 'recent';
const STORAGE_AUTO_RESOLVE = 'auto_resolve';
const STORAGE_SHOW_DETAILS = 'show_details';
const STORAGE_SHOW_RECORDS = 'show_records';
const STORAGE_SHOW_COMPONENTS = 'show_components';
const STORAGE_FORCE_LTR = 'force_ltr';
const STORAGE_HIDE_EXAMPLES = 'hide_examples';

const INPUT_NAME = 'Input';
const OPENSEA_NAME = 'OpenSea';
const VISION_NAME = 'Vision';
const PRETTY_NAME = 'üíñÔ∏è';
const MANAGER_NAME = 'Manager';
const NFT_OWNER_NAME = 'NFT Owner';

const CHAIN_ID_MAINNET = 1;
const CHAIN_ID_GOERLI = 5;
const CHAIN_ID_SEPOLIA = 11155111;
const CHAINS = [
	// https://chainlist.wtf/
	//case 3: return 'https://ropsten.etherscan.io';
	//case 4: return 'https://rinkeby.etherscan.io';
	//case 139: return 'https://polygonscan.io';	
	{
		id: CHAIN_ID_MAINNET,
		name: 'Mainnet',
		explorer: 'https://etherscan.io',
		metadata: 'https://metadata.ens.domains/mainnet',
		opensea: 'https://opensea.io/assets/ethereum/',
		is_mainnet: true,
	},
	{
		id: CHAIN_ID_GOERLI,
		name: 'Goerli',
		explorer: 'https://goerli.etherscan.io',
		metadata: 'https://metadata.ens.domains/goerli',
		opensea: 'https://testnets.opensea.io/assets/goerli/'
	},
	{
		id: CHAIN_ID_SEPOLIA,
		name: 'Sepolia',
		explorer: 'https://sepolia.etherscan.io',
		metadata: 'https://metadata.ens.domains/sepolia',
		opensea: 'https://testnets.opensea.io/assets/sepolia/',
	}
];

const MIN_ETH_LENGTH = 3;
const NFT_DOMAINS = new Set(['eth', 'art']); //, 'box']);
const REVERSE_DOMAIN = 'addr.reverse';
const RESOLVER_NAMES = {
	'0x1da022710dF5002339274AaDEe8D58218e9D6AB5': 'Old Public (v1)',
	'0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41': 'Old Public (v2)',
	'0x231b0Ee14048e9dCcD1d247744d114a4EB5E8E63': '‚ú®Ô∏è Public (v3)',
	'0x5fBb459C49BB06083C33109fA4f14810eC2Cf358': 'Old Reverse (v1)',
	'0xA2C122BE93b0074270ebeE7f6b7292C7deB45047': 'Old Reverse (v2)',
};
const IS_CONTRACT = new Map();
const NOT_IFACE_RESOLVER = new Set();
const ADDRESS_MAP = new Map();
const IFACE_ETH_CONTROLLER = '0x612e8c09';

// TODO: https://github.com/ensdomains/docs/blob/profile-text-records/ens-improvement-proposals/ensip-xx-profile-text-records.md
const TYPE_ADDR = 'addr(bytes32,uint256)';
const TYPE_TEXT = 'text';
const RECORDS = [
	{
		type: TYPE_TEXT, 
		key: 'name',
	},
	// {
	// 	type: TYPE_TEXT, 
	// 	key: 'language',
	// },
	// {
	// 	type: TYPE_TEXT, 
	// 	key: 'timezone',
	// 	icon: '<b>tz</b>'
	// },
	{
		type: TYPE_TEXT, 
		key: 'notice',
		icon: 'üö®Ô∏è', //'‚ö†Ô∏è',
	},
	{
		type: TYPE_TEXT, 
		key: 'url',
		icon: 'üåêÔ∏è',
		format(x) {
			let match = x.match(/^https?:\/\/(.*?)\/?$/i);
			return match ? match[1] : x;
		},
		url(x) { return x; }
	},
	{
		type: TYPE_TEXT, 
		key: 'location'
	},	
	{
		type: TYPE_TEXT, 
		key: 'phone',
		icon: '‚òéÔ∏è',
		url(x) { return `tel:${x}`; }
	},
	{
		type: TYPE_TEXT, 
		key: 'email',
		icon: 'üìßÔ∏è',
		url(x) { return `mailto:${x}`; }
	},
	{
		type: TYPE_TEXT, 
		key: 'com.twitter', 
		icon: `<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 22 20"><path fill="var(--geist-fill, currentColor)" stroke="none" d="M16.99 0H20.298L13.071 8.26L21.573 19.5H14.916L9.702 12.683L3.736 19.5H0.426L8.156 10.665L0 0H6.826L11.539 6.231L16.99 0ZM15.829 17.52H17.662L5.83 1.876H3.863L15.829 17.52Z"/></svg>`,
		//format(x) { return `@${x}`; },
		url(x) { return `https://x.com/${encodeURIComponent(x)}`; }
	},
	{
		type: TYPE_TEXT, 
		key: 'farcaster', 
		url(x) { return `https://warpcast.com/${encodeURIComponent(x)}`; }
	},
	{
		type: TYPE_TEXT, 
		key: 'lens', 
		url(x) { return `https://hey.xyz/u/${encodeURIComponent(x)}`; }
	},
	{
		type: TYPE_TEXT,
		key: 'com.github', 
		icon: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="#000000"><path d="M12 0.297134C5.37 0.297134 0 5.67014 0 12.2971C0 17.6001 3.438 22.0971 8.205 23.6821C8.805 23.7951 9.025 23.4241 9.025 23.1051C9.025 22.8201 9.015 22.0651 9.01 21.0651C5.672 21.7891 4.968 19.4551 4.968 19.4551C4.422 18.0701 3.633 17.7001 3.633 17.7001C2.546 16.9561 3.717 16.9711 3.717 16.9711C4.922 17.0551 5.555 18.2071 5.555 18.2071C6.625 20.0421 8.364 19.5121 9.05 19.2051C9.158 18.4291 9.467 17.9001 9.81 17.6001C7.145 17.3001 4.344 16.2681 4.344 11.6701C4.344 10.3601 4.809 9.29014 5.579 8.45014C5.444 8.14714 5.039 6.92714 5.684 5.27414C5.684 5.27414 6.689 4.95214 8.984 6.50414C9.944 6.23714 10.964 6.10513 11.984 6.09913C13.004 6.10513 14.024 6.23714 14.984 6.50414C17.264 4.95214 18.269 5.27414 18.269 5.27414C18.914 6.92714 18.509 8.14714 18.389 8.45014C19.154 9.29014 19.619 10.3601 19.619 11.6701C19.619 16.2801 16.814 17.2951 14.144 17.5901C14.564 17.9501 14.954 18.6861 14.954 19.8101C14.954 21.4161 14.939 22.7061 14.939 23.0961C14.939 23.4111 15.149 23.7861 15.764 23.6661C20.565 22.0921 24 17.5921 24 12.2971C24 5.67014 18.627 0.297134 12 0.297134Z"></path></svg>`,
		url(x) { return `https://github.com/${encodeURIComponent(x)}`; }
	},
	{
		type: TYPE_TEXT,
		key: 'com.discord',
		icon: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" role="img" fill="#5A57DD"><path d="M20.7273 5.45455C20.7273 5.45455 18.2264 3.49746 15.2727 3.27273L15.0065 3.80509C17.6771 4.45855 18.9022 5.39509 20.1818 6.54546C17.9755 5.41909 15.7969 4.36364 12 4.36364C8.20309 4.36364 6.02455 5.41909 3.81818 6.54546C5.09782 5.39509 6.55527 4.35546 8.99345 3.80509L8.72727 3.27273C5.62855 3.56564 3.27273 5.45455 3.27273 5.45455C3.27273 5.45455 0.479455 9.50455 0 17.4545C2.81564 20.7016 7.09091 20.7273 7.09091 20.7273L7.98491 19.5355C6.46745 19.008 4.75364 18.066 3.27273 16.3636C5.03891 17.7 7.70455 19.0909 12 19.0909C16.2955 19.0909 18.9611 17.7 20.7273 16.3636C19.2464 18.066 17.5325 19.008 16.0151 19.5355L16.9091 20.7273C16.9091 20.7273 21.1844 20.7016 24 17.4545C23.5205 9.50455 20.7273 5.45455 20.7273 5.45455ZM8.45455 15.2727C7.40018 15.2727 6.54545 14.2958 6.54545 13.0909C6.54545 11.886 7.40018 10.9091 8.45455 10.9091C9.50891 10.9091 10.3636 11.886 10.3636 13.0909C10.3636 14.2958 9.50891 15.2727 8.45455 15.2727ZM15.5455 15.2727C14.4911 15.2727 13.6364 14.2958 13.6364 13.0909C13.6364 11.886 14.4911 10.9091 15.5455 10.9091C16.5998 10.9091 17.4545 11.886 17.4545 13.0909C17.4545 14.2958 16.5998 15.2727 15.5455 15.2727Z"></path></svg>`,
	},
	{
		type: TYPE_TEXT,
		key: 'io.keybase',
		icon: '<img src="https://keybase.io/images/icons/icon-keybase-logo-48.png">',
		url(x) { return `https://keybase.io/${encodeURIComponent(x)}`; }
	},
	{
		type: TYPE_TEXT,
		key: 'org.telegram',
		icon: `<svg xmlns="http://www.w3.org/2000/svg" fill="#2BABEE" viewBox="0 0 24 24" role="img"><g fill="inherit" clip-path="url(#a)"><path fill="inherit" fill-rule="evenodd" d="M24 12c0 6.6274-5.3726 12-12 12-6.62742 0-12-5.3726-12-12C0 5.37258 5.37258 0 12 0c6.6274 0 12 5.37258 12 12ZM12.43 8.85893c-1.1672.48547-3.49987 1.49027-6.99812 3.01437-.56806.2259-.86563.4469-.89272.663-.04578.3652.41154.509 1.03431.7048.08471.0267.17248.0543.26246.0835.6127.1992 1.43689.4322 1.86535.4414.38865.0084.82244-.1518 1.30135-.4807 3.26847-2.2063 4.95577-3.32149 5.06167-3.34553.0747-.01696.1783-.03829.2485.02408.0701.06235.0632.18045.0558.21215-.0453.1931-1.8405 1.8621-2.7695 2.7258-.2896.2692-.495.4602-.537.5038-.0941.0978-.19.1902-.2821.279-.5692.5487-.9961.9602.0236 1.6322.49.3229.8821.59 1.2733.8564.4273.2909.8534.5811 1.4047.9425.1405.0921.2746.1877.4053.2808.4972.3545.9438.6729 1.4957.6221.3206-.0295.6519-.331.8201-1.2302.3975-2.1252 1.1789-6.7299 1.3595-8.62742.0158-.16625-.0041-.37901-.0201-.4724-.0159-.0934-.0493-.22647-.1707-.32498-.1438-.11666-.3658-.14126-.465-.13952-.4514.00796-1.1439.24874-4.4764 1.63485Z" clip-rule="evenodd"></path></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h24v24H0z"></path></clipPath></defs></svg>`,
		url(x) { return `https://t.me/${encodeURIComponent(x)}`; }
	},
	{
		type: TYPE_TEXT,
		key: 'com.linkedin',
		icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>`,
		url(x) { return `https://www.linkedin.com/in/${encodeURIComponent(x)}`; }
	},
	{
		type: 'contenthash',
	},
	{
		type: 'pubkey',
	},
	{
		type: TYPE_ADDR,
		coin: 0, // BTC
		icon: `<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 500 500" role="img" class="sc-56a68b4b-0 nEsDk"><path fill="#F39321" d="M43.43 125.143c7.71-10.766 14.875-21.901 23.562-31.986 15.8-18.343 33.692-34.063 54.18-47.075 18.379-11.672 37.761-20.872 58.501-27.305 32.294-10.018 65.26-12.997 98.838-9.165 24.544 2.801 48.191 9.067 70.713 19.215 13.633 6.142 26.456 13.731 39.025 21.927 25.328 16.515 45.618 38.014 62.58 62.577 18.116 26.236 29.889 55.421 36.346 86.725 4.535 21.983 6.449 44.171 4.503 66.504-2.399 27.536-8.514 54.086-19.938 79.604-9.662 21.583-21.589 41.401-36.861 59.301-14.94 17.511-31.788 32.831-51.149 45.461-13.184 8.6-26.926 16.276-41.434 21.975-24.274 9.537-49.447 15.986-75.787 17.115-18.545.795-36.985.483-55.279-2.763-15.713-2.788-31.049-6.858-46.063-12.496-14.566-5.47-28.693-11.95-41.709-20.143-18.766-11.812-35.683-26.147-50.737-42.663-16.773-18.403-30.373-38.808-40.779-61.344-14.7-31.835-21.929-65.401-22.359-100.425-.162-13.173 1.349-26.244 3.105-39.283.126-.933-.002-1.899-.012-2.851 1.536-.952 1.4-2.618 1.677-4.071 3.906-20.483 10.494-40.059 19.418-58.906 3.162-6.674 7.525-12.764 9.659-19.928zm281.727 129.37c6.537-3.474 12.749-5.465 17.658-9.85 18.918-16.899 23.96-56.673-6.747-75.833-9.566-5.969-19.77-10.393-30.77-14.907 1.819-14.731 7.709-28.516 9.622-43.603-9.076-2.249-17.578-5.234-26.425-6.193l-10.674 41.837c-6.78-2.076-13.761-1.879-20.142-5.473 2.302-14.39 7.773-27.872 9.268-42.314-9.322-1.464-17.216-5.094-26.265-5.485l-10.586 42.215c-17.944-2.75-34.419-8.921-52.52-12.239-3.977 8.91-5.738 18.311-7.334 28.313 5.896 1.392 11.022 2.623 16.158 3.811 12.965 2.998 16.517 10.086 13.439 21.424-2.19 8.065-4.166 16.189-6.182 24.301-7.245 29.16-14.432 58.333-21.72 87.482-1.642 6.567-5.734 8.706-12.398 7.731-6.563-.96-12.757-3.907-19.99-3.693-3.136 10.032-9.378 18.871-11.588 29.946l51.344 13.08c-1.312 15.208-7.614 29.125-9.476 44.441l25.544 6.123c5.653-14.044 6.957-28.803 12.226-43.33 6.351 3.265 13.397 2.317 19.612 6.427l-10.178 42.077c8.986 3.216 17.753 4.528 26.758 6.77l10.578-42.386c2.123-1.091 3.676-.888 5.143-.574a132.886 132.886 0 0 0 42.676 2.14c12.368-1.373 23.343-6.088 32.148-15.372 9.791-10.323 14.71-22.952 17.078-36.535 1.93-11.065 1.436-22.277-5.06-32.071-5.091-7.674-12.084-13.53-21.197-18.26zM223.128 312.17c17.411 4.325 34.803 8.95 53.02 5.624 9.715-1.774 17.037-6.73 19.985-16.503 2.78-9.218 1.164-17.593-5.673-24.879-7.11-7.576-16.254-11.514-25.682-14.807-11.264-3.934-22.683-7.508-34.99-8.48l-13.972 56.788c2.981.929 5.117 1.712 7.312 2.257zm61.5-80.324c9.628-1.368 17.612-7.738 19.958-16.393 2.869-10.583-.337-19.865-8.902-26.178-9.718-7.163-20.908-10.807-32.47-13.337-4.307-.943-8.544-3.454-13.756-1.759l-12.599 51.209c16.457 4.155 31.611 8.753 47.769 6.458z"></path></svg>`,
		btc: {p2pkh: 0, p2sh: 5, hrp: 'bc', p2wpkh: 0, p2tr: 1},
		url(x) { return `https://blockstream.info/address/${x}`; },
	},
	{
		type: TYPE_ADDR,
		coin: 2, // LTC
		icon: `<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 500 500" role="img" class="sc-56a68b4b-0 nEsDk"><circle cx="249.8" cy="250.2" r="248.4" style="fill: rgb(51, 94, 159);"></circle><path d="m139.4 402.6 37-120.2-40.3 12.3 10.7-29.6 37-11.5 51.7-170.1c1.1-3.6 4.5-6.1 8.3-6.1h52.8c5.8 0 9.9 5.6 8.3 11.1l-42 140.4 37.9-10.7-6.9 28.6-39.1 11.8-27.3 87.2h139c4.2 0 7.2 4 6.1 8L360.5 398c-.8 2.7-3.2 4.6-6.1 4.6h-215z" style="fill: rgb(255, 255, 255);"></path></svg>`,
		btc: {p2pkh: 0x30, p2sh: 0x32, hrp: 'ltc', p2wpkh: 0},
		url(x) { return `https://litecoinspace.org/address/${x}`; }
	},
	{
		type: TYPE_ADDR,
		coin: 3, // DOGE
		icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2000 2000" role="img" class="sc-56a68b4b-0 nEsDk"><g fill="#c2a633"><path d="M1024 659H881.12v281.69h224.79v117.94H881.12v281.67H1031c38.51 0 316.16 4.35 315.73-327.72S1077.44 659 1024 659z"></path><path d="M1000 0C447.71 0 0 447.71 0 1000s447.71 1000 1000 1000 1000-447.71 1000-1000S1552.29 0 1000 0zm39.29 1540.1H677.14v-481.46H549.48V940.7h127.65V459.21h310.82c73.53 0 560.56-15.27 560.56 549.48 0 574.09-509.21 531.41-509.21 531.41z"></path></g></svg>`,
		btc: {p2pkh: 0x1E, p2sh: 0x16},
		url(x) { return `https://dogechain.info/address/${x}`; }
	},
	{
		type: TYPE_ADDR,
		coin:  8444, // CHIA
		icon: 'üå±Ô∏è',
		bech32: {hrp: 'xch', type: Bech32.M},
		url(x) { return `https://xchscan.com/address/${x}`; }
	},
	// {
	// 	type: TYPE_ADDR,
	// 	coin: 137 | 0x80000000,
	// 	icon: '<b>polygon</b>',
	// 	url(x) { return `https://polygonscan.com/address/${x}`; },
	// },
	{
		type: TYPE_TEXT, 
		key: 'description',
		icon: '<b>desc</b>',
	},
	{
		type: TYPE_TEXT,
		key: 'avatar',
		format() { return ''; },
	},
	{
		type: TYPE_TEXT,
		key: 'banner',
		format() { return ''; },
		url(x) { return x; },
	},
];

const location0 = new URL(window.location.href);
const entity_span = create('span');

input_field.value = decodeURIComponent(location0.hash.slice(1));
force_mainnet_check.checked = location0.searchParams.has('1');
skip_norm_check.checked = location0.searchParams.has('skip');
const debug = location0.searchParams.has('debug');

let infura_provider = new ethers.InfuraProvider(CHAIN_ID_MAINNET, 'f36f6a8638134ac09f9400d3a7008dfe');
let window_provider;
let active_provider;
let active_chain; // = CHAINS[0];
let registry_contract;
let eth_resolver_contract;
let eth_nft_contract;
let eth_controller_contract;
let wrapper_contract;
let multicall_contract;
let price_oracle_contract;
let reverse_registrar;
let resolve_timer = RESOLVE_MODE_IDLE;
let resolve_t0;

console.log(versions);
document.querySelector('footer').innerHTML += ` ‚Äî <span>v${versions.version}</span>`;
document.querySelector('footer span').addEventListener('click', () => {
	window.alert(JSON.stringify(versions, null, ' '));
});
// TODO: add more 
function keycap(i) {
	return String.fromCodePoint(0x30+i, 0xFE0F, 0x20E3);
}
const KEYCAP_MINUS = '‚ûñÔ∏è';
const KEYCAP_NAME = 'Keycap';
const DIGIT_MAP = new Map();
const DIGITS_MAP = new Map();
for (let i = 0; i < 10; i++) DIGIT_MAP.set(keycap(i), i);
function add_digits(name, digits, extra = {}) {
	explode_cp(digits).forEach((cp, i) => DIGIT_MAP.set(cp, {name, i, ...extra}));
	DIGITS_MAP.set(name, digits);
}
add_digits('ASCII', '0123456789');
add_digits('Arabic', 'Ÿ†Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©', {mixed: 1}); //, reversed: true
[[0x6F4, 4], [0x6F5, 5], [0x6F6, 6]].forEach(([cp, i]) => {
	DIGIT_MAP.set(cp, {name: 'Extended Arabic', i, mixed: 1});
});
add_digits('CJK', '„Äá‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πù');
add_digits('Devangari', '‡•¶‡•ß‡•®‡•©‡•™‡•´‡•¨‡•≠‡•Æ‡•Ø');
add_digits('Thai', '‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô');
//add_digits('Bengali', '‡ß¶‡ßß‡ß®‡ß©‡ß™‡ß´‡ß¨‡ß≠‡ßÆ‡ßØ');
//add_digits('Tamil', '‡Ø¶‡Øß‡Ø®‡Ø©‡Ø™‡Ø´‡Ø¨‡Ø≠‡ØÆ‡ØØ'); 

read_local_storage(STORAGE_HIDE_EXAMPLES, x => examples_div.classList.toggle('hide', x), true);
read_local_storage(STORAGE_AUTO_RESOLVE, x => auto_resolve_check.checked = x);
read_local_storage(STORAGE_SHOW_DETAILS, x => show_details_check.checked = x);
read_local_storage(STORAGE_SHOW_COMPONENTS, x => show_components_check.checked = x);
read_local_storage(STORAGE_SHOW_RECORDS, x => show_records_check.checked = x);
read_local_storage(STORAGE_FORCE_LTR, x => force_ltr_check.checked = x);

sync_recent(localStorage[STORAGE_RECENT]);

for (let btn of document.querySelectorAll('#examples button:not([id]), button[data-name]')) {
	let name = btn.innerText;
	if (btn.dataset.name) name = btn.dataset.name;
	if (typeof btn.dataset.raw !== 'string') name = replace_escapes(name);
	if (!btn.innerText || btn.innerText.includes('{')) btn.innerText = name;
	let meta = typeof btn.dataset.meta === 'string' || name.includes(':') || is_checksum_address(name);
	try {
		if (meta || name !== ens_normalize(name)) {
			btn.classList.add('mapped');
		}
	} catch (err) {
		btn.classList.add('error');
	}	
	if (!meta && !name.includes('.')) name += '.eth';
	if (typeof btn.dataset.escape === 'string') name = apply_escapes_where(name);
	if (!btn.title) btn.title = meta ? name : `${name}\n${explode_cp(name).map(hex_cp).join(' ')}`;
	btn.addEventListener('click', () => {
		input_field.value = name;
		if (btn.dataset.skip) skip_norm_check.checked = true;
		if (options_div.getBoundingClientRect().top > window.innerHeight * .9) {
			options_div.scrollIntoView(); // scuffed
		}
		let delay = parseInt(btn.dataset.delay)|0;
		if (delay > 0) {
			schedule_resolve(delay);
		} else {
			resolve();
		}
	});
}
for (let x of document.querySelectorAll('[data-tokenize]')) {
	x.replaceWith(dom_from_tokens(ens_tokenize(replace_escapes(x.dataset.tokenize)), {
		emoji_url,
		components: x.dataset.parts
	}));
}

resolve_btn.addEventListener('click', () => resolve());
input_field.addEventListener('keydown', e => {
	if (e.key === 'Enter') {
		e.stopPropagation();
		resolve();
	}
});
input_field.addEventListener('input', () => {
	if (parse() && auto_resolve_check.checked) schedule_resolve();
});

window.addEventListener('storage', e => {
	if (e.type === 'storage' && e.key === STORAGE_RECENT) {
		sync_recent(e.newValue);
	}
});
function sync_recent(saved) {
	recent_optgroup.innerHTML = '';
	try {
		JSON.parse(saved).reverse().forEach(x => add_recent(x, false));
	} catch (err) {	
	}
}
recent_select.addEventListener('change', () => {
	let option = recent_select.selectedOptions[0];
	recent_select.selectedIndex = -1;
	if (!option) return;
	if (recent_optgroup.contains(option)) {
		input_field.value = option.value;
		resolve();
	} else if (option.value === 'reset') {
		recent_select.classList.add('hide');
		recent_optgroup.innerHTML = '';
		localStorage[STORAGE_RECENT] = '[]';
	}
});
function add_recent(name, save = true) {
	if (!name) return;
	let found;
	for (let x of recent_optgroup.children) {
		if (x.value === name) {
			recent_optgroup.prepend(x); // move to top
			found = true;
			break;
		}
	}
	if (!found) {
		while (recent_optgroup.childElementCount >= 25) { // max
			recent_optgroup.lastChild.remove();
		}
		let option = new Option();
		option.value = name;
		if (is_checksum_address(name)) {
			option.innerHTML = `üè†Ô∏è ${name}`; 
		} else {
			try {
				let norm = ens_normalize(name);
				option.innerHTML = `${norm === name ? '‚úÖÔ∏è' : '‚òëÔ∏è'} ${name}`;
			} catch (err) {
				option.innerHTML = `‚ùåÔ∏è ${apply_escapes_where(name, cp => should_escape(cp) || cp == 0x20)}`;
			}
		}
		recent_optgroup.prepend(option);
	}
	recent_select.selectedIndex = -1;
	recent_select.classList.remove('hide');
	if (save) {
		localStorage[STORAGE_RECENT] = JSON.stringify([...recent_optgroup.children].map(x => x.value));
	} 
}
make_network_switcher(document.querySelector('#add_goerli_btn'), CHAIN_ID_GOERLI);
make_network_switcher(document.querySelector('#add_sepolia_btn'), CHAIN_ID_SEPOLIA);
document.querySelector('#random_emoji_btn').addEventListener('click', e => {
	let name = '';
	let pool = e.altKey ? EMOJI.filter(cps => cps.length == 1 || (cps.length == 2 && cps[1] === 0xFE0F)) : EMOJI;
	while (Array.from(name).length < MIN_ETH_LENGTH) {
		name += ens_normalize(str_from_cps(pool[Math.random() * pool.length|0]));
	}
	input_field.value = `${name}.eth`;
	skip_norm_check.checked = false;
	resolve();
});
function get_selected_input() {
	let {value, selectionStart, selectionEnd} = input_field;
	if (selectionEnd > selectionStart) {
		value = value.slice(selectionStart);
	}
	return replace_escapes(value);
}
document.querySelector('#find_emoji_btn').addEventListener('click', e => {
	let url = './emoji.html';
	let value = get_selected_input();
	let token = ens_tokenize(value).find(x => x.emoji);
	if (token) url += `#q=${encodeURIComponent(String.fromCodePoint(...token.cps))}`;
	create_link(url).click();	
});
document.querySelector('#chars_btn').addEventListener('click', e => {
	let url = './chars.html';
	let value = get_selected_input();
	if (value) url += `#${value.codePointAt(0).toString(16)}`;
	create_link(url).click();
});
document.querySelector('#confused_btn').addEventListener('click', e => {
	create_link(`./confused.html#${encode_uri_component_surrogate_escaped(input_field.value.replaceAll('.', ''))}`).click();
});
nf_btn.addEventListener('click', () => {
	let s0 = input_field.value;
	let s1 = replace_escapes(s0);
	let s2 = apply_escapes_where(str_from_cps(nfd(explode_cp(s1))));
	let s3 = apply_escapes_where(str_from_cps(nfc(explode_cp(s1))));
	if (s2 === s3 && s2 === apply_escapes_where(s1)) return; // do nothing
	input_field.value = s0 == s2 ? s3 : s2;
	resolve();
});
parent_btn.addEventListener('click', e => {
	let name = input_field.value;
	let pos = name.indexOf('.');
	input_field.value = pos >= 0 ? name.slice(pos+1) : '';
	resolve();
});
escape_btn.addEventListener('click', e => {
	let s0 = input_field.value;
	let s1 = replace_escapes(s0);
	let s2 = apply_escapes_where(s1, undefined, e.altKey);
	let s3 = apply_escapes_where(s1, () => true, e.altKey);
	let set = [...new Set([s1, s2, s3])];
	let pos = set.indexOf(s0);	
	input_field.value = set[(pos + 1) % set.length];
	update_title();
});
document.querySelector('#copy_link_btn').addEventListener('click', () => {
	navigator.clipboard.writeText(window.location.href);
});
document.querySelector('#copy_example_btn').addEventListener('click', () => {
	let url = new URL(window.location.href);
	url.hash = '#vitalik.eth';
	navigator.clipboard.writeText(url);
});
auto_resolve_check.addEventListener('input', () => {
	localStorage[STORAGE_AUTO_RESOLVE] = auto_resolve_check.checked;	
	if (auto_resolve_check.checked && input_field.value) {
		resolve();
	}
});
show_details_check.addEventListener('input', () => {	
	localStorage[STORAGE_SHOW_DETAILS] = show_details_check.checked;	
	for (let el of document.querySelectorAll('.detailed')) {
		make_detailed(el);
	}
});
show_records_check.addEventListener('input', () => {
	localStorage[STORAGE_SHOW_RECORDS] = show_records_check.checked;	
	let records = document.querySelector('.row.records');
	if (records) {
		records.classList.toggle('hide', !show_records_check.checked);
	} else if (show_records_check.checked) {
		resolve();
	}
});
show_components_check.addEventListener('input', () => {
	localStorage[STORAGE_SHOW_COMPONENTS] = show_components_check.checked;
	update_exploded();
});
force_ltr_check.addEventListener('input', () => {
	localStorage[STORAGE_FORCE_LTR] = force_ltr_check.checked;
	sync_force_ltr();
});
force_mainnet_check.addEventListener('input', async () => {
	update_title();
	if (!window_provider) return;
	force_mainnet_check.disabled = true;
	if (update_network(await get_window_provider_network().catch(() => {}))) {
		resolve();
	}
	force_mainnet_check.disabled = false;
});
skip_norm_check.addEventListener('input', () => {
	resolve();
}); 
examples_btn.addEventListener('click', () => {
	let b = !examples_div.classList.contains('hide');
	examples_div.classList.toggle('hide', b);
	localStorage[STORAGE_HIDE_EXAMPLES] = b;
	sync_examples();
});

if (input_field.value.endsWith('_!')) { // backwards compat
	input_field.value = input_field.value.slice(0, -2);
	skip_norm_check.checked = true;
}
if (window.ethereum) {
	let p = ethereum;
	if (Array.isArray(ethereum.providers)) p = ethereum.providers[0]; // fix scuffed multi-provider
	window_provider = new ethers.BrowserProvider(p, 'any');
	window_provider._provider = p;
	let timer = setTimeout(update_network, 100); // avoid creating infura connection if possible
	window_provider.getNetwork().finally(() => clearTimeout(timer)).then(update_network).catch(() => {});
	ethereum.on('connect', ({chainId}) => {
		clearTimeout(timer);
		update_network(ethers.Network.from(parseInt(chainId)));
	});
	ethereum.on('chainChanged', chainId => {
		update_network(ethers.Network.from(parseInt(chainId)));
	});
	ethereum.on('disconnect', () => update_network());
} else {
	force_mainnet_check.checked = false;
	force_mainnet_check.classList.add('hide');
	update_network();
}

sync_examples();
sync_force_ltr();
input_field.focus();
window.addEventListener('hashchange', () => {
	input_field.value = decodeURIComponent(window.location.hash.slice(1));
	resolve();
});

function make_network_switcher(btn, id) {
	btn.classList.add('chain');
	btn.dataset.chain = id;
	btn.title = `Chain: ${id} / 0x${id.toString(16)}`;
	btn.addEventListener('click', () => switch_to_network(id));
	return btn;
}
async function get_window_provider_network() {
	if (!window_provider) throw new Error('no window');
	if (!window_provider._provider.isConnected()) throw new Error('not connected');
	return window_provider.getNetwork();
}
async function switch_to_network(id) {
	let network = await get_window_provider_network();
	if (Number(network.chainId) === id) {
		if (active_provider === window_provider) return;
		return update_network(network);
	}
	await window_provider.send('wallet_switchEthereumChain', [{chainId: `0x${id.toString(16)}`}]);
	for (let btn of document.querySelectorAll('.chain')) {
		btn.disabled = true;
	}
}
function update_network(network) {
	let chain0 = active_chain;
	active_chain = CHAINS[0];
	active_provider = infura_provider;
	let window_online = window_provider && window_provider._provider.isConnected();
	let registry = '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e';
	if (network && window_online) {
		let chain = CHAINS.find(x => x.id === Number(network.chainId));
		if (chain && (!force_mainnet_check.checked || chain.is_mainnet)) {
			active_chain = chain;
			active_provider = window_provider;
			let plugin = network.plugins.find(x => x instanceof ethers.EnsPlugin);
			if (plugin) {
				registry = plugin.address;
			} else {
				network.attachPlugin(new ethers.EnsPlugin(registry, chain));
			}
		}
	}
	let using_window = active_provider === window_provider;
	let provider_name = using_window ? 'window.ethereum' : 'Infura';
	document.body.classList.toggle('testnet', !active_chain.is_mainnet);	
	let network_div = create('div', {
		innerHTML: `using <b>${provider_name}</b> on <a target="_blank" href="${active_chain.explorer}/address/${registry}" title="Registry Contract">${active_chain.name}</a>`
	});
	if (window_online && !using_window && network && Number(network.chainId) !== CHAIN_ID_MAINNET && !force_mainnet_check.checked) {
		provider_div.innerHTML = `<div class="error">Unsupported Network (${network.chainId})</div>`;
	} else {
		provider_div.innerHTML = '';	
	}
	provider_div.append(network_div);
	for (let btn of document.querySelectorAll('.chain')) {
		btn.disabled = !window_online || active_chain.id == btn.dataset.chain;
	}
	if (!active_chain.is_mainnet || (window_online && active_provider !== window_provider)) {
		network_div.append(make_network_switcher(create('button', {
			innerHTML: active_chain.is_mainnet ? 'Use Browser' : '‚Ü™ Mainnet'
		}), CHAIN_ID_MAINNET));
	}
	if (chain0 === active_chain) return; // no change	
	let init = !registry_contract;
	registry_contract = new ethers.Contract(registry, [
		'function resolver(bytes32 node) external view returns (address)',
		'function owner(bytes32 node) external view returns (address)',
	], active_provider);
	eth_resolver_contract = null;
	eth_nft_contract = null;
	eth_controller_contract = null;
	wrapper_contract = null;
	multicall_contract = null;
	reverse_registrar = null;
	NOT_IFACE_RESOLVER.clear();
	IS_CONTRACT.clear();
	if (input_field.value) {
		schedule_resolve(0);
	} else if (init) {
		parse();
	}
	return true; // changed
}

function sync_examples() {
	if (examples_div.classList.contains('hide')) {
		examples_btn.innerText = 'üëÄ Examples';
		options_div.prepend(examples_btn);
	} else {
		examples_btn.innerText = 'üôà Hide Examples';
		examples_div.prepend(examples_btn);
	}
}

function sync_force_ltr() {
	input_field.classList.toggle('force-ltr', force_ltr_check.checked);
}

function should_stop_resolving() {
	return resolve_timer !== RESOLVE_MODE_IDLE;
}

function schedule_resolve(delay = 500) {
	clearTimeout(resolve_timer);
	if (is_working()) {
		resolve_timer = [Date.now() + delay]; // encode as future time
	} else {
		primary_loader.classList.remove('hide');
		resolve_timer = setTimeout(resolve, delay);
	}
} 

function stop_resolving() {
	clearTimeout(resolve_timer);
	resolve_timer = RESOLVE_MODE_EMPTY;
	primary_loader.classList.add('hide');
}

function update_title() {
	let title = 'ENS Resolver';
	let input = input_field.value;
	let url = new URL(location0);
	let args = [];
	if (debug) args.push('debug');
	if (force_mainnet_check.checked) args.push('1');
	if (skip_norm_check.checked) args.push('skip');
	url.search = args.join('&');
	if (input) {
		title += `: ‚Äú${input}‚Äù`;
		if (skip_norm_check.checked) {
			title += ' (!)';
		}
		url.hash = '#' + encode_uri_component_surrogate_escaped(input);
	} else {
		url.hash = '';	
	}
	if (!active_chain.is_mainnet) {
		title += ` / ${active_chain.name}`;
	}
	window.history.replaceState(null, null, url); 
	document.title = title;
}

function replace_name(name) {
	//if (name === '[root]') return '';
	return name;
}

function parse() {
	update_title();	
	let input = input_field.value;
	let skip = skip_norm_check.checked;
	nf_btn.disabled = !input;
	escape_btn.disabled = !input;
	parent_btn.disabled = !input;	
	if (!input) {
		stop_resolving();
		output_div.innerHTML = '';
		output_div.append(...readme_dom);	
		return;
	}
	// TODO: conslidate this code with resolve()
	let name = replace_name(replace_escapes(input));
	output_div.innerHTML = '';
	if (resolve_timer === RESOLVE_MODE_EMPTY) {
		resolve_timer = RESOLVE_MODE_IDLE;
	}
	if (is_checksum_address(name)) {
		let row = create_row('Address');
		row.append(create_etherscan_address_link(name));		
		add_row_tag(row, create_reverse_resolve_btn(name));
		output_div.append(row);
		return true;
	}
	let row = create_row(INPUT_NAME);
	make_exploded(row, name, false); //, true);
	output_div.append(row, create_breakdown_row(name, true));
	try {
		let norm = ens_normalize(name);
		if (norm === name) {
			make_normalized(row, norm);
			//make_exploded(row, name, false);
		} else {
			add_row_tag(row, create_tag('fail', 'Normalized'));
			if (!skip) {
				add_transformed_row(name);
				let norm_row = create_row('Normalized');
				make_exploded(norm_row, norm, true);
				make_normalized(norm_row, norm);
				add_old_tag(norm_row, name, true);
				output_div.append(norm_row, create_breakdown_row(norm));
			}
		}		
		add_old_tag(row, name);
		//output_div.append(create_dns_row(norm));
		return true;
	} catch (err) {
		row.classList.add('error');
		add_row_tag(row, create_tag('norm', err));
		if (skip) return true;
		add_old_tag(row, name);
		stop_resolving();

		// if there is a fully ignorable label
		let collapsed = ens_split(name).filter(x => !x.tokens || x.tokens.length).map(x => str_from_cps(x.input)).join('.');
		if (collapsed !== name) {
			add_row_tag(row, create('button', {
				innerText: 'üí•Ô∏è Collapse Empty Labels',
				click() {
					input_field.value = collapsed;
					resolve();
				}
			}));
		}

		// if there is whitespace
		let stripped = name.replace(/\s+/g, '');
		if (stripped !== name) {
			add_row_tag(row, create('button', {
				innerText: '‚úÇÔ∏è Strip Whitespace',
				click() {
					input_field.value = stripped;
					resolve();
				}
			}));
		}

		// if there are likely unmapped mistakes
		const SLOPPY_MAP = new Map([
			[0x2F, 0x2044], 
			[0x3002, 0x2E],
			[0xFF0E, 0x2E],
			[0xFF61, 0x2E],
		]);
		let sloppy = str_from_cps(explode_cp(name).map(x => SLOPPY_MAP.get(x) || x))
		if (sloppy !== name) {
			add_row_tag(row, create('button', {
				innerHTML: 'üí£Ô∏è Unsafe Replace',
				title: `Replace the following characters:` + [...SLOPPY_MAP.entries()].map(([a, b]) => {
					return `\n"${safe_str_from_cps([a])}" ${hex_cp(a)} ‚Üí "${safe_str_from_cps([b])}" ${hex_cp(b)}`
				}).join(''),
				click() {
					input_field.value = sloppy;
					resolve();
				}
			}));
		}

		let tokens = ens_tokenize(name); 

		// if there are disallowed characters
		if (tokens.some(x => x.type === 'disallowed')) {
			try {
				ens_normalize(stripped);
			} catch (err) {
				// and they aren't just whitespace
				add_row_tag(row, create('button', {
					innerHTML: '‚ùå Remove Disallowed',
					click() {
						input_field.value = str_from_cps(tokens.flatMap(t => t.type === 'nfc' ? t.tokens0 : t).flatMap(t => {
							switch (t.type) {
								case 'disallowed': return [];
								case 'valid': return t.cps;
								case 'emoji': return t.input;
								default: return t.cp;
							}
						}));
						resolve();
					}
				}));	
			}
		}

		// if there are normalizable parts
		if (tokens.some(x => x.type === 'nfc' || x.type === 'ignored' || x.type === 'mapped' || (x.type === 'emoji' && x.input.includes(0xFE0F)))) {
			add_row_tag(row, create('button', {
				innerHTML: 'üí™Ô∏è Force Normalize',
				click() {
					input_field.value = str_from_cps(tokens.flatMap(token => {
						switch (token.type) { 
							case 'ignored': return []; // removes ignored (dangerous)
							case 'mapped': // applies known mappings 
							case 'emoji': // removes FE0F from known emoji
							case 'nfc':
							case 'valid': return token.cps;
							default: return token.cp;
						}
					}));
					resolve();
				}
			}));
		}
	}
}

function add_transformed_row(input) {
	if (ens_tokenize(input).some(x => x.type === 'nfc' || x.type === 'mapped')) {
		let row = create_row('Transform');
		row.classList.add('transform');
		make_detailed(row);
		make_exploded(row, input, true);
		output_div.append(row);
	}
}

function create_dns_row(name, replaced, contenthash) {
	let row = create_row(replaced ? 'Alternative DNS' : 'DNS');
	row.classList.add('dns');
	try {
		const MAX_LABEL = 63;
		const MAX_NAME = 253; 
		const VALID_REGEX = /^[-0-9a-z]*$/i;
		let encoded = name.split('.').map(label => {
			let cps = explode_cp(label);
			try {
				let encoded = puny_encoded(cps);//.toLowerCase();
				if (!VALID_REGEX.test(encoded)) {
					let first = [...encoded].find(ch => !VALID_REGEX.test(ch));
					throw new Error(`unsupported ASCII: "${safe_str_from_cps(explode_cp(first))}"`);
				}
				if (encoded === label) {
					if (label.startsWith('xn--')) throw new Error('punycode literal');
					if (label.slice(2, 4) === '--') throw new Error('invalid label extension');
					// 20230123: WHATWG URL uses "CheckHyphens" false
					//if (label.startsWith('-')) throw new Error('leading hyphen');
					//if (label.endsWith('-')) throw new Error('trailing hyphen');
				}
				if (encoded.length > MAX_LABEL) throw new Error(`too long: ${encoded.length} > ${MAX_LABEL}`);
				return encoded;
			} catch (err) {
				throw new Error(`Invalid label "${safe_str_from_cps(cps)}": ${err.message}`);
			}
		}).join('.');
		if (encoded.length > MAX_NAME) {
			throw new Error(`Name too long: ${encoded.length} > ${MAX_NAME}`);
		}
		let browser;
		try {
			browser = new URL(`https://${name}`).host;
		} catch (ignored) {
		}
		row.append(create_main_span(encoded));
		add_row_tag(row, create_copy_btn(encoded));
		if (encoded === name) {
			if (encoded === browser) {
				add_row_tag(row, create_tag('good', 'Verbatim'));
			} else {
				add_row_tag(row, create_tag('warn', 'Mangled'));
				if (encoded) {
					// TODO: decide what to show
				}
			}
		} else if (!browser || browser !== encoded) {
			add_row_tag(row, create_tag('stop', 'Incompatible'));
			if (browser) {
				add_row_tag(row, create_copy_btn(browser));
			}
			if (!replaced) {
				add_alternative_btn(row, name);
			}
		} else {
			add_row_tag(row, create_tag('star', 'Compatible'));
		}
		if (name.includes('\u200D')) {
			add_row_tag(row, create_tag('warn', 'ZWJ'));
		}
		if (active_chain.is_mainnet) {
			if (encoded.endsWith('.eth')) {
				if (contenthash) {
					add_row_tag(row, create_link(`https://${encoded}.limo`, {button: '‚ÜóÔ∏è Website', className: 'external'}));
				} else {
					add_row_tag(row, create_link(`https://${encoded}.limo`, {innerHTML: '.limo', className: 'external'}));
				}
				add_row_tag(row, create_link(`https://${encoded}.link`, {innerHTML: '.link', className: 'external'}));
				add_row_tag(row, create_link(`https://${encoded}.li`,   {innerHTML: '.li',   className: 'external'}));
				add_row_tag(row, create_link(`https://${encoded}.xyz`,  {innerHTML: '.xyz',  className: 'external'}));
				add_row_tag(row, create_link(`https://${encoded}.co`,   {innerHTML: '.co',   className: 'external'}));
			} else {
				add_row_tag(row, create_link(`https://${encoded}`, {button: '‚ÜóÔ∏è Website', className: 'external'}));
			}
		}
		add_row_tag(row, create_link(`../../punycode.js/test/demo.html#${encoded?'p':'u'}=${encoded || name}`, {button: '‚úÖÔ∏è Check'}));
	} catch (err) {
		row.classList.add('invalid');
		add_row_tag(row, create_tag('fail', err));
		if (!replaced) {
			add_alternative_btn(row, name);
		}
	}	
	return row;
	
}

// try some transformations
function add_alternative_btn(row, name) {
	let alt = name;
	try {
		alt = ens_beautify(alt);
	} catch (err) {
	}
	alt = str_from_cps(explode_cp(name).map(cp => {
		if (cp >= 0x660 && cp <= 0x669) {
			return cp + 0x90; // try other arabic digits
		} else {
			return cp;
		}
	}));
	if (alt !== name) {
		add_row_tag(row, create('button', {
			innerText: 'ü•àÔ∏è Try Alternative',
			click() {
				row.replaceWith(create_dns_row(alt, true));
			}
		}));
	}
}

function is_safe_ascii(cp) {
	// same as:
	//return !should_escape(cp) && cp != 0x20;
	return cp >= 0x21 && cp <= 0x7E;
}
function unicode_escape_cp(cp) {
	let hex = hex_cp(cp);
	return hex.length > 4 ? `\\u{${hex}}` : `\\u${hex.padStart(4, '0')}`; // be nice
}
function unicode_escape(s) {
	return explode_cp(s).map(unicode_escape_cp).join('');
}
function entity_escape(s) {
	return explode_cp(s).map(cp => is_safe_ascii(cp) ? String.fromCodePoint(cp) : `&#x${hex_cp(cp)};`).join('');
}
// escape where escape_fn is true (default: non-ascii)
// unicode: use \u-format
function apply_escapes_where(s, escape_fn, unicode) {
	if (!escape_fn) escape_fn = cp => !is_safe_ascii(cp);
	return explode_cp(s).map(cp => {
		return escape_fn(cp) ? unicode ? unicode_escape_cp(cp) : quote_cp(cp) : String.fromCodePoint(cp);
	}).join('');
}
function replace_escapes(s) {
	// match: \u{HEX}, {HEX}, \uXXXX, [0xHEX], [DEC]
	return s.replace(/(?:(?:(?:\\u)?\{([0-9a-f]+)\}|\\u([0-9a-f]{4}))|(?:\[((?:0x[0-9a-f]+)|[0-9]+)\]))/uig, (_, hex1, hex2, num) => {
		try {
			return String.fromCodePoint(num ? parseInt(num) : parseInt(hex1 || hex2, 16)); 
		} catch (err) {
			return 'ÔøΩ';
		}
	});
}
function encode_uri_component_ens_escaped(s) {
	return s.split('.').map(x => {
		try {
			if (ens_normalize(x) === x) {
				return encodeURIComponent(x);
			}
		} catch (err) {
		}
		return `[${labelhash(x).slice(2)}]`; // support unlinkable/unnormalized stuff
	}).join('.');
}
function encode_uri_component_surrogate_escaped(s) {
	return encodeURIComponent(apply_escapes_where(s, is_surrogate));
}
function create_link(url, {button, ...args} = {}) {
	let a = create('a', {
		href: url,
		target: '_blank',
		innerText: url,
		...args
	});
	if (button) a.replaceChildren(create('button', {innerHTML: button}));
	try {
		new URL(url, window.location.href);
	} catch (err) {
		a.classList.add('invalid');
	}
	return a;
}
function create_ens_link(name, innerHTML = '<button>üõ†Ô∏è ENS</button>') {
	try {
		if (ens_normalize(name) === name) {
			return create_link(`https://app.ens.domains/${encode_uri_component_ens_escaped(name)}`, {innerHTML, className: 'ens'});
		}
	} catch (err) {
	}
}
function create_ens_metadata_link(contract, token) {
	return create_link(`${active_chain.metadata}/${contract}/${token}`, {button: 'üè∑Ô∏è Metadata', className: 'metadata'});
}
function create_etherscan_address_link(addr, {innerHTML, anchor = '', contract, className} = {}) {
	if (!innerHTML) {
		innerHTML = addr;
		className = 'addr';
	}
	if (contract && !anchor) anchor = '#readContract';
	return create_link(`${active_chain.explorer}/address/${addr}${anchor}`, {innerHTML, className});
}
function create_jazz_icon(address) {
	let i = ADDRESS_MAP.get(address);
	if (!i || debug) ADDRESS_MAP.set(address, i = ADDRESS_MAP.size + 1);
	return create('span', {innerHTML: i, className: ['jazz', `addr${i}`]});
}

function make_click_copy(el, raw) {
	el.addEventListener('click', e => {
		let copy = raw;
		if (e.altKey) {
			copy = explode_cp(copy).map(hex_cp).join(' ');
		} else if (e.shiftKey) {
			copy = bytes_from_utf8(copy).map(hex_cp).join(' ');
		} 
		const cls = 'copied';
		document.querySelectorAll(`.${cls}`).forEach(x => x.classList.remove(cls));
		navigator.clipboard.writeText(copy);
		el.classList.add(cls);
		setTimeout(() => el.classList.remove(cls), 2000);
	});
	return el;
}

function create_copy_btn(raw, {small, value} = {}) {
	let btn = create('button', {className: 'copy'});
	make_click_copy(btn, raw);
	if (small) btn.classList.add('small');
	if (value) {
		btn.title = raw;
	} else {
		let cps = explode_cp(raw);
		btn.title = [
			raw,
			cps.map(hex_cp).join(' '),
			`[ALT] Codepoints (${cps.length})`,
			`[SHIFT] UTF-8 Bytes (${bytes_from_utf8(raw).length})`,
		].join('\n');
	}
	return btn;
}
function reverse_name(addr) {
	return `${addr.slice(2).toLowerCase()}.${REVERSE_DOMAIN}`;
}
function create_reverse_resolve_btn(addr) {
	return create_resolve_btn(reverse_name(addr), '‚Ü©Ô∏è Reverse Record');
}
function create_resolve_btn(name, innerHTML = '‚Ü©Ô∏è Resolve') {
	return create('button', {
		innerHTML,
		title: name,
		click() {
			input_field.value = name;
			resolve();
		}
	});
}
function create_main_span(text) {
	return create('span', null, create('span', {innerText: text, className: ['main', 'long']}));
}
function create_pretty_tag() {
	return create('span', {innerHTML: PRETTY_NAME, title: 'Beautified Form', className: 'clean'});
}
function upgrade_split_type(info) {
	if (info.type === 'Latin') {
		let cps = info.tokens.flatMap(x => x.is_emoji ? [] : x); // ascii+emoji
		if (cps.every(cp => cp < 0x80)) {
			info.type = 'ASCII';
		}
	} 
	info.confusing = determine_confusion(str_from_cps(info.input), flatten_tokens(info.tokens));
}

function flatten_tokens(tokens) {
	return tokens.flatMap(t => t.is_emoji ? String.fromCodePoint(...t) : t);
}

// from https://raffy.antistupid.com/eth/ens-regs.html
function determine_confusion(label, flat) {
	let match;
	if (/[ƒÖ√ßƒô≈ü√¨√≠√Æ√Ø«ê≈Ç]/u.test(label)) {
		return 'Rare';
	} else if (/l\d{2,}/i.test(label) || /\d{2,}l/i.test(label)) {
		return 'Digits+L';
	} else if (has_repeated_run(flat, 10)) {
		return 'Many';
	} else if (match = get_similar_emoji(flat)) {
		return match;
	} else if (/^0x[0-9a-f]{18,}/i.test(label)) {
		return 'Address-like';
	}
}

function has_repeated_run(flat, thres) {
	let prev, count;
	for (let x of flat) {
		if (prev !== x) {
			prev = x;
			count = 1;
		} else if(++count >= thres) {
			return true;
		}
	}
}

function get_similar_emoji(flat) {
	let set = new Set(flat.filter(x => typeof x === 'string'));
	if (!set.size) return;
	let conflicts = [
		['üá∫üá∏', ['üá∫üá≤']]
	];
	for (let [primary, similar] of conflicts) {
		let p = set.has(primary);
		let n = similar.reduce((a, x) => a + +set.has(x), 0);
		if (p && n || n > 1) {
			return `Mixed ${primary}`;
		} else if (!p && n) {
			return `Uncommon ${primary}`;
		}
	}
}

function make_normalized(row, name) {
	row.classList.add('normalized');
	let span = create('span', {
		title: 'Normalized Form',
		innerHTML: `‚úÖÔ∏è`,
		className: 'normalized',
	});
	let split = ens_split(name);
	if (split.length > 1 && split[split.length-1].type === 'ASCII') {
		split.pop(); // remove ASCII TLD
	}
	let pure_ascii = split.every(x => x.type === 'ASCII');
	split.forEach(upgrade_split_type);
	if (pure_ascii) {
		span.classList.add('ascii');
		span.innerHTML += ` ASCII`; 
	} else {
		let types = new Set(split.map(x => x.type));
		if (types.has('Latin') && types.has('ASCII')) {
			types.delete('ASCII');
		}
		if (split.some(x => x.emoji)) {
			types.add('Emoji');
		} else {
			types.delete('Emoji');
		}
		span.innerHTML += ` ${[...types].sort().join('+')}`;
	}
	if (split.some(x => x.confusing)) {
		add_row_tag(row, create_tag('confusing', 'Possibly<br>Confusing'));
	}
	add_row_tag(row, span);	
}

function make_detailed(el) {
	el.classList.add('detailed');
	let hide = !show_details_check.checked;
	if (el.dataset.reversed) hide = !hide;
	el.classList.toggle('hide', hide);
}
function make_locked(row) {
	row.classList.add('locked');
}
function make_contract(row) {
	row.classList.add('contract');
}
function make_exploded(row, name, is_norm, components) {	
	let before = !is_norm;
	let tokens_div = create_tokens_div(name, before, components);
	let old = row.querySelector('.exploded');
	if (old) {
		old.replaceWith(tokens_div);
	} else {
		row.append(tokens_div);
	}
}

function create_ethmoji_row(tokens, suffix) {
	let row = create_row('Ethmoji');
	row.classList.add('category', 'ethmoji');
	make_detailed(row);
	let tally = new Map();
	let last;
	for (let token of tokens) {
		let form = str_from_cps(token.emoji);
		let rec = tally.get(form);
		if (!rec) {
			rec = {form, count: 0, ...token};
			tally.set(form, rec);
		}
		++rec.count;
	}
	tally = [...tally.values()];
	let formula = create('div', {className: 'formula'});
	for (let rec of tally.values()) {
		formula.append(create_link(`./emoji.html#q=${str_from_cps(rec.cps)}`, {innerHTML: `${rec.form}<sup>${rec.count}</sup>`}));
	}
	row.append(formula);
	let span_grade = create('span');
	let min_repeated;
	if (tokens.every(t => t.emoji[2] == 0x20E3)) {
		if (tokens.length == 2) {
			add_row_tag(row, create_tag('fire', 'Shortest Keycaps'));
		} else {
			add_row_tag(row, create_tag('star', 'Keycaps'));
		}
	} else if (tally.length == 1) {
		let ncp = tally[0].cps.length;
		let repeat = 1 + Math.max(0, MIN_ETH_LENGTH - ncp);
		if (tally[0].count === repeat) {
			add_row_tag(row, create_tag('fire', repeat == 1 ? 'Single' : 'Shortest'));
		} else {
			if (tally[0].count > 1) {
				add_row_tag(row, create_tag('star', 'Repeated'));
			}
			min_repeated = str_from_cps(tally[0].cps).repeat(repeat);
		}
	} else {
		add_row_tag(row, `Unique: ${tally.length}`);
	}
	// if (tokens.every((x, i) => x.form == tokens[tokens.length-1-i].form)) {
	// 	add_row_tag(row, create_palindrome_tag());
	// }
	if (min_repeated) {
		add_row_tag(row, create_resolve_btn(min_repeated + suffix, '‚Ü©Ô∏è Shortest'));
	}
	return row;
}

function create_digits_row(norm, group, values, negative, suffix) {
	let row = create_row('Integer'); // `${name0} Digits`
	row.classList.add('category', 'integer');
	make_detailed(row);
	let sign = negative ? '-' : '';
	let form = sign + values.join('');
	row.append(create('code', {innerText: form, className: ['main', 'long']}));
	if (values.length == (negative ? 2 : 3)) {
		add_row_tag(row, create_tag('fire', 'Shortest'));
	}
	if (values.every((x, i) => x == values[0])) {
		add_row_tag(row, create_tag('star', `Repeated (${values.length})`));
	}
	if (negative) {
		add_row_tag(row, 'Negative');
	} else if (values.length > 1 && values.every((x, i) => x == values[values.length-1-i])) {
		add_row_tag(row, create_palindrome_tag());
	}	
	let pad = 0;
	while (values[pad] === 0) pad++;
	if (pad) {
		add_row_tag(row, `Zero Pad (${pad})`);
	}
	let btn = create_resolve_btn((negative ? KEYCAP_MINUS : '') + values.map(keycap).join('') + suffix, KEYCAP_NAME);
	btn.disabled = group === KEYCAP_NAME;
	add_row_tag(row, btn);
	for (let [name, digits] of DIGITS_MAP) {
		//if (name0 === name) continue;
		let btn = create_resolve_btn(sign + values.map(x => digits.charAt(x)).join('') + suffix, name);
		btn.disabled = group === name;
		add_row_tag(row, btn);
	}
	return row;
}

async function add_contract_name(row, address) {
	let name = RESOLVER_NAMES[address];
	if (active_chain.is_mainnet && name) {
		add_row_tag(row, create_tag('good', name));
	} else if (!await is_contract(address)) {
		add_row_tag(row, create_tag('fail', 'Not a Contract'));
	}
}

function add_old_tag(row, name, is_norm) {
	const OLD_NAME = 'ENSIP-1';
	let span = create('span', {className: ['tags', 'old']});
	try {
		let norm0 = eth_ens_namehash.normalize(name);
		let norm;
		try {
			norm = ens_normalize(name);
		} catch (err) {
		}
		let html = OLD_NAME;
		if (!is_norm && norm0 !== norm) { // diff-norm
			html += `: ‚ö†Ô∏è<b>Diff Norm</b>`;
		}
		if (norm0 === name) {
			span.innerHTML = `‚úÖÔ∏è ${html}`;
		} else {
			if (norm === norm0) throw new Error('not normalized');
			add_row_tag(row, create_resolve_btn(norm0, `‚ùåÔ∏è ${html}`));
			return;
		}
	} catch (err) {
		span.innerHTML = `‚ùåÔ∏è ${OLD_NAME}`;
		span.title = err.message;
	}
	add_row_tag(row, span);
}

function add_nft_links(row, name, contract, token) {
	add_row_tag(row, create_ens_metadata_link(contract, token));
	add_row_tag(row, create_link(`${active_chain.explorer}/nft/${contract}/${BigInt(token)}`, {innerHTML: 'Etherscan', className: 'external'}));
	if (active_chain.opensea) {
		add_row_tag(row, create_link(`${active_chain.opensea}${contract}/${BigInt(token)}`, {innerHTML: OPENSEA_NAME, className: 'external'}));
	}
	if (!active_chain.is_mainnet) return;
	try {
		let encoded = encodeURIComponent(name);
		if (encoded.endsWith('.eth')) {
			add_row_tag(row, create_link(`https://www.ens.vision/name/${encoded.slice(0, -4)}`, {innerHTML: VISION_NAME, className: 'external'}));
		}
		add_row_tag(row, create_link(`http://predomain.eth.limo/#/domain/${encoded}`, {innerHTML: 'Predomain', className: 'external'}));
	} catch (err) {
	}
}

async function add_avatar(row, resolver) {
	try {
		let {url, linkage} = await resolver._getAvatar();
		if (!url) return;
		try {
			url = new URL(url).toString().replaceAll('#', '%23'); // i forget why im doing this
		} catch (ignored) {
		}
		let img = new Image();
		img.src = url;
		let a = create_link(url, {className: 'avatar'});
		a.replaceChildren(img);
		row.append(a);
		let avatar = linkage.find(x => x.type === 'avatar');
		resolver._avatar = avatar.value || url;
	} catch (err) {
		console.log('Avatar error', avatar, err);
	}
}

// https://github.com/adraffy/keccak.js/blob/main/src/utils.js#L96
function bytes_from_utf8(s) {
	if (typeof s !== 'string') throw new TypeError('expected string');
	let v = [];
	for (let pos = 0, len = s.length; pos < len; ) {
		let cp = s.codePointAt(pos++);
		if (cp < 0x800) {
			if (cp < 0x80) {
				v.push(cp);
			} else {
				v.push(0xC0 | (cp >> 6), 0x80 | (cp & 0x3F));
			}
		} else {
			if (cp < 0x10000) {
				v.push(0xE0 | (cp >> 12), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
			} else {
				v.push(0xF0 | (cp >> 18), 0x80 | ((cp >> 12) & 0x3F), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
				pos++;
			}
		}
	}
	return Uint8Array.from(v);
}
function utf8_from_bytes(v) {
	let cps = [];
	for (let i = 0, n = v.length; i < n; ) {
		let x = v[i++];
		if (x < 0x80) {
			cps.push(x);
		} else if (x < 0xE0) {
			cps.push(((x & 0x1F) << 6) | req_utf8_cont(v, i++));
		} else if (x < 0xF0) {
			cps.push(((x & 0x0F) << 12) | (req_utf8_cont(v, i++) << 6) | req_utf8_cont(v, i++));
		} else {
			cps.push(((x & 0x07) << 18) | (req_utf8_cont(v, i++) << 12) | (req_utf8_cont(v, i++) << 6) | req_utf8_cont(v, i++));
		}
	}
	return str_from_cps(cps);
}
function req_utf8_cont(v, i) {
	let x = v[i];
	if ((x & 0xC0) != 0x80) throw new Error(`malformed utf8 at ${i}: expected continuation`);
	return x & 0x3F;
}
function create_tokens_div(name, before, components) {
	// tokenize each label separately so we can show major/minor errors
	// flatten non-errors tokens into wrapper
	let split = ens_split(name);
	let wrapper = create('div', {className: ['tokens', 'exploded']});
	let first = true;
	for (let i = 0; i < split.length; i++) {
		if (i > 0) {
			wrapper.append(...dom_from_tokens(ens_tokenize('.')).children); 
		}
		let {input, error} = split[i];
		let tokens = dom_from_tokens(ens_tokenize(str_from_cps(input)), {
			before, 
			emoji_url,
			components: components || show_components_check.checked,
			tld_class: i == split.length-1
		});
		if (error) {
			tokens.classList.add('error');
			if (first) {
				tokens.classList.add('first');
				first = false;
			}
			wrapper.append(tokens);
		} else {
			wrapper.append(...tokens.children);
		}
	}
	wrapper.dataset.name = name;
	if (before) wrapper.dataset.before = 1;
	if (components) wrapper.dataset.components = 1;
	return wrapper;
}

function update_exploded() {
	for (let x of output_div.querySelectorAll('.exploded')) {
		let tokens_div = create_tokens_div(x.dataset.name, x.dataset.before, x.dataset.components);
		if (x.dataset.downgraded) {
			apply_downgrade(tokens_div);
		}
		x.replaceWith(tokens_div);
	}
}

function apply_downgrade(tokens_div) {
	tokens_div.dataset.downgraded = '1';
	for (let x of tokens_div.querySelectorAll('.disallowed')) {
		x.classList.add('ignored');
		x.classList.remove('disallowed');
	}
}

function add_reg_exp_tags(row, exp, now) {
	let span = create_tag('reg', `‚úçÔ∏è Registered until ${new Date(exp).toLocaleDateString()}`);
	add_row_tag(row, span);
	if (exp - now < 45 * 86400) {
		add_row_tag(row, create_tag('warn', `Expires in ${format_dur(exp - now)}`));
	} else {
		span.innerHTML += ` (${format_dur(exp - now)})`;
	}
}

function create_palindrome_tag() {
	return create_tag('good', '‚áÑ');
}

function apply_class(el, ...cls) {
	for (let x of cls) {
		if (x) el.classList.add(...x.trim().split(/\s+/));
	}
	return el;
}

function create_tag(type, value) {
	if (!value) return;
	let span = create('span', {className: 'tags'});
	if (value instanceof Error) {
		value = value.message;
		span.classList.add('long');
	}
	switch (type) {
		case 'star': 
			type = 'attn';
			value = `‚≠êÔ∏è ${value}`;
			break;
		case 'norm':
			span.dataset.reversed = '1';
			make_detailed(span);
			// fallthru
		case 'warn':
			type = 'note';
			value = `‚ö†Ô∏è ${value}`;
			break;
		case 'fire':
			value = `üî•Ô∏è ${value}`;
			break;
		case 'fail': 
			value = `‚ùåÔ∏è ${value}`;
			break;
		case 'stop':
			type = 'fail';
			value = `üõëÔ∏è ${value}`;
			break;
	}
	span.innerHTML = value;
	span.classList.add(type);
	return span;
}

function create_namehash_breakdown(name) {
	let node = namehash(name);
	let div = create('div', {className: 'hash'});
	div.append(create_link(`../../keccak.js/test/demo.html#algo=namehash&s=${encode_uri_component_surrogate_escaped(name)}&escape=1`, {innerHTML: 'Namehash:'}));
	div.append(create('code', {innerHTML: node, className: 'long'}));
	div.append(create_copy_btn(node, {small: true, value: true}));
	return div;
}

function create_breakdown_row(name, before) {
	let outer = create('div', {className: 'breakdown'});
	make_detailed(outer);
	outer.append(create_namehash_breakdown(name));
	let split = ens_split(name);
	for (let i = 0; i < split.length; i++) {
		let info = split[i];
		info.index = i;
		info.cps = before || !info.output ? info.input : info.output;
		info.label = str_from_cps(info.cps);
	}
	for (let info of split) {
		let row = create('div', {className: 'label'});

		row.append(create_tag('index', info.index+1));

		let span_name = document.createElement('span');
		span_name.classList.add('name', 'long');
		if (info.label) {
			span_name.innerText = info.label;
			row.append(span_name);
			row.append(create_copy_btn(info.label, {small: true}));
		}
		if (info.error) {
			row.classList.add('error');
			row.append(create('span', {innerText: `‚ùåÔ∏è ${info.error.message}`, className: 'error'}));
		} else if (compare_arrays(info.input, info.output)) { // mapped or nfc
			row.classList.add('mapped');
			row.append(create_tag('note', 'Unnormalized'));
		} else {
			row.classList.add('valid');
			upgrade_split_type(info);
			if (info.confusing) {
				row.append(create_tag('confusing', info.confusing));
			}
			if (info.type.startsWith('Restricted[')) {
				let script = info.type.slice(11, -1);
				row.append(create_link(`https://www.compart.com/en/unicode/scripts/${script}`, {innerHTML: `‚ö†Ô∏è ${script} (Restricted)`, className: ['tags', 'restricted']}));
			} else if (info.type !== 'Emoji') {
				row.append(create_tag('type', info.type));
			}
			if (info.emoji) {
				row.append(create_tag('emoji', 'Emoji'));
			}
		}
		if (info.label) {
			row.append(create_tag('length', info.cps.length));
			if (info.emoji || info.type !== 'ASCII') {
				let v = bytes_from_utf8(info.label);
				row.append(create_tag('bytes', v.length));
			}
		}
		outer.append(row);

		let hash = labelhash(info.label);
		let hash_div = document.createElement('div');
		hash_div.classList.add('hash', 'minor');
		hash_div.append(create_link(`../../keccak.js/test/demo.html#algo=keccak-256&s=${encode_uri_component_surrogate_escaped(info.label)}&escape=1`, {innerHTML: 'Labelhash:'}));
		hash_div.append(create('code', {innerText: hash, className: 'long'}));
		hash_div.append(create_copy_btn(hash, {small: true, value: true}));
		outer.append(hash_div);
		
		let parent = split.slice(info.index + 1).map(x => x.label).join('.');
		if (NFT_DOMAINS.has(parent)) {
			let token = BigInt(hash).toString();
			let token_div = document.createElement('div');
			token_div.classList.add('hash', 'minor');
			token_div.append(create('b', {innerText: 'Token:'}));
			token_div.append(create('code', {innerText: token, className: 'long'}));
			token_div.append(create_copy_btn(token, {small: true, value: true}));
			outer.append(token_div);
		}
	}
	return outer;
}

function create_row(label, waiting) {
	let row = document.createElement('div');
	row.classList.add('row');
	if (label) {
		let span = document.createElement('span');
		span.classList.add('row-label');
		if (typeof label === 'string') {
			span.innerHTML = `${label}:`;
		} else {
			span.append(label);
		}
		row.append(span);
	}
	if (waiting) {
		row.append(create('div', {innerHTML: '<div class="spinner"></div>', className: 'temporary'}));
	}
	return row;
}

function remove_temporary(row) {
	for (let x of row.querySelectorAll('.temporary')) {
		x.remove();
	}
}

function add_row_tag(row, tag) {
	if (!tag) return;
	if (typeof tag === 'string') {
		tag = create('span', {innerHTML: tag});
	}
	tag.classList.add('tags');
	row.append(tag);
	return tag;
}

function trim_trailing_decimal_zeros(s) {
	return s.includes('.') ? s.replace(/\.?0*$/, '') : s;
}
function format_dur(t) {
	if (t < 1000) return `${Math.ceil(t)}ms`;
	t /= 1000;
	let unit;
	if (t < 60) {
		unit = 's';
	} else {
		t /= 60;
		if (t < 60) {
			unit = 'm';
		} else {
			t /= 60;
			if (t < 24) {
				unit = 'h';
			} else {
				t /= 24;
				if (t < 365) {
					unit = 'd';
				} else {
					t /= 365;
					unit = 'y';
				}
			}
		}
	}
	return trim_trailing_decimal_zeros(t.toFixed(1)) + unit;
}

function is_working() {
	return resolve_btn.disabled || !registry_contract;
}
function resolve() {
	if (!registry_contract) return;
	if (is_working()) {
		resolve_timer = [0]; // ASAP
		return;
	}
	clearTimeout(resolve_timer);
	resolve_timer = RESOLVE_MODE_IDLE;
	ADDRESS_MAP.clear();
	let input = input_field.value;
	let skip = skip_norm_check.checked;
	// replace marketplace URL with token:XXX
	if (input.includes('://')) {
		try {	
			let url = new URL(input);
			if (url.host === 'ens.vision' || url.host === 'www.ens.vision') {
				// https://ens.vision/name/%F0%9F%91%A9%F0%9F%8F%BC%E2%80%8D%F0%9F%A6%BC%E2%80%8D%E2%AC%85
				let v = url.pathname.toLowerCase().split('/').filter(x => x);
				if (v.length >= 2 && v[0] === 'name') {
					input = decodeURIComponent(v[1]);
					if (!input.endsWith('.eth')) input += '.eth';
					input_field.value = input;
				}
			} else { 
				// generalized handler
				// https://opensea.io/assets/ethereum/0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401/65925476150180752387929572463320899353544457962160224303512375154243473029563
				// https://opensea.io/assets/ethereum/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				// https://www.gem.xyz/asset/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				// https://element.market/assets/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				let v = url.pathname.toLowerCase().split('/').filter(x => x);
				if (v.length >= 2 && /^[a-f0-9]+$/i.test(v[v.length-1])) {
					// TODO: fix this, use ensure_nft() and ensure_wrapper() 
					if (v[v.length-2] === '0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85') {
						input_field.value = input = `token:${v[v.length-1]}`;
					} else if (v[v.length-2] === '0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401') {
						input_field.value = input = `wrapped:${v[v.length-1]}`;
					}
				}
			}
		} catch (err) {
		}
	}
	let match;
	// replace token:XXX with ens subgraph label (or fail)
	if (match = input.match(/^(?:labelhash|token):(0x[a-f0-9]+|[0-9]+)$/i)) {
		let hash = ethers.zeroPadValue(match[1], 32);
		resolve_btn.disabled = true;
		return (async() => {
			try {
				if (!active_chain.is_mainnet) throw new Error(`token: only works on mainnet`);
				let res = await fetch('https://api.thegraph.com/subgraphs/name/ensdomains/ens', {
					method: 'POST',
					body: JSON.stringify({
						query: `{domains(where:{labelhash:"${hash}"}){labelName}}`
					})
				});
				if (!res.ok) throw new Error(`HTTP Error ${r.status}`);
				let {data: {domains}} = await res.json();
				if (!domains.length) throw new Error(`Unknown labelhash preimage: ${hash}`);
				let label = domains[0].labelName;
				if (!label) throw new Error(`Unknown labelhash preimage: ${hash}`);
				let hash0 = labelhash(label);
				if (hash0 !== hash) throw new Error(`Incorrect labelhash preimage: "${label}")\n\nExpected: ${hash}\nComputed: ${hash}`);
				input_field.value = `${label}.eth`;
				setTimeout(resolve, 0);
			} catch (err) {
				window.alert(err.message);
				stop_resolving();
			}
			resolve_btn.disabled = false;
		})();
	} else if (match = input.match(/^(?:namehash|wrapped):(0x[a-f0-9]+|[0-9]+)$/i)) {
		let hash = ethers.zeroPadValue(match[1], 32);
		resolve_btn.disabled = true;
		return (async () => {
			try {
				await ensure_wrapper();
				let v = ethers.getBytes(await wrapper_contract.names(hash));
				if (!v.length) throw new Error(`Unknown namehash preimage: ${hash}`);
				input_field.value = labels_from_encoded_dns(v).join('.');
				resolve_btn.disabled = false;
				setTimeout(resolve, 0);
			} catch (err) {
				window.alert(err.message);
				stop_resolving();
			}
			resolve_btn.disabled = false;
		})();
	}
	// input convenience: expand range
	if (match = input.match(/^range:([0-9a-f]+)\.\.([0-9a-f]+)$/i)) {
		let lo = parseInt(match[1], 16);
		let hi = parseInt(match[2], 16);
		if (hi >= lo) {
			input = str_from_cps(Array(1 + hi - lo).fill().map((_, i) => lo + i));
		}
	}
	// input convenience: HEX HEX HEX => {HEX}{HEX}
	if (/^\s*[0-9a-f]{2,}(\s+[0-9a-f]{2,})+\s*$/i.test(input)) { 
		input = input.trim().split(/\s+/).map(x => `{${x}}`).join('');	
	}
	// input convenience: entities
	input = input.replace(/&#?[0-9a-z]+;/gui, x => {
		entity_span.innerHTML = x;
		return apply_escapes_where(entity_span.innerText);
	});
	input_field.value = input;
	let name = replace_name(replace_escapes(input));
	add_recent(name);
	if (!parse() && (!input || !skip)) {
		primary_loader.classList.add('hide');
		return;
	}
	resolve_btn.disabled = true;
	primary_loader.classList.remove('hide');
	resolve_t0 = Date.now();
	resolve1(name, skip).then(() => {
		resolve_btn.disabled = false;
		if (Array.isArray(resolve_timer)) {
			setTimeout(resolve, Math.max(0, resolve_timer[0] - Date.now()));
		} else {
			primary_loader.classList.add('hide');
		}
	});
}

function create_elapsed() {
	let now = Date.now();
	let delta = now - resolve_t0;
	if (!delta) return; // 0ms is stupid
	resolve_t0 = now;
	return create('span', {innerHTML: format_dur(delta), className: 'elapsed'});
}

async function resolve1(input, skip_norm) {
	output_div.innerHTML = '';
	//output_div.append(links_copy);

	let input_is_address = is_checksum_address(input);
	let input_row;
	let normed_row;
	let reverse_row;
	let name_norm;
	let norm_err;

	if (input_is_address) {
		input_row = create_row('Address');
		input_row.append(create_jazz_icon(input));
		input_row.append(create_etherscan_address_link(input));
		add_row_tag(input_row, create_copy_btn(input, {value: true}));
		add_row_tag(input_row, create_reverse_resolve_btn(input));
		add_owner_links(input_row, input);

		let rev_name = reverse_name(input);

		let rev_details = document.createElement('div');
		rev_details.classList.add('breakdown', 'reverse');
		make_detailed(rev_details);
		let rev_div = create('div', {innerHTML: `<b>Reverse Name:</b> <code class="long">${rev_name}</code>`, className: 'hash'});
		rev_div.append(create_copy_btn(rev_name, {small: true, value: true}));
		rev_details.append(rev_div, create_namehash_breakdown(rev_name));
		output_div.append(input_row, rev_details);

		let resolver_row = create_row('Reverse Resolver', true);
		output_div.append(resolver_row);

		if (await is_contract(input)) make_contract(input_row);
		if (should_stop_resolving()) return;

		let resolver, last_err;
		try {
			resolver = await get_resolver(rev_name);
		} catch (err) {	
			last_err = err;
		} 
		if (should_stop_resolving()) return;
		remove_temporary(resolver_row);	
		add_row_tag(resolver_row, create_elapsed());

		if (reverse_registrar === null) {
			try {
				reverse_registrar = await registry_contract.owner(namehash(REVERSE_DOMAIN));
			} catch (err) {
				reverse_registrar = false;
			}
			if (should_stop_resolving()) return;
		}
		if (reverse_registrar) {
			add_row_tag(input_row, create_etherscan_address_link(reverse_registrar, {
				contract: true, 
				anchor: '#writeContract#F7',
				innerHTML: '<button class="glow">‚úçÔ∏è Set Name</button>'
			}));
		}

		if (last_err) {
			resolver_row.classList.add('error');
			add_row_tag(resolver_row, create_tag('warn', last_err));
			return;
		} else if (!resolver) {
			add_row_tag(resolver_row, create_tag('stop', 'Primary Not Set'));
			return;
		}
		
		resolver_row.append(create_etherscan_address_link(resolver.address, {contract: true}));
		add_row_tag(resolver_row, create_copy_btn(resolver.address, {value: true}));
		await add_contract_name(resolver_row, resolver.address);
		if (should_stop_resolving()) return;

		reverse_row = normed_row = create_row('Reverse', true);
		output_div.append(reverse_row);
		let primary;
		[{data: primary, error: last_err}] = await fetch_records(resolver, [{type: 'name'}]);
		if (should_stop_resolving()) return;
		remove_temporary(reverse_row);
		add_row_tag(reverse_row, create_elapsed());
		if (last_err) {
			reverse_row.classList.add('error');
			add_row_tag(reverse_row, create_tag('warn', last_err));
			return;
		} else if (!primary) {
			add_row_tag(reverse_row, create_tag('stop', 'Primary is Null'));
			return;
		}

		make_exploded(reverse_row, primary, false);
		add_row_tag(reverse_row, create_copy_btn(primary));
		add_row_tag(reverse_row, create_ens_link(primary));
		//add_nft_links(reverse_row, primary);
		output_div.append(create_breakdown_row(primary, true));
			
		try {
			name_norm = ens_normalize(primary);
		} catch (err) {
			reverse_row.classList.add('error');
			add_row_tag(reverse_row, create_tag('norm', err));
			if (!skip_norm) return;
			name_norm = primary;
			norm_err = err;
		}
		if (!norm_err) {
			if (name_norm === primary) {
				add_row_tag(reverse_row, create_resolve_btn(primary));
				make_normalized(reverse_row, name_norm);
			} else {
				add_row_tag(reverse_row, create_tag('fail', 'Normalized'));
				let row = normed_row = create_row('Normalized Reverse');
				make_exploded(row, name_norm, true);
				add_row_tag(row, create_copy_btn(name_norm));
				add_row_tag(row, create_resolve_btn(name_norm));
				make_normalized(row, name_norm);
				output_div.append(row);
				output_div.append(create_breakdown_row(name_norm));
			}	
		}
	} else {
		
		// the input is a name
		input_row = normed_row = create_row(INPUT_NAME);
		input_row.classList.add('input');
		make_exploded(input_row, input, false);
		add_row_tag(input_row, create_ens_link(input));
		output_div.append(input_row);
		output_div.append(create_breakdown_row(input, true));
		add_row_tag(input_row, create_copy_btn(input));

		if (/^0x[0-9a-f]{40}$/i.test(input)) {
			add_row_tag(input_row, create_resolve_btn(ethers.getAddress(input.toLowerCase()), 'üõ†Ô∏è Fix Checksum'));
		}
		if (!input.includes('.')) {
			add_row_tag(input_row, create_resolve_btn(`${input}.eth`, 'üîÑÔ∏è Add <b>".eth"</b>'));
		}

		try {
			name_norm = ens_normalize(input);
		} catch (err) {
			input_row.classList.add('error');
			add_row_tag(input_row, create_tag('norm', err));
			if (!skip_norm) return; // i think this is always true
			name_norm = input;
			norm_err = err;
		}	

		if (!norm_err) {
			if (name_norm === input) {
				make_normalized(input_row, name_norm);
				//make_exploded(input_row, input, false); 
			} else  { 
				add_row_tag(input_row, create_tag('fail', 'Normalized'));
				if (skip_norm) {
					name_norm = input;
				} else {
					add_transformed_row(input);
					let row = normed_row = create_row('Normalized');
					make_exploded(row, name_norm, true);
					make_normalized(row, name_norm);
					add_row_tag(row, create_copy_btn(name_norm));
					add_row_tag(row, create_resolve_btn(name_norm));
					add_row_tag(row, create_ens_link(name_norm));
					//add_nft_links(row, name_norm);
					add_old_tag(row, name_norm, true);
					output_div.append(row);
					output_div.append(create_breakdown_row(name_norm));
				}
			}
		}
		add_old_tag(input_row, input);
	}

	let sep_pos = name_norm.indexOf('.');
	if (sep_pos == -1) sep_pos = name_norm.length;
	if (sep_pos > 0) {
		let prefix = name_norm.slice(0, sep_pos);
		let suffix = name_norm.slice(sep_pos); 
		let tokens = ens_tokenize(prefix);
		if (tokens.every(t => t.type === 'emoji')) {
			input_row.after(create_ethmoji_row(tokens, suffix));
			let negative = str_from_cps(tokens[0].emoji) == KEYCAP_MINUS;
			if (negative) tokens = tokens.slice(1);
			let values = tokens.map(x => x.emoji[0] - 0x30);
			if (values.every(x => x >= 0 && x < 10)) {
				input_row.after(create_digits_row(name_norm, KEYCAP_NAME, values, negative, suffix));
			}
		} else {
			let negative = prefix.startsWith('-');
			if (negative) prefix = prefix.slice(1);
			if (prefix) {
				let cps = explode_cp(prefix);
				let digits = cps.map(cp => DIGIT_MAP.get(cp));
				if (digits.every(x => x)) {
					let values = digits.map(x => x.i);
					let name0 = digits[0].name;
					if (digits.every(x => x.name === name0)) {
						//if (digits[0].reversed) values.reverse(); // LTR
						input_row.after(create_digits_row(name_norm, name0, values, negative, suffix));
					} else {
						let first = digits[0].mixed;
						if (first && digits.every(x => x.mixed == first)) {
							let row = create_digits_row(name_norm, 'Arabic', values, negative, suffix); //values.reverse()); // LTR
							add_row_tag(row, create_tag('warn', 'Mixed Digits'));
							input_row.after(row);
						} else {
							let row = create_digits_row(name_norm, 'Numeric', values, negative, suffix);
							add_row_tag(row, create_tag('warn', 'Multiple Scripts'));
							input_row.after(row);
						}
					}
				}
			}
		}
	}

	if (!skip_norm && !norm_err) {
		let pretty = ens_beautify(name_norm);
		let row = create_row(`Beautified`);
		row.classList.add('pretty');
		row.append(create_main_span(pretty));
		add_row_tag(row, create_copy_btn(pretty));
		if (input !== pretty) {
			add_row_tag(row, create_resolve_btn(pretty));
		}
		add_row_tag(row, create_pretty_tag());
		if (input === pretty) { 
			add_row_tag(input_row, create_pretty_tag());
			add_row_tag(row, create_tag('good', 'Same as Input'));
		} else if (name_norm === pretty) {			
			add_row_tag(normed_row, create_pretty_tag());
			add_row_tag(row, create_tag('good', 'Same as Norm'));
		}
		add_old_tag(row, pretty);
		output_div.append(row);
	}

	output_div.append(create_dns_row(name_norm));

	// at this point, we have a name
	// lookup the name
	let resolver, resolver_err;
	let resolver_row = create_row('Resolver', true);
	output_div.append(resolver_row);
	try {
		resolver = await get_resolver(name_norm);
	} catch (err) {
		if (!is_address_type_error(err)) {
			resolver_err = err;
		}
	}
	if (should_stop_resolving()) return;
	remove_temporary(resolver_row);	
	add_row_tag(resolver_row, create_elapsed());
	
	if (resolver_err) {
		resolver_row.classList.add('error');
		add_row_tag(resolver_row, create_tag('warn', resolver_err));
	} else if (resolver) { 
		add_avatar(normed_row, resolver); 
		resolver_row.append(create_etherscan_address_link(resolver.address, {contract: true}));
		add_row_tag(resolver_row, create_copy_btn(resolver.address, {value: true}));
		if (resolver._wildcard) {
			add_row_tag(resolver_row, create_tag('special', 'Wildcard'));
			if (resolver._basename === name_norm) {
				add_row_tag(resolver_row, 'Basename');
			} else {
				add_row_tag(resolver_row, create_resolve_btn(resolver._basename, `‚Ü©Ô∏è ${resolver._basename}`));
			}
		} else {
			add_contract_name(resolver_row, resolver.address);
			if (should_stop_resolving()) return;
		}
	} else {
		add_row_tag(resolver_row, create_tag('warn', `Not Set`));	
	}

	let parent_domain = name_norm.slice(sep_pos+1);
	let nft_backed = NFT_DOMAINS.has(name_norm.slice(sep_pos+1));
	let nft_contract;
	let nft_token;

	let avail_row;
	let available;	
	if (parent_domain === 'eth') {
		let eth_label = name_norm.slice(0, sep_pos);
		nft_token = labelhash(eth_label);
		let avail_err;
		let expiry;
		let len = Array.from(eth_label).length;
		avail_row = create_row('Availability', true);
		let premium;
		output_div.append(avail_row);
		try {
			await ensure_eth_nft();
			if (should_stop_resolving()) return;
			nft_contract = eth_nft_contract;
			if (len >= MIN_ETH_LENGTH) {
				available = await eth_nft_contract.available(nft_token);
				if (should_stop_resolving()) return;
				expiry = Number(await eth_nft_contract.nameExpires(nft_token));
				if (available) {
					if (should_stop_resolving()) return;
					premium = await price_oracle_contract.premium(eth_label, expiry, 0);
				}
			}
		} catch (err) {
			avail_err = err;
		}
		remove_temporary(avail_row);
		if (should_stop_resolving()) return;
		add_row_tag(avail_row, create_elapsed()); 
		add_row_tag(avail_row, create_tag('length', len));

		if (avail_err) {
			avail_row.classList.add('error');
			add_row_tag(avail_row, create_tag('warn', avail_err));
		} else if (available === undefined) {
			add_row_tag(avail_row, create_tag('fail', `Too Short`));
			let padded = Array(1 + Math.max(0, MIN_ETH_LENGTH - len)).fill(eth_label).join('');
			add_row_tag(avail_row, create_resolve_btn(`${padded}.eth`, '‚Ü©Ô∏è Repeat until 3+'));
		} else if (available) {
			add_row_tag(avail_row, create_ens_link(name_norm, '<button class="glow">üëåÔ∏è Available to Register</button>'));
			let ether = parseFloat(ethers.formatEther(premium));
			if (ether) {
				add_row_tag(avail_row, create_tag('warn', `${ether.toFixed(ether < 1 ? 4 : 2)}Œû Premium`));
			}
			//add_row_tag(avail_row, create_typed_tag('fire', 'Available'));
			//add_row_tag(avail_row, create_ens_link(name_norm, {title: 'Register'}));
		} else {
			let exp = expiry * 1000;
			let end = exp + eth_nft_contract.grace_period;
			let now = Date.now();
			if (now >= exp && now <= end) {
				add_row_tag(avail_row, create_tag('warn', `Grace period (${format_dur(eth_nft_contract.grace_period)}) ends in ${format_dur(end - now)}`));
			} else {
				add_reg_exp_tags(avail_row, exp, now);
			}
		}
		if (nft_contract) {
			let span = avail_row.querySelector('.row-label');
			span.title = `Grace: ${format_dur(nft_contract.grace_period)}\nPremium: ${format_dur(price_oracle_contract.premium_period)}`;
		}
	} else if (nft_backed) {
		let label = name_norm.slice(0, sep_pos);
		nft_token = labelhash(label);
		let avail_url;
		let avail_err;
		avail_row = create_row('Availability', true);
		output_div.append(avail_row);
		try {
			let address = await registry_contract.owner(namehash(parent_domain));
			if (should_stop_resolving()) return;
			if (is_null_hex(address)) throw new Error('Missing backing contract');
			nft_contract = new ethers.Contract(address, [
				'function available(uint256 id) external view returns(bool)',
				'function ownerOf(uint256 id) external view returns (address)',
			], active_provider);
			available = await nft_contract.available(nft_token); //.catch(() => {});
			if (active_chain.is_mainnet && parent_domain === 'art') {
				avail_url = `https://protocol.art/api/art-tokens?exact=${encodeURIComponent(label)}`;
				if (available) {
					try {
						let res = await fetch(avail_url);
						let {Items} = await res.json();
						available = !Items.length;
					} catch (ignored) {
					}
				}
			}
		} catch (err) {
			avail_err = err;
		}
		remove_temporary(avail_row);
		if (should_stop_resolving()) return;
		add_row_tag(avail_row, create_elapsed()); 
		add_row_tag(avail_row, create_tag('length', Array.from(label).length));
		if (nft_contract) {
			let old = avail_row.querySelector('.row-label');
			old.replaceChildren(create_etherscan_address_link(nft_contract.target, {innerHTML: old.innerHTML, contract: true}));
		}
		if (avail_err) {
			avail_row.classList.add('error');
			add_row_tag(avail_row, create_tag('warn', avail_err));
		} else {
			add_row_tag(avail_row, create_tag(available ? 'good' : 'fail', 'Available'));
			if (avail_url) {
				add_row_tag(avail_row, create_link(avail_url, {button: 'üîçÔ∏è Details', className: 'external'}));
			}
		}
	}
	
	// get the owner
	let is_wrapped, owner, nft_owner;
	if ((!resolver || resolver._basename === name_norm) && (!nft_backed || available !== undefined)) { 
		let node = namehash(name_norm);
		let wrapped_row = create_row('Wrapper', true);
		let unwrappable;
		try {
			encoded_dns_from_labels(name_norm);
		} catch (err) {
			unwrappable = true;
		}
		if (!available) {
			output_div.append(wrapped_row);			
			let wrapped_err;
			try {
				await ensure_wrapper();
				if (should_stop_resolving()) return;
				if (!unwrappable) {
					is_wrapped = await wrapper_contract.isWrapped(node);
				}
			} catch (err) {
				wrapped_err = err;
			}
			if (should_stop_resolving()) return;
			if (wrapped_err) {
				wrapped_row.classList.add('error');
				add_row_tag(wrapped_row, create_tag('warn', wrapped_err));
			} else if (unwrappable) {
				add_row_tag(wrapped_row, create_tag('warn', 'Unwrappable'));
			} else if (!is_wrapped) {
				add_row_tag(wrapped_row, 'Unwrapped');
			}
			if (wrapper_contract) {
				let old = wrapped_row.querySelector('.row-label');
				old.replaceChildren(create_etherscan_address_link(wrapper_contract.target, {innerHTML: old.innerHTML, contract: true}));
			}
			if (is_wrapped) {
				add_nft_links(normed_row, name_norm, wrapper_contract.target, node);
			} else if (nft_contract) {
				add_nft_links(normed_row, name_norm, nft_contract.target, nft_token);
			}
		} else if (unwrappable) {
			output_div.append(wrapped_row);
			add_row_tag(wrapped_row, create_tag('stop', 'Unwrappable'));
		}
		remove_temporary(wrapped_row);
		add_row_tag(wrapped_row, create_elapsed());

		// there doesn't seem to be an "owner"
		//owner = await resolver._fetch('0x02571be3'); // owner(bytes32)
		//owner = await resolver._fetch('0x38a699a4'); // exists(bytes32)
		//owner = await resolver._fetch('0x7dd56411'); // ownerOf(bytes32)
		let owner_row = create_row(available ? 'Previous Owner' : 'Owner', true);
		let owner_err;
		let checked_nft;
		output_div.append(owner_row);
		try {
			if (is_wrapped) {
				let data = await wrapper_contract.getData(node);
				if (should_stop_resolving()) return;
				owner = data.owner;
				let now = Date.now();
				let exp = Number(data.expiry) * 1000;
				let fuses = Number(data.fuses);
				if (debug) fuses = 0x7FFFF;
				if (fuses & 0x10000) { // PARENT_CANNOT_CONTROL 
					if (fuses & 0x00001) { // CANNOT_UNWRAP 
						add_row_tag(wrapped_row, create_tag('good', 'üîíÔ∏è Locked')); 
					} else {
						add_row_tag(wrapped_row, create_tag('good', 'üïäÔ∏è Emancipated'));
					}
					if (!(fuses & 0x20000)) { // !IS_DOT_ETH 
						add_reg_exp_tags(wrapped_row, exp, now); // note: this includes grace for .eth subs
						if (fuses & 0x40000) { // CAN_EXTEND_EXPIRY => no approval needed
							add_row_tag(wrapped_row, create_tag('note', '‚û°Ô∏è Extendable by anyone'));
						} else {
							add_row_tag(wrapped_row, create_tag('warn', 'Extension requires approval'));
						}
					}
				} else {
					add_row_tag(wrapped_row, create_tag('good', 'üéÅÔ∏è Wrapped')); // ‚ôæÔ∏è
				}
				if (fuses & 0x00002) add_row_tag(wrapped_row, 'üö´Ô∏è Burn Fuses');
				if (fuses & 0x00004) {
					add_row_tag(wrapped_row, 'üö´Ô∏è Transfer');
					make_locked(owner_row);
				}
				if (fuses & 0x00008) {
					add_row_tag(wrapped_row, 'üö´Ô∏è Set Resolver');
					make_locked(resolver_row);
				}
				if (fuses & 0x00010) add_row_tag(wrapped_row, 'üö´Ô∏è Set TTL');
				if (fuses & 0x00020) add_row_tag(wrapped_row, 'üö´Ô∏è Subdomain');
				if (fuses & 0x00040) add_row_tag(wrapped_row, 'üö´Ô∏è Approve');
			} else {
				owner = await registry_contract.owner(node);
				if (should_stop_resolving()) return;
				if (is_null_hex(owner)) owner = false;
				if (!owner && nft_contract) {
					checked_nft = true;
					owner = await nft_contract.ownerOf(nft_token).catch(() => {});
					if (is_null_hex(owner)) owner = false;
				}
			}
		} catch (err) {
			owner_err = err;
		}
		if (should_stop_resolving()) return;
		if (await is_contract(owner)) make_contract(owner_row);
		remove_temporary(owner_row);
		if (should_stop_resolving()) return;
		add_row_tag(owner_row, create_elapsed());
		if (owner_err) {
			owner_row.classList.add('error');
			owner_row.append(create_tag('warn', owner_err));
		} else if (!owner) {
			if (available) {
				add_row_tag(owner_row, create_tag('reg', 'üåªÔ∏è Not Set'));
			} else {
				add_row_tag(owner_row, create_tag('warn', 'Not Set'));
			}
		} else {
			owner_row.classList.add(available ? 'old' : 'owner');
			owner_row.append(create_etherscan_address_link(owner));
			add_row_tag(owner_row, create_copy_btn(owner, {value: true}));
			//owner_row.classList.toggle('old', available);
			// if the input was an address, we can validate
			if (input_is_address) {
				add_row_tag(reverse_row, create_tag(owner === input ? 'good' : 'fail', 'Owned'));
				if (owner === input) {
					add_row_tag(owner_row, 'Same as Input');
				}
			}
			if (owner !== input) {
				add_row_tag(owner_row, create_resolve_btn(owner));
				add_owner_links(owner_row, owner);
			}
			if (active_chain.is_mainnet && parent_domain === 'art') {
				add_row_tag(avail_row, create_link(`https://protocol.art/account/${owner}`, {button: 'üõ†Ô∏è Configure', className: 'external'}));
			}
			if (!is_wrapped && !available && !checked_nft && nft_contract) {
				let nft_row = create_row(create_etherscan_address_link(nft_contract.target, {innerHTML: `${NFT_OWNER_NAME}:`, contract: true}), true);
				nft_row.classList.add('nft');
				output_div.append(nft_row);
				try {
					await ensure_eth_nft();
					nft_owner = await nft_contract.ownerOf(nft_token);
					if (is_null_hex(nft_owner)) nft_owner = false;
				} catch (err) {
				}
				if (should_stop_resolving()) return;
				if (nft_owner && nft_owner !== owner) {
					owner_row.querySelector('.row-label').innerText = `${MANAGER_NAME}:`;
					owner_row.insertAdjacentElement('beforebegin', nft_row); // move up
					nft_row.append(create_jazz_icon(nft_owner));
					let a = create_etherscan_address_link(nft_owner);
					nft_row.append(a);
					add_row_tag(nft_row, create_copy_btn(nft_owner, {value: true}));
					try {
						let norm = await get_safe_primary(nft_owner, owner);
						if (should_stop_resolving()) return;
						if (norm.endsWith('.' + name_norm)) { // proper subdomain
							nft_owner = norm; // swap
							let sub = norm.slice(0, -(name_norm.length + 1));
							a.innerHTML = `<b>${ens_beautify(sub)}</b>.${ens_beautify(name_norm)}`;
							add_row_tag(nft_row, create_tag('good', 'Subdomain'));
						} else {
							a.innerHTML = ens_beautify(norm);
							//add_row_tag(nft_row, create_typed_tag('good', 'Owned'));
						}
					} catch (err) {
					}
					if (nft_owner !== input) {
						add_row_tag(nft_row, create_resolve_btn(nft_owner));
					}					
					add_owner_links(nft_row, nft_owner);
					add_row_tag(nft_row, create_elapsed());
					remove_temporary(nft_row);
					nft_row.classList.toggle('old', !!available);
				} else {
					nft_row.remove();
				}
			}
			owner_row.append(create_jazz_icon(owner));
		}
	}

	if (resolver && !NOT_IFACE_RESOLVER.has(resolver.address)) {
		let row = create_row(create_link('https://docs.ens.domains/contract-api-reference/.eth-permanent-registrar#discovery', {innerHTML: 'Interfaces:'}), true);
		output_div.append(row);	
		let contract = contract_for_resolver(resolver);
		// https://docs.ens.domains/contract-api-reference/.eth-permanent-registrar	
		const TITLE_WRAPPER = '<b>Wrapper</b> ERC-1155';
		const TITLE_NFT = '<b>NFT</b> ERC-721';
		let interfaces = [
			//{iface: IFACE_ETH_NFT, name: 'NFT'},  
			{iface: '0x019a38fe', title: TITLE_WRAPPER},
			{iface: IFACE_ETH_CONTROLLER, title: '<b>Controller</b>'},
			{iface: '0x018fac06', title: '<b>Old Controller</b>'},
			{iface: '0x6ccb2df4', name: TITLE_NFT},
			{iface: '0x7ba18ba1', title: '<b>Migration</b>'},
		];
		let discovered = new Set();
		function add_iface(html, addr) {
			if (is_null_hex(addr)) return;
			if (discovered.has(addr)) return;
			discovered.add(addr);
			html += ` <code class="prefix">${addr.slice(0, 6)}</code>`;
			add_row_tag(row, create_etherscan_address_link(addr, {innerHTML: html, contract: true, className: 'iface'}));
		}
		try {
			// https://github.com/ensdomains/ens-contracts/blob/dev/contracts/resolvers/profiles/IInterfaceResolver.sol
			if (!await contract.supportsInterface('0x124a319c')) {
				throw new Error('not EIP-165');
			}
			for (let {iface, title} of interfaces) {
				let addr = await contract.get_interface(iface);
				if (is_null_hex(addr)) continue;
				if (!discovered.size) {
					add_iface(TITLE_NFT, owner);
				}
				add_iface(`${title} <code>${iface.slice(2)}</code>`, addr);
				if (iface === IFACE_ETH_CONTROLLER) {
					let controller = contract_for_controller(addr);
					let oracle = contract_for_price_oracle(await controller.prices());
					add_iface('<b>Price Oracle</b>', oracle.address);
					add_iface('<b>USD Oracle</b>', await oracle.usdOracle());
					add_iface(TITLE_WRAPPER, await controller.nameWrapper());
					//add_iface('DAO Wallet', await contract.owner().catch(() => ''));
				}
			}
		} catch (err) {
			if (discovered.size) {
				add_row_tag(row, create_tag('warn', err));
			}
		}
		if (should_stop_resolving()) return;
		if (discovered.size) {
			remove_temporary(row);
			add_row_tag(row, create_elapsed()); 
		} else {
			row.remove();
			NOT_IFACE_RESOLVER.add(resolver.address);
		}
	}

	// add address
	let address;
	if (resolver) {
		let address_err;
		let address_row = create_row(`ETH Address`, true);
		address_row.classList.add(available ? 'old' : 'addr');
		output_div.append(address_row);	
		try {
			address = await fetch_addr60(resolver);
		} catch (err) {
			address_err = err;
			console.log(err);
		}
		if (should_stop_resolving()) return;
		if (await is_contract(address)) make_contract(address_row);
		if (should_stop_resolving()) return;
		if (address_err) {
			address_row.classList.add('error');
			add_row_tag(address_row, create_tag('warn', address_err));
		} else if (!address) {
			add_row_tag(address_row, create_tag('warn', 'Not Set'));
		} else {
			address_row.append(create_jazz_icon(address));
			address_row.append(create_etherscan_address_link(address));
			address_row.append(create_copy_btn(address, {value: true}));
			if (input_is_address) {
				if (address === input) {
					add_row_tag(input_row, create_tag('fire', 'Primary'));
					add_row_tag(address_row, 'Same as Input');
				} else if (address) {
					add_row_tag(address_row, create_resolve_btn(address));
					add_row_tag(address_row, create_tag('warn', 'Different from Owner'));	
				}
			// } else if (owner !== address && nft_owner !== address) {
			// 	add_row_tag(address_row, create_resolve_btn(address));
			// 	if (owner) {
			// 		add_row_tag(address_row, create_typed_tag('fail', 'Owner'));	
			// 	}
			// 	add_owner_links(address_row, address); 
			} else if (owner === address) {
				if (nft_owner && nft_owner !== address) {
					add_row_tag(address_row, create_tag('good', `Same as ${MANAGER_NAME}`));	
				} else {
					add_row_tag(address_row, create_tag('good', 'Same as Owner'));
				}
			} else if (nft_owner === address) {
				add_row_tag(address_row, create_tag('good', `Same as ${NFT_OWNER_NAME}`));
			} else {
				add_row_tag(address_row, create_resolve_btn(address));
				if (owner) {
					add_row_tag(address_row, create_tag('fail', 'Owner'));	
				}
				add_owner_links(address_row, address);
			}
		}
		remove_temporary(address_row);
		add_row_tag(address_row, create_elapsed());	

		if (show_records_check.checked) {
			let records_row = create_row(create_link('https://docs.ens.domains/contract-api-reference/publicresolver', {innerHTML: 'Records:'}), true);
			records_row.classList.add('records');
			if (available) records_row.classList.add('old');
			output_div.append(records_row);	
			let old = records_row.childElementCount;
			for (let {rec, data, error} of await fetch_records(resolver, RECORDS)) {
				if (error) continue;
				//if (error) return create_typed_tag('warn', error);
				let a = document.createElement('a');
				a.classList.add('record');
				switch (rec.type) {
					// https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/profiles/IAddressResolver.sol
					// https://docs.ens.domains/ens-improvement-proposals/ensip-9-multichain-address-resolution
					// https://docs.ens.domains/ens-improvement-proposals/ensip-11-evmchain-address-resolution
					case TYPE_ADDR: {
						if (is_null_hex(data))  continue;
						a.classList.add('rtrim');
						a.innerHTML = rec.icon || `<b>coin(${rec.coin})</b>`;
						try {
							let v = ethers.getBytes(data);
							let address;
							if (rec.evm) {
								address = ethers.getAddress(data);
							} else if (rec.btc) {
								address = format_btc_address(v, rec.btc);
							} else if (rec.bech32) {
								address = new Bech32(rec.bech32.hrp, convert(v, 8, 5, true), rec.bech32.type).toString();
							} else {
								address = rec.decode(v);
							}
							a.append(create('span', {innerHTML: address, className: ['addr', 'long']}));
							if (rec.url) {
								a.append(create_link(rec.url(address), {button: 'üîçÔ∏è'}));
							}
							make_click_copy(a, address);
							a.title = `${address}\nCoinType: ${rec.coin}`;
						} catch (err) {
							a.append(create_tag('fail', err));
							a.append(create_copy_btn(data));
						}
						records_row.append(a);
						break;
					}
					// https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/profiles/ITextResolver.sol
					case TYPE_TEXT: {
						data = data.trim();
						if (!data) continue;
						if (rec.url) {
							a.target = '_blank';
							a.href = rec.url(data);
						} else {
							make_click_copy(a, data);
							a.title = data;
						}
						a.innerHTML = rec.icon || `<b>${rec.key}</b>`;
						let text = rec.format ? rec.format(data) : data;
						if (text) {
							a.append(create('span', {innerText: text, className: text.length > 32 ? 'long' : null}));
						}
						break;
					}
					// https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/profiles/IPubkeyResolver.sol
					case 'pubkey': {
						let [x, y] = data;
						if (is_null_hex(x)) continue;
						a.innerHTML = `<b>pubkey</b>`;
						a.append(make_click_copy(create('button', {innerText: 'x', title: x}), x));
						a.append(make_click_copy(create('button', {innerText: 'y', title: y}), y));
						break;
					}
					// https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/profiles/IContentHashResolver.sol
					// https://docs.ens.domains/ens-improvement-proposals/ensip-7-contenthash-field
					// https://github.com/multiformats/multicodec/blob/master/table.csv
					case 'contenthash': { 
						if (is_null_hex(data))  continue;
						a.innerHTML = `<b>${rec.type}</b>`;
						a.classList.add('rtrim');
						let buf = ethers.getBytes(data);
						let decoded, url;
						try {
							let [proto, pos] = uvarint.read(buf);
							buf = buf.subarray(pos);
							switch (proto) {
								//case 0xE2: // IPLD
								case 0xE3: { // IPFS
									let cid = CID.from(buf);
									decoded = cid.toString();
									if (cid.codec !== 0x70) throw new Error('not dag-pb');
									a.append(create_link(`https://${decoded}.ipfs2.eth.limo/`, {button: 'üÜîÔ∏è IPFS'}));
									a.append(create_check_cid_btn(decoded));
									url = `ipfs://${decoded}`;
									break;
								}
								case 0xE5: { // IPNS
									let cid = CID.from(buf);
									decoded = cid.toString('k'); // base36 for urls
									if (cid.codec !== 0x72) throw new Error('not libp2p-key');
									a.append(create_link(`https://${decoded}.ipfs2.eth.limo/`, {button: '‚ÜóÔ∏è IPNS'}));
									a.append(create_check_cid_btn(decoded));
									url = `ipns://${decoded}`;
									break;
								}
								case 0xE4: { // Swarm
									// https://docs.ethswarm.org/docs/develop/access-the-swarm/upload-and-download
									// https://gateway.ethswarm.org/access/
									let cid = CID.from(buf);
									decoded = cid.toString();
									if (cid.codec !== 0xFA) throw new Error('not swarm-manifest');
									a.append(create_link(`https://${decoded}.bzz.link/`, {button: 'Swarm'}));
									a.append(create_check_cid_btn(decoded));
									url = `bzz://${decoded}`;
									break;
								}
								//case 0xE8: // DNSLink 
								case 0x1BC:   // onion
								case 0x1BD: { // onion v3 
									// https://www.tor2web.org/
									// https://blog.torproject.org/v3-onion-services-usage/
									if (buf.length != 16 && buf.length != 56) throw new Error('bad length');
									decoded = Base36.encode(buf);
									a.append(create_link(`https://${decoded}.onion.to/`, {button: 'Onion'}));
									url = `onion://${decoded}`;
									break;
								}
								case 0xB19910: { // skylink
									// https://support.skynetlabs.com/key-concepts/skylinks
									decoded = Base64URL.encode(buf);
									if (decoded.length != 46) throw new Error('bad length');
									a.append(create_link(`https://siasky.net/${decoded}`, {button: 'Skylink'}));
									url = `sia://${decoded}`;
									break;
								}
								case 0xB29910: { // arweave
									// https://docs.arweave.org/developers/arweave-node-server/http-api
									if (buf.length != 32) throw new Error('not sha256');
									decoded = Base64URL.encode(buf);
									a.append(create_link(`https://arweave.net/${decoded}`, {button: 'Arweave'}));
									a.append(create_link(`https://viewblock.io/arweave/tx/${decoded}`, {button: '‚úÖÔ∏è Check'}));
									url = `arweave://${decoded}`;
									break;
								}
							}
							a.append(create_copy_btn(url, {value: true}));

							// upgrade the limo link
							document.querySelector('.row.dns').replaceWith(create_dns_row(name_norm, false, true));

						} catch (err) {
							a.append(create_tag('fail', err));
							a.append(make_click_copy(create('button', {innerText: 'Data', title: data}), data));
							if (decoded) {
								a.append(make_click_copy(create('button', {innerText: 'Decoded', title: decoded}), decoded));
							}
						}
						break;
					}
				}
				records_row.append(a);
			}
			if (records_row.childElementCount === old) {
				add_row_tag(records_row, 'None');
			}
			if (resolver._multicall) {
				add_row_tag(records_row, create_tag('good', 'Multicall'));
			}
			if (should_stop_resolving()) return;
			remove_temporary(records_row);
			add_row_tag(records_row, create_elapsed());	
		}
	}

	if (input_is_address || !address) return; // nothing more to do

	// lookup primary from eth address 
	let primary, primary_err;
	let primary_row = create_row('Primary', true);	
	output_div.append(primary_row);
	//primary_row.append(create_jazz_icon(address)); // only true in the forward direction
	try {
		primary = await active_provider.lookupAddress(address);
		if (debug) primary = primary.toUpperCase();
	} catch (err) {
		primary_err = err;
	}
	remove_temporary(primary_row);
	if (should_stop_resolving()) return;
	add_row_tag(primary_row, create_elapsed());

	primary_row.classList.toggle('old', !!available);
	
	if (primary_err) {
		primary_row.classList.add('error');
		add_row_tag(primary_row, create_tag('warn', primary_err));
		return;
	}
	if (!primary) {
		add_row_tag(primary_row, create_tag('warn', 'Not Set'));
		return;
	}

	// primary exists
	make_exploded(primary_row, primary, false);

	// lets check if it's normalized
	let primary_norm;
	try {
		primary_norm = ens_normalize(primary);
		if (primary === primary_norm) {
			make_normalized(primary_row, primary_norm);
		}
		// note: dont add extra junk if its the same
		if (primary === input) {
			add_row_tag(primary_row, 'Same as Input');
		} else if (primary === name_norm) {		
			add_row_tag(primary_row, 'Same as Norm');
		} else {
			if (primary === ens_beautify(primary)) {
				add_row_tag(primary_row, create_pretty_tag());
			}
			add_row_tag(primary_row, create_copy_btn(primary_norm));
			add_row_tag(primary_row, create_resolve_btn(primary));
			add_old_tag(primary_row, primary);
			//add_row_tag(primary_row, create_ens_link(primary_norm));
			let details_row = create_breakdown_row(primary, true);
			details_row.classList.toggle('old', !!available);
			output_div.append(details_row);
		}
	} catch (err) {
		primary_row.classList.add('error');
		add_row_tag(primary_row, create_tag('norm', err));
		add_old_tag(primary_row, primary);
	}

	// primary was valid but not normalized
	if (primary_norm && primary !== primary_norm) {
		add_row_tag(primary_row, create_tag('fail', 'Normalized'));
		// create norm row
		let row = create_row('Normalized Primary');
		row.classList.toggle('old', !!available);
		make_exploded(row, primary_norm, true);
		make_normalized(row, primary_norm);
		//add_row_tag(row, create_ens_link(primary_norm));
		//add_nft_links(row, primary_norm);
		if (primary_norm === input) {
			add_row_tag(row, 'Same as Input');
		} else {
			if (name_norm !== primary_norm) {
				add_row_tag(row, create_resolve_btn(primary_norm));
			}
			add_row_tag(row, create_copy_btn(primary_norm));
			add_old_tag(row, primary_norm, true);
			if (primary_norm === ens_beautify(primary_norm)) {
				add_row_tag(row, create_pretty_tag());
			}
		}
		output_div.append(row);
		let details_row = create_breakdown_row(primary_norm);
		details_row.classList.toggle('old', !!available);
		output_div.append(details_row);
	}	

	if (primary_norm && name_norm === primary_norm) {
		if (owner === address) {
			add_row_tag(normed_row, create_tag('fire', 'Primary Owner'));
		} else {
			add_row_tag(normed_row, create_tag('good', 'Primary'));
		}
	}
}

function create_check_cid_btn(cid) {
	return create_link(`https://cid.ipfs.tech/#${cid}`, {button: '‚úÖÔ∏è Check'});
}

function add_owner_links(row, owner) {	
	add_row_tag(row, create_link(`${active_chain.is_mainnet ? 'https://opensea.io/' : 'https://testnets.opensea.io/'}${owner}?tab=collected`, {innerHTML: OPENSEA_NAME, className: 'external'}));
	if (active_chain.is_mainnet) {
		add_row_tag(row, create_link(`https://ens.vision/0x/${owner}`, {innerHTML: VISION_NAME, className: 'external'}));	
	}	
	add_row_tag(row, create_link(`https://rainbow.me/${owner}`, {innerHTML: 'Rainbow', className: 'external'}));
	add_row_tag(row, create_link(`https://debank.com/profile/${owner}`, {innerHTML: 'Debank', className: 'external'}));
}
async function fetch_addr60(resolver) {
	let [{data: address, error}] = await fetch_records(resolver, [{type: TYPE_ADDR, coin: 60}]);
	if (error) throw error;
	if (!is_null_hex(address)) return ethers.getAddress(address);
}
async function fetch_records(resolver, records) {
	if (resolver._wildcard && !resolver._dns) return []; // unreachable
	const options = {enableCcipRead: true};
	let contract = contract_for_resolver(resolver);
	if (records.length > 1) {
		let encoded = records.map(rec => {
			let frag = contract.interface.getFunction(rec.type);
			let params = [contract._node];
			switch (rec.type) {
				case TYPE_TEXT: params.push(rec.key); break;
				case TYPE_ADDR: params.push(rec.coin); break;
			}
			return contract.interface.encodeFunctionData(frag, params);
		});
		try {
			let res;
			if (resolver._wildcard) { // optimistic CCIP-multicall
				let frag = contract.interface.getFunction('multicallWithNodeCheck');
				res = await contract.resolve(resolver._dns, contract.interface.encodeFunctionData(frag, [contract._node, encoded]), options);
				[res] = contract.interface.decodeFunctionResult(frag, res);
			} else if (await can_multicall()) {
				res = await multicall_contract.tryAggregate(false, encoded.map(data => ({target: resolver.address, data})));
				res = res.map(({success, data}) => success ? data : null);
			}
			if (res && res.length === records.length) {
				resolver._multicall = true;
				return records.map((rec, i) => {
					try {
						let frag = contract.interface.getFunction(rec.type);
						let data = contract.interface.decodeFunctionResult(frag, res[i]);
						if (frag.outputs.length === 1) data = data[0];
						return {rec, data};
					} catch (error) {
						return {rec, error};
					}
				});
			}
		} catch (err) {
		}
	}
	return Promise.all(records.map(async rec => {
		if (rec.key === 'avatar' && resolver._avatar) { // add_avatar() probably already computed
			return {rec, data: resolver._avatar}; 
		}		
		if (!resolver._wildcard && rec.type === TYPE_ADDR && rec.coin === 60) { // try boomer method first
			try {
				let data = await contract.addr(contract._node);
				return {rec, data};
			} catch (err) {
			}
		} 
		let params = [contract._node];
		switch (rec.type) {
			case TYPE_TEXT: params.push(rec.key); break;
			case TYPE_ADDR: params.push(rec.coin); break;
		}
		try {
			let data;
			if (resolver._wildcard) {
				let frag = contract.interface.getFunction(rec.type);
				data = await contract.resolve(resolver._dns, contract.interface.encodeFunctionData(frag, params), options);
				data = contract.interface.decodeFunctionResult(frag, data);
				if (frag.outputs.length === 1) data = data[0];
			} else {
				data = await contract[rec.type](...params, options);
			}
			return {rec, data};
		} catch (error) {
			return {rec, error};
		}
	}));
}
async function ensure_eth_resolver() {
	if (eth_resolver_contract) return;
	if (eth_resolver_contract === false) throw new Error(`No "eth" resolver`);	
	let resolver = await get_resolver('eth');
	if (!resolver) {
		eth_resolver_contract = false;
		return ensure_eth_resolver(); 
	}
	eth_resolver_contract = contract_for_resolver(resolver);
}
function contract_for_resolver(resolver) {
	// https://github.com/ensdomains/ens-contracts/tree/staging/contracts/resolvers/profiles
	let contract = new ethers.Contract(resolver.address, [
		'function supportsInterface(bytes4 interfaceID) external view returns (bool)',
		'function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address)',
		'function resolve(bytes name, bytes data) view returns (bytes)',
		'function addr(bytes32 node, uint coinType) view returns (bytes)',
		'function addr(bytes32 node) view returns (address)',
		'function text(bytes32 node, string key) view returns (string)',
		'function contenthash(bytes32 node) view returns (bytes)',
		'function pubkey(bytes32 node) view returns (bytes32 x, bytes32 y)',
		'function name(bytes32 node) view returns (string)',
		'function recordVersions(bytes32 node) external view returns (uint64)',
		'function multicallWithNodeCheck(bytes32, bytes[] calldata data) external returns (bytes[] memory results)',
	], active_provider);
	contract._node = namehash(resolver.name);
	contract.get_interface = hash => contract.interfaceImplementer(contract._node, hash);
	return contract;
}
function contract_for_controller(address) {
	return new ethers.Contract(address, [
		'function owner() external view returns (address)',
		'function prices() external view returns (address)',
		'function nameWrapper() external view returns (address)',
	], active_provider);
}
function contract_for_price_oracle(address) {
	let contract = new ethers.Contract(address, [
		'function premium(string calldata name, uint256 expires, uint256 duration) external view returns (uint256)',
		'function price(string calldata name, uint256 expires, uint256 duration) external view returns (uint256)',
		'function usdOracle() external view returns (address)',
	], active_provider);
	/*
	totalDays = 21; // FromDigits["15"]
	price0 = 10^(8 + 18) // FromDigits["52b7d2dcc80cd2e4000000", 16]
	price1 = BitShiftRight[price0, totalDays]
	dur = 1814400;  // t /. First@Solve[price0*(1/2)^(t/86400) == price1, t, Reals]
	*/
	contract.premium_period = 21*86400*1000;
	return contract;
}
async function ensure_wrapper() {
	if (wrapper_contract) return;
	if (wrapper_contract === false) throw new Error(`Not implementated`);
	await ensure_eth_resolver();
	let wrapper_address = await eth_resolver_contract.get_interface('0x019a38fe');
	if (is_null_hex(wrapper_address)) {
		wrapper_contract = false;
		return ensure_wrapper();
	}
	wrapper_contract = new ethers.Contract(wrapper_address, [
		'function isWrapped(bytes32 node) public view returns (bool)',
		'function getData(uint256 id) external view returns (address owner, uint32 fuses, uint64 expiry)',
		'function names(bytes32 node) public view returns (bytes)',	
	], active_provider);
}
async function ensure_eth_nft() {
	if (eth_nft_contract) return;
	if (eth_nft_contract === false) throw new Error(`Not implemented`);
	await ensure_eth_resolver();
	let nft_address = await registry_contract.owner(eth_resolver_contract._node);
	//let nft_address = await eth_resolver_contract.get_interface(IFACE_ETH_NFT);
	if (is_null_hex(nft_address)) {
		eth_nft_contract = false;
		return ensure_eth_nft();
	}
	eth_nft_contract = new ethers.Contract(nft_address, [
		'function available(uint256 id) external view returns(bool)',
		'function nameExpires(uint256 id) external view returns(uint256)',
		'function ownerOf(uint256 id) external view returns (address)',
		'function GRACE_PERIOD() external view returns (uint256)',
	], active_provider);
	eth_nft_contract.grace_period = 1000 * (await eth_nft_contract.GRACE_PERIOD().then(Number).catch(() => 90*86400));
	eth_controller_contract = contract_for_controller(await eth_resolver_contract.get_interface(IFACE_ETH_CONTROLLER));
	price_oracle_contract = contract_for_price_oracle(await eth_controller_contract.prices());
}
async function can_multicall() {
	if (multicall_contract === null) {
		const MULTICALL3 = '0xcA11bde05977b3631167028862bE2a173976CA11';
		if (await is_contract(MULTICALL3)) {
			multicall_contract = new ethers.Contract(MULTICALL3, [
				`function tryAggregate(bool requireSuccess, tuple(address target, bytes data)[] memory calls) public view returns (tuple(bool success, bytes data)[] memory returnData)`
			], active_provider);
		} else {
			multicall_contract = false;
		}
	}
	return multicall_contract;
}
function labels_from_encoded_dns(v) {
	let labels = [];
	let pos = 0;
	while (true) {
		let n = v[pos++];
		if (!n) {
			if (pos !== v.length) break;
			return labels;
		}
		if (v.length < pos+n) break;
		labels.push(utf8_from_bytes(v.subarray(pos, pos += n)));
	}
	throw new Error('invalid encoded name');
}
function encoded_dns_from_labels(labels) {
	const MAX_LABEL = 255;
	let v = [];
	for (let label of labels) {
		if (!label) throw new Error('encoded name: invalid empty label');
		let u = bytes_from_utf8(label);
		if (u.length > MAX_LABEL) throw new Error(`encoded name: too long: ${u.length} > ${MAX_LABEL}`);
		v.push(u.length, ...u);
	}
	v.push(0);
	return Uint8Array.from(v);
}
// https://docs.ens.domains/ens-improvement-proposals/ensip-10-wildcard-resolution
async function get_resolver(name) {
	let v = name.split('.');
	for (let i = 0; i < v.length; i++) {
		let basename = v.slice(i).join('.');
		let address = await registry_contract.resolver(namehash(basename));
		if (should_stop_resolving()) break;
		if (!is_null_hex(address)) {
			let resolver = new ethers.EnsResolver(active_provider, address, name);
			resolver._basename = basename; // remember
			let wild = await resolver.supportsWildcard().catch(() => {}); // can throw
			if (i && !wild) break;
			if (wild) {
				resolver._wildcard = true;
				try {
					resolver._dns = encoded_dns_from_labels(v);
				} catch (err) {
				}
			}
			return resolver;
		}
		if (basename === 'eth') break; // mimic ethers
	}
}
async function get_safe_primary(owner, alt_owner) {
	// return normalized primary if resolve(reverse(owner)) is owner or alt_owner
	let rev_resolver = await get_resolver(reverse_name(owner));
	if (!rev_resolver) {
		throw new Error('Primary not set');
	}
	let contract = contract_for_resolver(rev_resolver);
	let [{data: primary}] = await fetch_records(rev_resolver, [{type: 'name'}]);
	if (!primary) {
		throw new Error('Primary is Null');
	}
	let name = ens_normalize(primary);
	let resolver = await get_resolver(name);
	if (!resolver) {
		throw new Error('Resolver not set');
	}
	let address = await fetch_addr60(resolver);
	if (!address) {
		throw new Error('Address not set');
	}
	if (owner.localeCompare(address, undefined, {sensitivity: 'base'})) {
		if (!alt_owner || alt_owner.localeCompare(address, undefined, {sensitivity: 'base'})) {
			throw new Error(`Address mismatch`);
		}
	}
	return name;
}
async function is_contract(address) {
	if (typeof address !== 'string') return;
	address = address.toLowerCase();
	let is = IS_CONTRACT.get(address);
	if (typeof is === 'boolean') return is;
	try {
		is = !is_null_hex(await active_provider.getCode(address));
		IS_CONTRACT.set(address, is);
		return is;
	} catch (err) {
	}	
}

function base58check(v) {
	return Base58BTC.encode([...v, ...ethers.getBytes(ethers.sha256(ethers.sha256(v))).slice(0, 4)]);
}
function format_btc_address(v, {p2pkh, p2sh, hrp, p2wpkh, p2tr}) {
	let n = v.length;
	// P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
	if (Number.isInteger(p2pkh) && n >= 5 && v[0] == 0x76 && v[1] == 0xA9 && v[2] === n-5 && v[n-2] == 0x88 && v[n-1] == 0xAC) {
		v[2] = p2pkh;
		return base58check(v.subarray(2, -2));
	}
	// P2SH: OP_HASH160 <scriptHash> OP_EQUAL
	if (Number.isInteger(p2sh) && n >= 3 && v[0] == 0xA9 && v[1] == n-3 && v[n-1] == 0x87) {
		v[1] = p2sh;
		return base58check(v.subarray(1, -1));
	}
	try {
		let version = v[0];
		if (version) version -= 0x50;
		let v32 = convert(v.subarray(2), 8, 5);
		if (p2wpkh === version) {
			return new Bech32(hrp, [version, ...v32], 1).toString();
		}
		if (p2tr === version) {
			return new Bech32(hrp, [version, ...v32], Bech32.M).toString();
		}
	} catch (err) {
		console.log(err);
	}
	throw new Error('invalid');
}

function create(tag, args, ...a) {
	let el = document.createElement(tag);
	if (args) {
		for (let [k, v] of Object.entries(args)) {
			if (!v) continue;
			if (v instanceof Function) {
				el.addEventListener(k, v);
			} else if (k === 'className') {
				if (Array.isArray(v)) {
					el.classList.add(...v);
				} else {
					el.classList.add(v);
				}
			} else {
				el[k] = v;
			}
		}
	}
	el.append(...a);
	return el;	
}
function is_address_type_error(err) {
	return err.code === 'INVALID_ARGUMENT' && err.argument === 'value' && err.value === '0x';
}
function is_checksum_address(s) {
	try {
		return s.startsWith('0x') && s === ethers.getAddress(s);
	} catch (ignored) {
	}
}
function is_null_hex(s) {
	return !s || /^0x0*$/.test(s);
}
function labelhash(s) {
	return s ? ethers.keccak256(bytes_from_utf8(s)) : ethers.ZeroHash;
}
function namehash(s) {
	let hash = labelhash();
	if (s) hash = s.split('.').reduceRight((h, x) => ethers.keccak256(h + labelhash(x).slice(2)), hash);
	return hash;
}
function read_local_storage(key, fn, def) {
	let value = localStorage[key];
	if (typeof value === 'string') {
		try {
			return fn(JSON.parse(value));
		} catch (err) {
		}
	}
	if (def !== undefined) {
		fn(def);
	}
}
</script>
</body>
</html>
