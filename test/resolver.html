<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" type="image/png" href="./favicon.png">
<title>ENS Resolver</title>
<style>
:root {
	--btn-fill-color: #eee;
	--btn-border-color: #888;
	--copied-color: #8f8;
	--confusing-color: #d47;
}
.hide {
	display: none !important;
}
.balloon {
	flex: 1;
}
.long {
	white-space: pre-wrap !important;
	word-break: break-word;
}
.force_ltr {
	direction: ltr;
	unicode-bidi: bidi-override;
}
a, button, select {
	cursor: pointer;
}
select {
	font-size: 85%;
	align-self: stretch;
}
a.button {
	text-decoration: none;
}
button {
	appearance: none;
	display: inline-flex;
	align-items: center;
	margin: 0;
	padding: 4px 8px;
	border: 1px solid var(--btn-border-color);
	border-radius: 4px;
	background-color: var(--btn-fill-color);
	color: #000;
	font-size: 100%;
	gap: 4px;
	transition: transform .1s ease;
}
button:disabled {
	opacity: .5;
	pointer-events: none;
}
button:hover {
	transform: scale(1.04);
	border: 2px solid #000;
	margin: -1px;
}
button:hover:active {
	transform: unset;
}
.rtrim {
	padding-right: 4px !important;
}
body {
	margin: 3rem;
	background: #eee;
	display: flex;
	flex-direction: column;
	gap: 8px;
	overflow-y: scroll;
}
header {
	display: flex;
	flex-wrap: wrap;
	align-items: end;
	justify-content: space-between;
	gap: 4px 8px;
}
h1 {
	margin: 0;
}
#provider {
	font-size: 11pt;
	font-weight: normal;
	color: #666;
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 4px;
}
#provider button {
	font-size: 9pt;
	padding: 2px 6px;
}
#provider .notice {
	background-color: #fff;
	color: #000;
	padding: 1px 4px;
	border-radius: 4px;
	font-size: 90%;
}
#provider a {
	font-weight: bold;
}
#github {
	flex: 1;
	text-align: right;
	display: flex;
	flex-direction: column;
	order: 2;
	align-items: end;
	white-space: pre;
}
body.testnet {
	background: #ffe0ff;
}
.spinner {
	width: 24px;
	height: 24px;
	box-sizing: border-box;
	animation: spin 2s infinite linear;
	border: 4px solid #000;
	border-bottom-color: transparent !important;
	border-radius: 100%;
}
@keyframes spin {
	to { transform:rotate(360deg); }
}
#examples {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 4px;
	font-size: 11pt;
	padding-bottom: 6px;
	border-bottom: 2px solid #fff;
}
#examples b {
	font-size: 12pt;
}
#examples button:not([id]) {
	background: #fff;
	padding: 2px 4px;
	border: 2px solid transparent;
	transition: transform 0.1s;
	font-size: 10pt;
	margin: 0;
}
#examples button:not([id]):hover {
	border-color: #aaa;
	transform: scale(1.5);
}
#examples button:not([id]):hover:active {
	border-color: #000;
}
#examples button.mapped:not([id]) {
	border-color: #ccf;
}
#examples button.error:not([id]) {
	border-color: #fcc;
}
#examples a {
	background-color: #ffc;
}
#examples_btn {
	font-weight: bold;
}
#input {
	display: flex;
	align-items: stretch;
	gap: 8px;
}
#input input {
	box-sizing: border-box;
	width: 100%;
	padding: 8px;
	font-size: 20pt;
	line-height: 24pt;
	transition: font-size .5s ease-in-out;
}
#input input.small {
	font-size: 15pt;
}
#input input.smaller {
	font-size: 12pt;
}
#actions {
	flex-wrap: wrap;
}
.left {
	margin-left: auto;
}
.grouped {
	display: flex;
	align-items: center;
	gap: 8px;
}
#options {
	display: flex;
	flex-wrap: wrap;
	align-items: stretch;
	gap: 6px;
}
#options input {
	display: none;
}
#options label {
	display: flex;
	gap: 2px;
	align-items: center;
	padding: 2px 4px;
	border-radius: 4px;
	border: 2px solid #ccc;
	user-select: none;
	color: #666;
	background-color: #fff;
	white-space: pre;
}
#options :disabled + label {
	opacity: .5;
}
#options :not(:disabled) + label {
	cursor: pointer;
}
#options :not(:disabled) + label:hover {
	outline: 2px solid #000;
}
#options :checked + label {
	color: #000;
}
#auto_resolve_check:checked + label {
	border-color: #5c5;
	background: linear-gradient(90deg, #fff, #cfc);
	font-style: italic;
}
#show_details_check:checked + label {
	border-color: #ca4;
	background-color: #edb;
	/* font: 85% monospace; */
	color: #432;
}
#show_components_check:checked + label {
	border-color: #0aa;
	background-color: #cff;
}
#show_records_check:checked + label {
	border-color: #aa0;
	background-color: #ffa;
}
#skip_norm_check:checked + label::before { content: 'âœ–'; font-size: 95%; }
#skip_norm_check:checked + label {
	border-color: #f00;
	background-color: #f00;
	color: #fff;
}
#force_ltr_check:checked + label::after { content: '!'; }
#force_ltr_check:checked + label {
	border-color: #555;
	background-color: #555;
	color: #fff;
}
#chain_select:empty {
	display: none;
}
#copy_link_btn {
	margin-left: auto;
}
#resolve_btn {
	font-weight: bold;
	font-size: 120%;
	gap: 8px;
}
#output {
	display: flex;
	flex-direction: column;
	gap: 8px;
	font-size: 14pt;
}
#output.hide_recs .avatar,
#output.hide_recs .row.records,
#output.hide_recs .row.efp,
#output.hide_recs .row.verifications {
	display: none;
}
#output.hide_details .detailed { display: none; }
#output:not(.hide_details) .inv_detailed { display: none; }
.row button {
	font-size: 11pt;
}
.row-label {
	order: -10;
	text-align: right;
	font-weight: bold;
	white-space: pre;
}
.row-label a {
	color: #000;
	text-decoration: none;
}
.row-label:after {
	content: ':';
}
.row-label a:hover {
	text-decoration: underline;
}
.row.locked .row-label {
	opacity: .65;
}
.row.locked .row-label:before {
	content: 'ğŸ”’ï¸';
}
.row {
	padding: 8px;
	background: #fff;
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 8px;
}
.row.display {
	background: #eff;
}
.row.normalized {
	background: #efe;
	outline: 1px solid #cdc;
}
.row.addr {
	background: #fffff0;
}
.row.dns {
	background:#f5faff;
}
.available {
	opacity: .65;
}
.row.dns .main {
	border-bottom-style: dotted;
}
.row.dns.invalid {
	background: #fff0f0;
	outline: 3px dashed #fcc;
}
.row.pretty {
	background: linear-gradient(90deg, #fff, #fff0fc);
}
.row.efp {
	background: linear-gradient(90deg, #FDF78188, #FDBBE388);
}
.row.category {
	background: #ffe;
}
.row.category .row-label {
	color: #654;
}
.row.category + .row.category {
	margin-top: -6px;
}
.formula {
	display: flex;
	flex-wrap: wrap;
	gap: 4px;
}
.formula a {
	padding: 4px;
	cursor: pointer;
	color: #000;
	text-decoration: none;
}
.formula a:hover {
	background: #cff;
}
.formula a sup {
	font-family: monospace;
}
.row .main {
	display: inline;
	font-size: 16pt;
	border-bottom: 2px solid #000;
	line-height: 130%;
}
ul.row {
	margin: 0;
	margin-top: 4px;
	padding: 16px 16px 16px 36px;
	flex-direction: column;
	align-items: start;
	gap: 4px;
}
ul .tokens {
	display: inline-flex;
}
.row.readme {
	background: #ffc;
}
.row.readme code {
	background: #cff;
	padding: 1px;
}
a.internal {
	font-weight: bold;
}
.row.legend {
	background: #fff;
	list-style: disclosure-closed;
}
.row.legend .tokens {
	min-height: 32px;
}
.row.links {
	display: grid;
	gap: 8px;
	grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
	background: #eff;
	order: 100;
}
a[data-badge]::after {
	content: attr(data-badge);
	margin-left: 4px;
	display: inline-block;
	padding: 2px 4px;
	border-radius: 4px;
	font: 70% sans-serif;
	background-color: #fed;
	color: #666;
	border: 1px solid #ccc;
}
a.addr {
	line-break: anywhere;
	font: 85% monospace;
}
span.key {
	padding: 2px 4px;
	border-radius: 4px;
	background-color: #999;
	color: #fff;
	font: 11px sans-serif;
}
span.tags {
	background: #ddd;
	color: #555;
	padding: 4px 8px;
	font-size: 12pt;
	border-radius: 4px;
	/* border: 1px solid #ccc; */
	white-space: pre;
}
code.framed {
	background-color: #fff;
	border: 1px solid #ccc;
	padding: 2px 4px;
}
button.ens  {
	border-color: #04f;
	background-color: #58f;
	color: #fff;
}
button.copy {
	flex: 0 0 auto;
	align-self: center;
	padding: 0;
	border: none;
	width: 28px;
	height: 28px;
	margin: 0;
	border-radius: 4px;
	background-color: inherit;
	background-position: center;
	background-repeat: no-repeat;
	background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' height='24' shape-rendering='geometricPrecision' stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' viewBox='0 0 24 24' width='24' style='color:var(--geist-foreground)'%3E%3Cpath d='M6 17C4.89543 17 4 16.1046 4 15V5C4 3.89543 4.89543 3 6 3H13C13.7403 3 14.3866 3.4022 14.7324 4M11 21H18C19.1046 21 20 20.1046 20 19V9C20 7.89543 19.1046 7 18 7H11C9.89543 7 9 7.89543 9 9V19C9 20.1046 9.89543 21 11 21Z'/%3E%3C/svg%3E");
	background-size: 85%;
}
button.copy.small {
	width: 20px;
	height: 20px;
	opacity: .4;
}
button.copy:hover {
	opacity: unset;
	background-color: var(--copied-color);
	transform: unset;
}
button.copy.copied {
	opacity: unset;
	background-color: var(--copied-color);
	background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='24' shape-rendering='geometricPrecision' stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' viewBox='0 0 24 24' width='24' style='color:var(--geist-foreground)'%3E%3Cpath d='M20 6L9 17l-5-5'/%3E%3C/svg%3E");
}
.tags.long { order: 30; }
.tags.ensip1 {
	background-color: #df8;
	order: 8;
}
.tags.index {
	font: 9pt monospace;
	background-color: unset;
	opacity: .5;
	user-select: none;
}
.tags.dist { background-color: #fca; color: #000; }
.tags.dist::before {
	content: 'Î”';
	padding-right: 2px;
	opacity: .7;
}
.tags.ens { order: 9; }
.tags.metadata { order: 10; }
.external { order: 11; font-size: 80%; }
.tags.invalid { color: #f00; }
.tags.elapsed {
	background: #f0f0f0;
	font: 9pt sans-serif;
	order: 50;
	margin-left: auto;
}
.requests {
	opacity: .5;
	padding-right: 4px;
}
.record.raw,
.tags.raw {
	font: 80% monospace;
	background-color: #cff;
}
.tags.confusing {
	color: #fff;
	background-color: var(--confusing-color);
	text-align: center;
}
.normalized .confusing {
	margin: -8px 0;
	font: 11px sans-serif;
}
.tags.normalized { background: #8f8; }
.tags.normalized.ascii {
	background: #7ce;
	color: #fff;
	font: 11pt monospace;
}
.tags.length {
	color: #333;
	background: #f8eedd;
}
.tags.length:after {
	content: 'cp';
	padding-left: 2px;
	font-size: 70%;
}
.tags.bytes {
	color: #333;
	background-color: #f8f8f8;
}
.bytes:after {
	content: 'bytes';
	padding-left: 2px;
	font-size: 70%;
}
.tags.iface {
	display: flex;
	align-items: center;
	gap: 4px;
	text-decoration: none;
	background-color: #ddf;
	padding: 4px 8px;
	border-radius: 4px;
	white-space: pre;
	color: #000;
}
.tags.iface.supports {
	background-color: #edf;
}
.tags.iface:hover {
	outline: 2px solid #00f;
}
.tags.iface code {
	font-size: 13px;
	color: #666;
}
.tags.iface code.prefix {
	color: #00f;
}
.tags.good {
	color: #060;
	background: #cfc;
}
.tags.fire {
	color: #000;
	background: #fdb;
}
.tags.note {
	background: #ffc;
}
.tags.reg {
	background-color: #def;
}
.tags.attn {
	background: #fff0dd;
}
.tags.fail {
	background: #fcc;
	color: #600;
}
.tags.type {
	background: #cff;
}
.tags.emoji {
	background-color: #fe0;
}
.tags.special {
	background: #f84;
	border: none;
	color: #fff;
}
.tags.clean {
	background: none;
	border: none;
	padding: 0;
	font-size: 110%;
	order: 7;
}
.tags.white {
	color: #000;
	background: #fff;
}
span.tally {
	background-color: #eff;
	color: #000;
	border: 1px solid #ccc;
	display: flex;
	gap: 4px;
	font: bold 80% sans-serif;
}
.tally .pass { color: #0a0; }
.tally .none { color: #888; }
.tally .skip { color: #bbb; text-decoration: line-through; }
.tally .fail { color: #a00; }
.jazz {
	order: -9;
	width: 1.2rem;
	height: 1.2rem;
	border-radius: 4px;
	display: flex;
	align-items: center;
	justify-content: center;
	color: #fff;
	font: bold 12px monospace;
	background-color: #666;
}
.jazz.addr1 { background-color: #66f; }
.jazz.addr2 { background-color: #c4c; }
.jazz.addr3 { background-color: #0a8; }
.jazz.addr4 { background-color: #a80; }
.jazz.addr5 { background-color: #c93; }
.jazz.addr6 { background-color: #42e; }
.avatar {
	order: -1;
}
.avatar img {
	position: relative;
	z-index: 1;
	display: block;
	border-radius: 4px;
	width: 32px;
	height: 32px;
	transition: transform 0.2s;
}
.avatar img:hover {
	transform: scale(3);
}
.avatar img.not_owner {
	outline: 2px solid #f00;
}
.breakdown {
	font-size: 12pt;
}
.breakdown .tags {
	padding: 2px 4px;
	border-radius: 4px;
	border: 1px solid #ddd;
}
.breakdown .hash {
	padding: 1px 8px;
	display: flex;
	gap: 4px;
	align-items: center;
	justify-content: center;
}
.breakdown .hash :first-child {
	white-space: pre;
}
.breakdown .hash code {
	font-size: 90%;
}
.breakdown .hash a {
	font-weight: bold;
	color: #000;
	text-decoration: none;
}
.breakdown .hash a:hover {
	text-decoration: underline;
}
.breakdown .hash.minor {
	font-size: 90%;
	color: #666;
}
.breakdown .hash.minor.first {
	border-top: 1px dotted #ccc;
}
.breakdown .label {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	justify-content: center;
	gap: 4px 6px;
	margin-top: 4px;
	border-top: 2px solid #fff;
	padding: 3px 6px;
}
.breakdown .label.valid {
	background: linear-gradient(90deg, #0000, #efea, #0000);
}
.breakdown .label.error {
	background: linear-gradient(90deg, #0000, #fcca, #0000);
}
.breakdown .label.mapped {
	background: linear-gradient(90deg, #0000, #ccf6, #0000);
}
.breakdown .name {
	margin: 0 4px;
	border: 1px solid #aaa;
	border-radius: 4px;
	padding: 1px 4px;
	font: 13pt monospace;
	color: #000;
}
.breakdown .restricted {
	text-decoration: none;
	background-color: #fcf;
	color: #000;
}
.breakdown .restricted:hover {
	outline: 2px solid #00f;
}
.breakdown .confusing {
	border: none;
}
.breakdown .error {
	order: 1;
}
.tokens {
	font-size: 16pt;
}
.tokens .emoji[data-components] {
	border-style: dashed;
}
.tokens [data-tld="eth"].valid,
.tokens [data-tld="reverse"].valid {
	color: #fff;
	background: #58f;
	border-color: #04f;
}
.tokens [data-tld="art"].valid {
	color: #fff;
	background: #555;
	border-color: #111;
}
/* .tokens [data-tld="box"].valid {
	color: #fff;
	background: #666;
	border-color: #666;
} */
.maxh {
	max-height: 10rem;
	overflow-y: auto;
	padding-bottom: 1px;
}
.exploded > .error {
	background-color: #f97;
	padding: 3px;
	border-radius: 5px;
}
.exploded > .error.first {
	background: #f77;
}
.row.records {
	background-color: #ffc;
}
.record {
	display: flex;
	color: #000;
	font-size: 90%;
	text-decoration: none;
	align-items: center;
	background: #fff;
	padding: 4px 8px;
	border-radius: 4px;
	border: 1px solid #ccc;
	gap: 4px;
}
.record.notice {
	font-weight: bold;
}
.record button.copy {
	width: 24px;
	height: 24px;
}
.record.copied {
	background-color: var(--copied-color);
}
.record b {
	font: 11px sans-serif;
	color: #666;
	user-select: none;
	pointer-events: none;
	order: -15;
	display: flex;
}
.record:not([href]):hover {
	border: 2px solid #0a0;
	margin: -1px;
}
.record[href]:hover {
	border: 2px solid #00f;
	margin: -1px;
}
.record img,
.record svg {
	width: 18px;
	height: auto;
	user-select: none;
}
.record span.addr {
	font: 80% monospace;
}
.record .minor {
	pointer-events: none;
	font: 12px sans-serif;
}
.record .changed {
	font: 11px sans-serif;
	background-color: #fdb;
	order: 10;
}
.record.verified {
	background-color: #eff;
}
.record.verified::before {
	content: 'âœ…ï¸';
	order: -20;
	margin-left: -3px;
}
.row.verifications {
	background-color: #eff;
}
.row.error {
	background: #fcc;
	outline: 3px dashed #d00;
	border-radius: 0;
}
.row.contract:not(.error) {
	background-color: #fffcf6;
	outline: 2px dashed #cc0;
}
.row.contract {
	position: relative;
}
.row.contract::before {
	position: absolute;
	top: 1px;
	right: 3px;
	content: 'Contract';
	font: 11px monospace;
	color: #999;
}
.transform {
	background: #fffaf0;
}
#recent_select {
	outline: none;
	width: 37px;
	padding: 0;
	margin: 0;
	border: 1px solid var(--btn-border-color);
	border-radius: 4px;
	appearance: none;
	background: no-repeat center url("data:image/svg+xml,%3Csvg height='21' width='20' version='1.1' viewBox='0 0 20 21' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10.5,0 C7,0 3.9,1.9 2.3,4.8 L0,2.5 L0,9 L6.5,9 L3.7,6.2 C5,3.7 7.5,2 10.5,2 C14.6,2 18,5.4 18,9.5 C18,13.6 14.6,17 10.5,17 C7.2,17 4.5,14.9 3.4,12 L1.3,12 C2.4,16 6.1,19 10.5,19 C15.8,19 20,14.7 20,9.5 C20,4.3 15.7,0 10.5,0 L10.5,0 Z M9,5 L9,10.1 L13.7,12.9 L14.5,11.6 L10.5,9.2 L10.5,5 L9,5 L9,5 Z'/%3E%3C/svg%3E"), no-repeat bottom 3px right 2px url("data:image/svg+xml,%3Csvg style='fill: currentColor' width='8' height='4' viewBox='0 0 8 4' version='1.1' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h8l-4 4Z' /%3E%3C/svg%3E") var(--btn-fill-color);
}
#recent_select:hover,
#recent_select:active {
	background-color: #ccc;
}
footer {
	margin: 16px 0;
	display: flex;
	gap: 10px;
	align-items: baseline;
	justify-content: center;
	color: #666;
}
#clock {
	font: 9pt sans-serif;
	background-color: #e0e0e0;
	border-radius: 4px;
	padding: 3px 6px;
}
#clock:empty {
	display: none;
}
#version {
	font-family: monospace;
	cursor: help;
}
#version:hover {
	color: #000;
	text-decoration: underline;
}
#enable_debug_btn {
	border-radius: 4px;
	user-select: none;
	padding: 3px;
	cursor: pointer;
}
#enable_debug_btn:hover {
	background-color: #fff;
}
#debug_header {
	display: flex;
	align-items: center;
	justify-content: center;
	gap: 8px;
	margin: 8px 0;
}
#debug textarea {
	box-sizing: border-box;
	width: 100%;
	resize: vertical;
	font-family: monospace;
}
#debug_footer {
	margin-top: 4px;
	color: #666;
	font-style: italic;
}
@media only screen and (max-width: 900px) {
	#provider {
		order: 3;
		flex-direction: row;
		align-items: center;
		gap: 4px;
		width: 100%;
	}
}
@media only screen and (max-width: 800px) {
	body {
		margin: 0;
	}
	button {
		font-size: 100%;
	}
	header {
		margin: 16px;
		margin-bottom: 0;
	}
	#input input {
		font-size: 20pt;
	}
	#input, #actions, #options, #examples {
		margin: 0 16px;
	}
	#content {
		font-size: 12pt;
	}
	a.wide {
		font-size: 95%;
	}
	.row {
		justify-content: center;
	}
	.tags.elapsed {
		margin-left: unset;
	}
	#examples_btn {
		display: block;
		width: 100%;
		font-size: 14pt;
		padding: 4px;
	}
	#output {
		font-size: 13pt;
	}
	#debug_header {
		margin: 8px;
	}
}
@media only screen and (max-width: 400px) {
	h1 a {
		display: none;
	}
}
</style>
</head>
<body>
<header>
	<h1><a href="https://ens.domains/">ENS</a> Resolver</h1>
	<div id="provider"><div class="spinner"></div> waiting for Browser</div>
	<div id="github">
		<a href="https://github.com/adraffy/ens-normalize.js">adraffy/ens-normalize.js</a>
		<a href="https://docs.ens.domains/ensip/15"><b>ENSIP-15</b></a>
	</div>
</header>
<div id="examples" class="hide">
<button>vitalik.eth</button>
<button>nIcK.eTh</button>
<button>brantly.cash</button>
<button>ğŸ´â€â˜ .art</button>
<button>..a..eth</button>
<button>Ã¶bb</button>
<button>Ã–bb</button>
<button data-name="â—ŒÌˆbb">â—ŒÌˆbb</button>

<a href="https://adraffy.github.io/punycode.js/test/demo.html"><b>Punycode:</b></a>
<button>xn--ls8h</button>
<button>xn--ğŸ’©</button>
<button>ğŸ’·pound</button>
<a href="https://github.com/ensdomains/ens-contracts/tree/master/contracts/wrapper#namewrapper-docs"><b>Wrapper:</b></a>
<button data-name="firstwrappedname">Emanicpated 2LD</button>
<button data-name="please.pumpdeezbags.eth">Emanicpated 3LD</button>
<button data-name="dessert3.menu.bestsushi7.eth">Wrapped</button>
<button data-name="david">Locked</button>

<b>Subdomain:</b>
<button data-name="nowzad.loopring.eth">loopring</button>
<button data-name="239.chonksociety.eth">Chonk #239</button>
<button>raffy.antistupid.com</button>

<a href="https://docs.ens.domains/ensip/10"><b>Wildcard:</b></a>
<button>moo331.nft-owner.eth</button>
<button>ğŸ’.gmcafe.eth</button>
<button>1.offchainexample.eth</button>
<button>barmstrong.cb.id</button>

<a href="https://blog.ens.domains/post/gasless-dnssec"><b>Offchain DNS:</b></a>
<button>brantly.rocks</button>

<b>Address:</b>
<button data-name="0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045">d8dA..6045</button>

<b>Contract:</b>
<button data-name="eth-usd.data.eth">Chainlink ETH-USD</button>

<b>Preimage:</b>
<button data-delay="1000" data-name="token:91842011529764390124322931916134555051359118325819011691525342013207339157209">Token#</button>
<button data-delay="1000" data-name="https://opensea.io/assets/ethereum/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209">OpenSea</button>
<button data-delay="1000" data-name="https://www.gem.xyz/asset/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209">Gem</button>

<a href="./chars.html"><b>Mapped:</b></a>
<button data-name="hyph{2D}{2010}{2011}{2012}{2013}{2014}{2015}{2043}{2212}{23AF}{23E4}{FE58}e{2E3A}n{2E3B}s">Hyphens</button>
<button>A.â„¢ï¸.Ğ®</button>
<button>â…§</button>
<button>â¨Œ</button>

<b>Ignored:</b>
<button data-name="{FE0E}{FE0F}">Emoji Style</button>

<b>Disallowed:</b>
<button data-name="{26}{3000}{E0061}{FFFFFF}{200D}">Types</button>
<button data-name="test .te st. test">Whitespace</button>
<button data-name="{3002}.{FF0E}.{FF61}">Alt Stops</button>
<button data-name="y{303}.{1EF9}">Invalid NFC</button>
<button data-name="{DF00}">Surrogate</button>
<button data-name="[ba967c160905ade030f84952644a963994eeaed3881a6b8a4e9c8cbe452ad7a2].eth" data-skip="1">"ğŸ’©.eth"</button>

<b>Deviation:</b>
<button>ÃŸ</button>
<button>áº</button>
<button>Ï‚</button>

<b>Complex:</b>
<button data-name="_1{FE0F}E{FE0E}{303}{AD}{1F4A9}{24C2}{FE0E}{2E3B}a{301}"></button>

<b>Combining Marks:</b>
<button data-name="{300}">Leading</button>
<button data-name="ğŸ’©{300}">Emoji</button>
<button data-name="x{300}{300}">Whitelisted</button>
<button data-name="{622}{64D}{64E}.{929}{901}{902}">NFD w/CM</button>

<b>NSM:</b>
<button data-name="{625}{610}{610}">Repeated</button>
<button data-name="{625}{610}{611}{612}{613}{614}">Too Many</button>

<a href="https://unicode.org/reports/tr46/#Validity_Criteria"><b>CheckHyphen:</b></a>
<button>-test.test-.t-e--s---t</button>
<button>te--st</button>

<b>Underscore:</b>
<button>__ab</button>
<button>a_b</button>

<a href="./emoji.html"><b>Emoji:</b></a>
<button>Â©</button>
<button>ğŸ•µ</button>
<button>ğŸ§™â€â™‚</button>
<button>ğŸ‹ğŸ¿â€â™‚</button>
<button data-name="ğŸ’©ğŸ’©ğŸ’©">ğŸ’©<sup>3</sup></button>
<button data-name="ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ">ğŸ<sup>13</sup></button>
<button data-name="ğŸ‘ğŸ—¨ğŸ‘ï¸â€ğŸ—¨ï¸">ğŸ‘ï¸â€ğŸ—¨ï¸</button>
<button data-name="ğŸ§ŸğŸ§Ÿâ™‚ğŸ§Ÿâ€â™‚">ğŸ§Ÿ</button>
<button>ğŸ˜µâ€ğŸ’«ğŸ˜µâ€ğŸ’«ğŸ˜µâ€ğŸ’«</button>
<button>ğŸ˜µğŸ’«ğŸ˜µğŸ’«ğŸ˜µğŸ’«</button>
<button>ğŸ‘©â€âš•ğŸ‘©ğŸ½â€âš•ï¸</button>
<button>ğŸ‘ªğŸ‘¨â€ğŸ‘©â€ğŸ‘¦</button>
<button data-name="ğŸš´ï¸ğŸšµï¸ğŸš´ğŸ»ğŸš´ğŸ¼ğŸš´ğŸ½ğŸš´ğŸ¾ğŸš´ğŸ¿ğŸšµğŸ»ğŸšµğŸ¼ğŸšµğŸ½ğŸšµğŸ¾ğŸšµğŸ¿ğŸš´â€â™€ï¸ğŸš´â€â™‚ï¸ğŸšµâ€â™€ï¸ğŸšµâ€â™‚ï¸ğŸš´ğŸ»â€â™€ï¸ğŸš´ğŸ»â€â™‚ï¸ğŸš´ğŸ¼â€â™€ï¸ğŸš´ğŸ¼â€â™‚ï¸ğŸš´ğŸ½â€â™€ï¸ğŸš´ğŸ½â€â™‚ï¸ğŸš´ğŸ¾â€â™€ï¸ğŸš´ğŸ¾â€â™‚ï¸ğŸš´ğŸ¿â€â™€ï¸ğŸš´ğŸ¿â€â™‚ï¸ğŸšµğŸ»â€â™€ï¸ğŸšµğŸ»â€â™‚ï¸ğŸšµğŸ¼â€â™€ï¸ğŸšµğŸ¼â€â™‚ï¸ğŸšµğŸ½â€â™€ï¸ğŸšµğŸ½â€â™‚ï¸ğŸšµğŸ¾â€â™€ï¸ğŸšµğŸ¾â€â™‚ï¸ğŸšµğŸ¿â€â™€ï¸ğŸšµğŸ¿â€â™‚ï¸">ğŸš´ï¸ Bikes (36)</button>
<button data-name="ğŸ¦°ğŸ¦±ğŸ¦²ğŸ¦³">ğŸ¦°</button>
<button>ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦ğŸ¿</button>
<button data-name="{1F3FB}{1F3FC}{1F3FD}{1F3FE}{1F3FF}">ğŸ»</button>
<button data-name="ğŸ’©{200D}ğŸ’©">ğŸ’©+ğŸ’©</button>
<button data-name="{261D}{FE0F}{1F3FB}"></button>
<button>â€¼ï¸</button>
<button>â‰ï¸</button>
<button data-name="â„¢â„¹â“‚ãŠ—ãŠ™ğŸˆğŸˆ‚ğŸˆšğŸˆ¯ğŸˆ²ğŸˆ³ğŸˆ´ğŸˆµğŸˆ¶ğŸˆ·ğŸˆ¸ğŸˆ¹ğŸˆºğŸ‰ğŸ‰‘">â˜¹ï¸ Demoted</button>

<b>Non-RGI:</b>
<button>ğŸ±â€ğŸ‰</button>
<button>ğŸ‘ªğŸ»</button>
<button>ğŸ¤¼ğŸ»â€â™€ï¸</button>
<button data-name="{1F469}{1F3FE}{200D}{1F91D}{200D}{1F469}{1F3FE}">Mod+Mod</button>

<b>Regional:</b>
<button>ğŸ‡¦</button>
<button>ğŸ‡¦ğŸ‡¦</button>
<button>ğŸ‡ºğŸ‡¸ğŸ‡ºğŸ‡²</button>

<b>Flag:</b>
<button>ğŸ´</button>
<button>ğŸï¸</button>
<button>ğŸ³ï¸â€ğŸŒˆ</button>

<a href="https://www.unicode.org/reports/tr51/#DisplayValidEmojiTagSeqs"><b>Tag:</b></a>
<button>{1F3F4}{E0067}{E0062}{E0065}{E006E}{E0067}{E007F}</button>
<button>{1F3F4}{E0067}{E0062}{E0073}{E0063}{E0074}{E007F}</button>
<button>{1F3F4}{E0067}{E0062}{E0077}{E006C}{E0073}{E007F}</button>
<button data-name="{1F3F4}{E0075}{E0073}{E0063}{E0061}{E007F}">usca</button>

<b>Circled/Squared:</b>
<button>i{2139}{2139}{FE0F}ğŸ›ˆ</button>
<button data-name="â’¶â’·â’¸â’¹â’ºâ’»â’¼â’½â’¾â’¿â“€â“â“‚â“ƒâ“„â“…â“†â“‡â“ˆâ“‰â“Šâ“‹â“Œâ“â“â“">â’¶-â“</button>
<button data-name="â“â“‘â“’â““â“”â“•â“–â“—â“˜â“™â“šâ“›â“œâ“â“â“Ÿâ“ â“¡â“¢â“£â“¤â“¥â“¦â“§â“¨â“©">â“-â“©</button>
<button data-name="â“ªâ‘ â‘¡â‘¢â‘£â‘¤â‘¥â‘¦â‘§â‘¨â‘©â‘ªâ‘«â‘¬â‘­â‘®â‘¯â‘°â‘±â‘²â‘³ã‰‘ã‰’ã‰“ã‰”ã‰•ã‰–ã‰—ã‰˜ã‰™ã‰šã‰›ã‰œã‰ã‰ã‰Ÿ">â“ª-ã‰Ÿ</button>
<button data-name="ğŸ…°ğŸ…±ğŸ…²ğŸ…³ğŸ…´ğŸ…µğŸ…¶ğŸ…·ğŸ…¸ğŸ…¹ğŸ…ºğŸ…»ğŸ…¼ğŸ…½ğŸ…¾ğŸ…¿ğŸ†€ğŸ†ğŸ†‚ğŸ†ƒğŸ†„ğŸ†…ğŸ††ğŸ†‡ğŸ†ˆğŸ†‰">ğŸ…°-ğŸ†‰</button>
<button data-name="ğŸ…ğŸ…‘ğŸ…’ğŸ…“ğŸ…”ğŸ…•ğŸ…–ğŸ…—ğŸ…˜ğŸ…™ğŸ…šğŸ…›ğŸ…œğŸ…ğŸ…ğŸ…ŸğŸ… ğŸ…¡ğŸ…¢ğŸ…£ğŸ…¤ğŸ…¥ğŸ…¦ğŸ…§ğŸ…¨ğŸ…©">ğŸ…-ğŸ…©</button>
<!-- TODO: 1CCD6-1CCEF = OUTLINED LATIN CAPITAL A-Z -->
<!-- TODO: 1CCF0-1CCF9 = OUTLINED DIGIT 0-9 -->
<button data-name="â“¿â¶â·â¸â¹âºâ»â¼â½â¾â¿â“«â“¬â“­â“®â“¯â“°â“±â“²â“³â“´">â“¿-â¿</button>
<button data-name="ğŸ„ŒâŠâ‹âŒâââââ‘â’â“">ğŸ„Œ-â“</button>
<button data-name="ã‰ˆã‰‰ã‰Šã‰‹ã‰Œã‰ã‰ã‰">ã‰ˆ-ã‰</button>

<a href="https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.1"><b>ContextJ:</b></a>
ZWNJ:
<button data-name="à´¨àµ{200C}à´®"></button>
<button data-name="Ù†ÛŒÙ…â€ŒÙØ§ØµÙ„Ù‡"></button>
<button data-name="a{200C}b"></button>

ZWJ:
<button data-name="eth{200D}{200D}{200D}.eth">eth</button>
<button data-name="à´£àµâ€"></button>
<button data-name="a{200D}b"></button>

<a href="https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.3"><b>ContextO:</b></a>
Middle Dot:
<button data-name="{6C}{B7}{6C}"></button>

Katakana Dot:
<button data-name="æœˆãƒ»æ°´"></button>
<button data-name="aãƒ»a{300}"></button>

Greek Keraia:
<button data-name="{375}Î±"></button>

Hebrew Geresh:
<button data-name="{5D1}{5F3}"></button>

<a href="https://www.rfc-editor.org/rfc/rfc5893.html#section-2"><b>CheckBidi:</b></a>
<button>×¤×¢×™×œ×•×ª×”×‘×™× ××•×</button>
<button data-name="{0786}{07AE}{0782}{07B0}{0795}{07A9}{0793}{07A6}{0783}{07AA}">Dhivehi</button>
<button data-name="{05D9}{05B4}{05D5}{05D0}{05B8}">Yiddish</button>
<button data-name="{1F1F8}{1F1E6}{633}{644}{645}{627}{646}">Emoji+RTL</button>
<button data-name="{633}{644}{645}{627}{646}{1F1F8}{1F1E6}">RTL+Emoji</button>
<button data-name="bahrain.Ù…ØµØ±">LTR.RTL</button>
<button data-name="bahrainÙ…ØµØ±">LTR+RTL in Label</button>
<button data-name="{202e}elgoog{202d}.eth">.ethgoogle</button>
<button data-name="{202e}hte.elgoog">google.eth</button>

<b>Keycaps:</b>
<button>1âƒ£2ï¸âƒ£ğŸ”Ÿ.eth</button>
<button data-name="0ï¸âƒ£1ï¸âƒ£2ï¸âƒ£3ï¸âƒ£4ï¸âƒ£5ï¸âƒ£6ï¸âƒ£7ï¸âƒ£8ï¸âƒ£9ï¸âƒ£ğŸ”Ÿ*ï¸âƒ£#ï¸âƒ£">*ï¸âƒ£-ğŸ”Ÿ</button>

<a href="https://unicode-org.github.io/cldr-staging/charts/latest/by_type/core_data.alphabetic_information.main.html">Exemplars</a> /
<a href="https://util.unicode.org/UnicodeJsps/confusables.jsp"><b>Confusables:</b></a>
<button>aÎ±.É‘</button>
<button>à®¶à¯à®°à¯€.à®¸à¯à®°à¯€</button>
<button data-name="i.i{307}.{131}{307}">iÌ‡</button>
<button data-name="{E8}.e{300}.{450}.{435}{300}">Ã¨</button>

<b>Mixed-Script:</b>
<button data-name="0aã€‡.é»‘a8">Digit+Latin+Han</button>
<button data-name="ã‚ã‚¢ã„ã‚¤ã†ã‚¦ãˆã‚¨ãŠã‚ª">Kana+Hira</button>
<button data-name="bitcoin.bitcÎ¿in.biÌ‡tcoin.bitÑoin">"bitcoin"</button>
<button>ã‚¡í£</button>

<b>Whole-Script:</b>
<button data-name="0x.0Ï‡.0Ñ…">"0x"</button>
<button data-name="apple.Ğ´Ñ€Ñ€ÓĞµ.Ğ°Ñ€Ñ€ÓĞµ.aÑ€Ñ€ÓĞµ">"apple"</button>
<button data-name="Î¹Î¿ÏƒÏÎ²Ï…Î½Î³">Greek</button>
<button data-name="o.Ù¥.à¥¦.à±¦.à©¦.àµ¦.Î¿.Ö…">"o"</button>
<button data-name="ã‚ãƒ¼.ã€‡ä¸€.ä¸€ãƒ¼.ä¸€.ãƒ¼.á…³">CJK Dash</button>

<a href="https://www.unicode.org/versions/Unicode15.0.0/"><b>Unicode 15.0:</b></a>
<a href="./emoji.html#q=v15"><button>Emoji (31)</button></a>

<a href="https://www.unicode.org/versions/Unicode15.1.0/"><b>Unicode 15.1:</b></a>
<button>â‰ .â‰®.â‰¯</button>
<a href="./emoji.html#q=v15.1"><button>Emoji (118)</button></a>

<a href="https://www.unicode.org/versions/Unicode16.0.0/"><b>Unicode 16.0:</b></a>
<a href="./emoji.html#q=v16"><button>Emoji (8)</button></a>
<button data-name="{1CC4A}{1CC6D}{1CC96}">Legacy Computing</button>

<a href="https://www.unicode.org/versions/Unicode17.0.0/"><b>Unicode 17.0:</b></a>
<a href="./emoji.html#q=v17"><button>Emoji (163)</button></a>
<button data-name="{1CEC0}{1CEC1}{1CEC2}{1CEC3}{1CEC4}{1CEC5}{1CEC6}{1CEC7}{1CEC8}{1CEC9}{1CECA}{1CECB}{1CECC}{1CECD}{1CECE}{1CECF}{1CED0}">Miscellaneous Symbols</button>

<b>Fenced:</b>
<button>O'Brian</button>
<button data-name="Â¼Â½Â¾â…â…‘â…’â…“â…”â…•â…–â…—â…˜â…™â…šâ…›â…œâ…â…â…Ÿâ†‰">"Â½"</button>
<button>123â„456â€™s</button>
<button data-name="a'.â€™z.a'â€™b.aâ„'.â„a">Invalid</button>

<b>Misc:</b>
<button data-name="$Â¢Â£Â¤Â¥â‚¡â‚¦â‚©â‚ªâ‚«â‚¬â‚­â‚®â‚±â‚²â‚´â‚µâ‚¸â‚¹â‚ºâ‚¼â‚½â‚¾âƒ€â‚¿Î.Ø‹">Currency</button>
<button data-name="â€¢-â€¢Â¬.âŒâ—¨-â—¨.âŒã€‡-ã€‡Â¬">Glasses</button>
<button>360Â°</button>
<button data-name="2Ï€r.4Ï€Î¸.8Ğ¿">"Ï€"</button>
<button>Î.â‰¡.â˜°</button>
<button>â™¢âŸ â§«</button>
<button data-name="_â–â–‚â–ƒâ–„â–…â–†â–‡â–ˆ">â–ƒâ–…â–‡</button>
<button data-name="âœ“.âœ”ï¸.âœ”ï¸.âœ…ï¸.â˜‘ï¸">Checks</button>
<button data-name="á´€Ê™á´„á´…á´‡êœ°É¢ÊœÉªá´Šá´‹ÊŸá´É´á´á´˜ê¯Ê€êœ±á´›á´œá´ á´¡xÊá´¢">êœ±á´á´€ÊŸÊŸ á´„á´€á´˜êœ±</button>
<button data-name="zÊxÊÊŒnÊ‡sÉ¹bdouÉ¯êÊÅ¿Ì£á´‰É¥áµ·ÉŸÇpâ†„qÉ">pÇuÉ¹nÊ‡</button>
<button data-name="ğŸ’©Ä…Ã§Ä™ÅŸÃ¬Ã­Ã®Ã¯ÇÅ‚">Rare Latin</button>

<b>Pure:</b>
Arabic:
<button>Ø¥Ù†ØªØ±Ù†Øª</button>
<button data-name="{660}{661}{662}{663}{664}{665}{666}{667}{668}{669}.{6F0}{6F1}{6F2}{6F3}{6F4}{6F5}{6F6}{6F7}{6F8}{6F9}.{6F0}{780}">Digits</button>
Hebrew:
<button>×©×™×¨×•×ªÖ¾×©××•×ª</button>

<a href="https://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers"><b>Restricted:</b></a>
<button data-name="ğ“€€ğ“€ğ“€‚">Egyptian Hieroglyphs</button>
<button data-name="ğŒ±ğŒ»ğ‰ğŒ¼ğŒ°">Gothic</button>
<button>ğ“†â¡ğŸ¸ï¸</button>
<button data-name="ağ“€‚">Mixed</button>
<button>áá®á‚á¥.eth</button>

<a href="https://adraffy.github.io/ens-norm-tests/test-compare/output/ens_normalize.git_1.9.0_vs_eth-ens-namehash_2.0.15.html#diff-norm"><b>Different Norm:</b></a>
<button data-name="â€‘888">Remapped Hyphen</button>
<button data-name="Û°Û±Û²Û³Û·Û¸Û¹">Mapped Arabic</button>

<a href="https://www.dentity.com/"><b>Verifications:</b></a>
<button>evanmoyer.eth</button>

</div>
<div id="options">
	<button id="examples_btn">ğŸ‘€ Examples</button>
	<input type="checkbox" id="auto_resolve_check" checked>
	<label for="auto_resolve_check"><svg width="20" fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24"><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/></svg>on Input</label>
	<input type="checkbox" id="show_components_check" checked>
	<label class="hide" for="show_components_check" title="Reveal internal emoji codepoints">Emoji ğŸ§¬ï¸</label>
	<input type="checkbox" id="show_records_check" checked>
	<label for="show_records_check" title="Include common text and address records">Records</label>
	<input type="checkbox" id="show_details_check">
	<label for="show_details_check">Labels</label>
	<input type="checkbox" id="skip_norm_check">
	<label for="skip_norm_check"  title="When active, normalization is not applied"><svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="var(--geist-fill)"></circle><path d="M15 9L9 15" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path><path d="M9 9L15 15" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path></svg>Norm</label>
	<input type="checkbox" id="force_ltr_check">
	<label for="force_ltr_check" title="Override Bidi Handling with Left-to-Right Direction&#10;(Applies only to Input)">LTR</label>
	<select id="chain_select"></select>
	<button id="mainnet_btn" class="ens hide">â†ª Mainnet</button>
	<button id="browser_btn" class="hide">Browser â†©</button>
	<button id="copy_link_btn">ğŸ”—ï¸ Copy Link</button>
</div>
<div id="input">
	<input id="input_field" size="20" placeholder="Name or Address">
	<select id="recent_select" title="Recent Names" class="hide">
		<option value="reset">ğŸ—‘ï¸ Clear History</option>
		<optgroup label="Recent Names"></optgroup>
	</select>
</div>
<div id="actions" class="grouped">
	<button id="find_emoji_btn" title="Lookup Selected/First Emoji&#10;[ALT] Random Emoji&#10;[SHIFT] Only Use Singles">Emoji</button>
	<button id="chars_btn" title="Lookup Selected/First Character">Chars</button>
	<button id="confused_btn" title="Explain Confusable Characters">Confused</button>
	<div class="grouped left">
		<div class="spinner"></div>
		<button id="nf_btn" title="NFDâ†”NFC">NF</button>
		<button id="escape_btn" title="[ALT] Unicode Escaped">Escape</button>
		<button id="resolve_btn" title="[ALT] Resolve parent&#10;[ESC] Clear input" class="ens">Resolve</button>
	</div>
</div>
<div id="output">
<ul class="row readme">
<li>Click an <button data-name="ğŸ‘ï¸â€ğŸ—¨ï¸A{303}.Eth">Example</button> to see how it works.</li>
<li><code>token:__</code> lookup the <a href="../../keccak.js/test/demo.html#algo=keccak-256&s=raffy&escape=1&encoding=utf8">labelhash</a> (if known) <button data-name="token:91842011529764390124322931916134555051359118325819011691525342013207339157209" data-delay="1000">raffy.eth</button> or <a href="../../ens-labels/demo.html">search for it</a>.</li>
<li><code>wrapped:__</code> lookup the <a href="../../keccak.js/test/demo.html#algo=namehash&s=firstwrappedname.eth&escape=1&encoding=utf8">namehash</a> (if wrapped) <button data-name="wrapped:0xc44eec7fb870ae46d4ef4392d33fbbbdc164e7817a86289a1fe30e5f4d98ae85" data-delay="1000">firstwrappedname.eth</button></li>
<li>Use <code>{FF}</code> or <code>[255]</code> to include codepoints <button data-raw data-name="a{61}[97].eth">aaa</button></li>
<li><code>\uFFFF</code>, <code>\u{HEX}</code>, <code>&amp;#xFF;</code>, <code>&amp;#255;</code>, or <code>&amp;entity;</code> are shorthand for <code>{HEX}</code>.</li>
<li><code>HEX<sub>1</sub> HEX<sub>2</sub></code> is shorthand for <code>{HEX<sub>1</sub>}{HEX<sub>2</sub>}</code> <button data-name="65 74 68" data-meta data-delay="1000">eth</button></li>
<li><code>range:HEX<sub>1</sub>..HEX<sub>n</sub></code> expands to a range of characters <button data-name="range:61..7A" data-delay="1000">ASCII a-z</button></li>
<li><button id="copy_example_btn">Copy Link</button></a> to get a URL that resolves on page-load.</li>
<li>Many elements have tooltips with additional information.</li>
<li>Follows <a class="internal" href="https://docs.ens.domains/ensip/15">ENSIP-15</a> and <a href="https://docs.ens.domains/terminology">ENS Terminology</a>.</li>
<li>Clear input to return to this page.</li>
</ul>
<ul class="row legend">
<li>This is a <b>valid</b> sequence of characters: <span data-tokenize="abc"></span> and domain name: <span data-tokenize="abc.eth"></span></li>
<li>This is an <b>emoji</b>: <span data-tokenize="ğŸ‘©ğŸ½â€âš•ï¸"></span> and its corresponding <b>components</b>: <span data-tokenize="ğŸ‘©ğŸ½â€âš•ï¸" data-parts="1"></span></li>
<li>This is a <b>mapped</b> token: <span data-tokenize="â„¢"></span> which transforms into a <b>valid</b> sequence: <span data-tokenize="tm"></span></li>
<li>Characters not in canonical form require <b>NFC</b>: <span data-tokenize="a{303}"></span></li>
<li>These are <b>ignored</b> characters: <span data-tokenize="{AD}{FE0F}{E0100}"></span></li>
<li>These are <b>disallowed</b> characters: <span data-tokenize="#{00}{1FFFFF}{E0061}{200D}"></span></li>
</ul>
<ul class="row links">
<li><a class="internal" href="./emoji.html">Supported Emoji</a></li>
<li><a class="internal" href="./chars.html">Characters Viewer</a></li>
<li><a class="internal" href="./confused.html">Confused Explainer</a></li>
<li><a class="internal" href="./validate.html">Validation Test</a></li>
<li><a class="internal" href="./report-nf.html">Unicode NormalizationTest</a></li>
<li><a href="../../ens-norm-tests/test-breakdown/output-20230226/">ENSIP-1â†’15 Breakdown</a></li>
<li><a href="https://docs.ens.domains/learn/deployments">ENS Deployments</a></li>
<li><a href="../../ens-labels/demo.html">Labelhashâ»Â¹</a></li>
<li><a href="https://github.com/adraffy/ens-labels/" data-badge="json">Label Database</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-brute.html">Brute-force</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-regs.html">Recent Registrations</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-renews.html">Recent Renews</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-exp.html">Expirations</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-emoji-freq.html">Emoji Frequency Browser</a></li>
<li><a href="../../emoji.js/test/demo.html" data-badge="js">Emoji Parser</a></li>
<li><a href="../../keccak.js/test/demo.html" data-badge="js">Keccak Hasher</a></li>
<li><a href="../../punycode.js/test/demo.html" data-badge="js">Punycode Coder</a></li>
<li><a href="../../cid.js/test/demo.html" data-badge="js">CID Tool</a></li>
<li><a href="https://github.com/adraffy/blocksmith.js" data-badge="js">blocksmith</a>
<li><a href="https://github.com/unruggable-labs/unruggable-gateways" data-badge="js">Unruggable Gateway</a>
<li><a href="https://github.com/namestonehq/TheOffchainResolver.sol" data-badge="sol">TheOffchainResolver</a></li>
<li><a href="https://github.com/namestonehq/TheOffchainGateway.js" data-badge="js">TheOffchainGateway</a></li>
<li><a href="https://github.com/namestonehq/ezccip.js" data-badge="js">ezccip</a></li>
<li><a href="https://namestonehq.github.io/ezccip.js/test/postman.html">CCIP-Read Postman</a></li>
<li><a href="https://github.com/namestonehq/enson.js" data-badge="js">enson</a></li>
<li><a href="https://adraffy.github.io/CCIPRewriter.sol/test/" data-badge="sol">CCIPRewriter</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-register.html">Register .eth Name</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-reverse.html">Set Primary</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-batch-resolver.html">Batch Resolver</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-nft-matcher.html">ENS+NFT Matcher</a></li>
<li><a href="https://raffy.antistupid.com/eth/emoji-pixels.html">Emoji Pixel Maker</a></li>
</ul>
</div>
<div id="debug" class="hide">
	<div id="debug_header">
		<b>ğŸ› ï¸ Debug Settings:</b>
		<button id="apply_debug_btn">ğŸ”„ï¸ <span class="key">shift+enter</span></button>
		<span class="balloon"></span>
		<button id="clean_debug_btn" title="Clear debugger">ğŸ§¹ï¸</button>
		<button id="disable_debug_btn" title="Disable debugger">ğŸ›‘ï¸</button>
	</div>
	<textarea rows="20"></textarea>
	<div id="debug_footer">While visible, all records are read and errors are shown.</div>
</div>
<footer>
	<span>Created by <a href="https://x.com/adraffy">raffy.eth</a></span>
	<span id="clock"></span>
	<span id="version"></span>
	<span id="enable_debug_btn" title="Enable Debugging">ğŸ› ï¸</span>
</footer>
<script type="module">
import {ethers} from 'https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.min.js';
import {
	ens_normalize, ens_split, ens_beautify, ens_tokenize, ens_emoji,
	nfc, nfd, hex_cp, quote_cp, explode_cp, str_from_cps, safe_str_from_cps,
	versions, compare_arrays, is_combining_mark, should_escape,
	dom_from_tokens, use_default_style,
} from '../dist/all.min.js';
import {puny_encoded, is_surrogate} from '../../punycode.js/dist/index.min.js';
import {CID, uvarint, convert, Bech32, Base32, Base58BTC, Base64URL} from '../../cid.js/dist/index.min.js';
import eth_ens_namehash from './eth-ens-namehash@2.0.15.min.js';
use_default_style();

const $ = x => document.querySelector(x);
const $$ = x => document.querySelectorAll(x);
const EMOJI = ens_emoji();

const input_field = $('#input_field');
const resolve_btn = $('#resolve_btn');
const auto_resolve_check = $('#auto_resolve_check');
const show_components_check = $('#show_components_check');
const show_components_label = $('label[for="show_components_check"]');
const show_records_check = $('#show_records_check');
const skip_norm_check = $('#skip_norm_check');
const show_details_check = $('#show_details_check');
const force_ltr_check = $('#force_ltr_check');
const chain_select = $('#chain_select');
const mainnet_btn = $('#mainnet_btn');
const browser_btn = $('#browser_btn');
const recent_select = $('#recent_select');
const recent_optgroup = $('#recent_select optgroup');
const options_div = $('#options');
const actions_div = $('#actions');
const primary_loader = $('#actions .spinner');
const output_div = $('#output');
const examples_div = $('#examples');
const examples_btn = $('#examples_btn');
const provider_div = $('#provider');
const nf_btn = $('#nf_btn');
const escape_btn = $('#escape_btn');
const version_span = $('#version');
const clock_span = $('#clock');
const enable_debug_btn = $('#enable_debug_btn');
const debug_div = $('#debug');
const debug_ta = $('#debug textarea');

const readme_dom = [...output_div.childNodes]; // save initial ux
const entity_span = document.createElement('span');

const DEBUG_INDENT = '    ';

const RESOLVE_MODE_IDLE = 'idle';
const RESOLVE_MODE_EMPTY = 'empty';
const STORAGE_RECENT = 'ens-norm.recent';
const STORAGE_SETTINGS = 'ens-norm.settings';

const INPUT_NAME = 'Input';
const OPENSEA_NAME = 'OpenSea';
const VISION_NAME = 'Vision';
const VISION_HOST = 'vision.io';
const PRETTY_NAME = 'ğŸ’–ï¸';
const MANAGER_NAME = 'Manager';
const WRAPPER_NAME = 'Wrapper';
const NFT_OWNER_NAME = 'NFT Owner';
const SAME_AS_INPUT = 'Same as Input';
const SAME_AS_NORM = 'Same as Norm';
const ALT_RAW = '[ALT] Raw Value';
const EMOJI_INSPECT = 'ğŸ”ï¸ Inspect';
const EMOJI_CHECK = 'âœ…ï¸ Check';

const RESOLVER_ABI = new ethers.Interface([
	'function interfaceImplementer(bytes32 node, bytes4 interfaceID) view returns (address)',
	'function resolve(bytes name, bytes data) view returns (bytes)',
	'function resolve(bytes name, bytes data, bytes context) view returns (bytes)',
	'function addr(bytes32 node, uint coinType) view returns (bytes)',
	'function addr(bytes32 node) view returns (address)',
	'function text(bytes32 node, string key) view returns (string)',
	'function contenthash(bytes32 node) view returns (bytes)',
	'function pubkey(bytes32 node) view returns (bytes32 x, bytes32 y)',
	'function name(bytes32 node) view returns (string)',
	'function recordVersions(bytes32 node) view returns (uint64)',
	'function multicall(bytes[] calldata data) returns (bytes[] memory results)',
	'error OffchainLookup(address sender, string[] gateways, bytes request, bytes4 callback, bytes carry)',
	'function supportsInterface(bytes4 interfaceID) view returns (bool)',
	'function oracle() view returns (address)',
	'function setAddr(bytes32 node, uint256 coinType, bytes addr)',
]);

const CHAINS = [
	{
		// https://github.com/ethereum-lists/chains/blob/master/_data/chains/eip155-1.json
		id: 1,
		name: 'Mainnet',
		ankr: 'eth',
		drpc: 'https://eth.drpc.org',
		manager: 'https://app.ens.domains',
		explorer: 'https://etherscan.io',
		metadata: 'https://metadata.ens.domains/mainnet',
		opensea: 'https://opensea.io/assets/ethereum/',
		is_mainnet: true,
		public: 'https://cloudflare-eth.com/',
	},
	// {
	// 	// https://github.com/ethereum-lists/chains/blob/master/_data/chains/eip155-5.json
	// 	id: 5,
	// 	name: 'Goerli',
	// 	explorer: 'https://goerli.etherscan.io',
	// 	metadata: 'https://metadata.ens.domains/goerli',
	// 	opensea: 'https://testnets.opensea.io/assets/goerli/'
	// },
	{
		// https://github.com/ethereum-lists/chains/blob/master/_data/chains/eip155-11155111.json
		id: 11155111,
		name: 'Sepolia',
		ankr: 'eth_sepolia',
		drpc: 'https://sepolia.drpc.org',
		manager: 'https://sepolia.app.ens.domains',
		explorer: 'https://sepolia.etherscan.io',
		metadata: 'https://metadata.ens.domains/sepolia',
		opensea: 'https://testnets.opensea.io/assets/sepolia/',
		public: 'https://ethereum-sepolia-rpc.publicnode.com',
	},
	{
		// https://github.com/ethereum-lists/chains/blob/master/_data/chains/eip155-17000.json
		id: 17000,
		name: 'Holesky',
		ankr: 'eth_holesky',
		drpc: 'https://holesky.drpc.org',
		manager: 'https://holesky.app.ens.domains',
		explorer: 'https://holesky.etherscan.io',
		metadata: 'https://metadata.ens.domains/holesky',
		//opensea: 'https://testnets.opensea.io/assets/holesky/',
		//rpc: 'https://rpc.holesky.ethpandaops.io',
		public: 'https://ethereum-holesky-rpc.publicnode.com',
	}
];
CHAINS.forEach(chain => {
	if (!chain.slug) chain.slug = chain.name.toLowerCase();
	chain.contracts = new Map();
	chain.resolvers = new Map();
});

const EVM_BIT = 1n << 31n;
const MIN_ETH_LENGTH = 3;
const IFACE_ETH_CONTROLLER = '0x612e8c09';
const NFT_DOMAINS = new Set(['eth', 'art']); //, 'box']);
const RESOLVER_NAMES = {
	'0x1da022710dF5002339274AaDEe8D58218e9D6AB5': 'Old Public (v0)',  // 3648359: just addr()
	'0xDaaF96c344f63131acadD0Ea35170E7892d3dfBA': 'Old Public (v1)',  // 9380387: addr(coinType)
	'0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41': 'Old Public (v2)',  // 9412610: same as v1?
	'0x231b0Ee14048e9dCcD1d247744d114a4EB5E8E63': 'âœ¨ï¸ Public (v3)',  // 16925619: wrapper support, versioned, name()
	'0x5fBb459C49BB06083C33109fA4f14810eC2Cf358': 'Old Reverse (v1)',
	'0xA2C122BE93b0074270ebeE7f6b7292C7deB45047': 'Old Reverse (v2)',
};
const ERROR_ABI = new ethers.Interface([
	'error NotImplemented()',
	'error InvalidOperation()',
	'error InvalidAddressFormat()',
	'error CouldNotResolve(bytes name)',
	'error InvalidLabelCount(bytes dns, uint256 count)',
	'error ECDSAInvalidSignatureLength(uint256 length)',
	// old TOR
	'error Untrusted(address signed, address expected)',
	// new TOR
	'error CCIPReadExpired(uint256 expired)',
	'error CCIPReadUntrusted(address signed, address expected)',
	'error Unauthorized(address owner)',
	'error InvalidContext(bytes context)',
	'error Unreachable(bytes name)',
	// IUniversalResolver
	'error ResolverNotFound(bytes name)',
	'error ResolverNotContract(bytes name, address resolver)',
	'error ResolverError(bytes errorData)',
	'error ReverseAddressMismatch(string primary, bytes primaryAddress)',
	'error HttpError(uint16 status, string message)',
	// NameCoder
	'error DNSDecodingFailed(bytes dns)',
	'error DNSEncodingFailed(string ens)',
	// https://github.com/ensdomains/ensips/pull/18
	'error UnreachableName(bytes name)',
	'error UnknownResolverProfile(bytes4 selector)',
	// urg
	'error CommitTooOld(uint256 latest, uint256 got, uint256 window)',
	'error CommitTooNew(uint256 latest, uint256 got)',
	'error UnexpectedString()',
	'error InvalidProof()',
]);

const CHAIN_NAMES = new Map([
	[0n, 'Default EVM'],
	[1n, 'Ethereum (Mainnet)'],
	[11155111n, "Ethereum (Sepolia)"],
	[17000n, "Ethereum (Holesky)"],
	[42161n, "Arbitrum"],
	[421614n, "Arbitrum (Sepolia)"],
	[8453n, "Base"],
	[84532n, "Base (Sepolia)"],
	[10n, "Optimism"],
	[11155420n, "Optimism (Sepolia)"],
	[534352n, "Scroll"],
	[534351n, "Scroll (Sepolia)"],
	[59144n, "Linea"],
	[59141n, "Linea (Sepolia)"],
	// [324n, "ZKsync"],
	// [300n, "ZKsync (Sepolia)"],
	// [167000n, "Taiko"],
	// [167009n, "Taiko (Sepolia)"],
]);

// https://docs.ens.domains/ensip/9
// https://github.com/satoshilabs/slips/blob/master/slip-0044.md
const TYPE_ADDR = 'addr(bytes32,uint256)';
const TYPE_TEXT = 'text';
const TYPE_PUBKEY = 'pubkey';
const TYPE_CONTENTHASH = 'contenthash';
const TYPE_NAME = 'name';
const RECORDS = [
	{
		key: 'name',
	},
	{
		key: 'language',
		bonus: true,
	},
	{
		key: 'timezone',
		bonus: true,
	},
	{
		key: 'notice',
		class: 'notice'
	},
	{
		key: 'url',
		//icon: 'ğŸŒï¸',
		format(text, el) {
			if (text.startsWith('data:')) {
				let match = text.match(/^data:([a-z0-9-/]+)[;,]/i)
				el.append(create('span', {innerText: match ? match[1].toLowerCase() : 'Data', className: ['tags', 'minor']}));
			} else {
				let match = text.match(/^https?:\/\/(.*?)\/?$/i);
				return match ? match[1] : text; //el.append(create('span', {innerText: match ? match[1] : text, className: 'url'}));
			}
		},
		url(x) { return x; }
	},
	{
		key: 'location'
	},
	{
		key: 'phone',
		icon: 'â˜ï¸',
		url(x) { return `tel:${x}`; }
	},
	{
		key: 'email',
		icon: 'ğŸ“§ï¸',
		url(x) { return `mailto:${x}`; }
	},
	{
		key: 'com.twitter',
		icon: `<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 22 20"><path fill="var(--geist-fill, currentColor)" stroke="none" d="M16.99 0H20.298L13.071 8.26L21.573 19.5H14.916L9.702 12.683L3.736 19.5H0.426L8.156 10.665L0 0H6.826L11.539 6.231L16.99 0ZM15.829 17.52H17.662L5.83 1.876H3.863L15.829 17.52Z"/></svg>`,
		url(x) { return `https://twitter.com/${x}`; },
		fix: repair_social,
	},
	{
		key: 'farcaster',
		icon: '<img src="https://pbs.twimg.com/profile_images/1546487688601096192/QoG0ZVgH_400x400.jpg">',
		url(x) { return `https://warpcast.com/${x}`; },
		fix: repair_social,
		ens: true,
	},
	{
		key: 'lens',
		url(x) { return `https://hey.xyz/u/${x}`; },
		ens: true,
	},
	{
		key: 'com.github',
		icon: '<img src="https://github.githubassets.com/favicons/favicon.png">',
		url(x) { return `https://github.com/${x}`; }
	},
	{
		key: 'com.discord',
		icon: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="#5A57DD"><path d="M20.7273 5.45455C20.7273 5.45455 18.2264 3.49746 15.2727 3.27273L15.0065 3.80509C17.6771 4.45855 18.9022 5.39509 20.1818 6.54546C17.9755 5.41909 15.7969 4.36364 12 4.36364C8.20309 4.36364 6.02455 5.41909 3.81818 6.54546C5.09782 5.39509 6.55527 4.35546 8.99345 3.80509L8.72727 3.27273C5.62855 3.56564 3.27273 5.45455 3.27273 5.45455C3.27273 5.45455 0.479455 9.50455 0 17.4545C2.81564 20.7016 7.09091 20.7273 7.09091 20.7273L7.98491 19.5355C6.46745 19.008 4.75364 18.066 3.27273 16.3636C5.03891 17.7 7.70455 19.0909 12 19.0909C16.2955 19.0909 18.9611 17.7 20.7273 16.3636C19.2464 18.066 17.5325 19.008 16.0151 19.5355L16.9091 20.7273C16.9091 20.7273 21.1844 20.7016 24 17.4545C23.5205 9.50455 20.7273 5.45455 20.7273 5.45455ZM8.45455 15.2727C7.40018 15.2727 6.54545 14.2958 6.54545 13.0909C6.54545 11.886 7.40018 10.9091 8.45455 10.9091C9.50891 10.9091 10.3636 11.886 10.3636 13.0909C10.3636 14.2958 9.50891 15.2727 8.45455 15.2727ZM15.5455 15.2727C14.4911 15.2727 13.6364 14.2958 13.6364 13.0909C13.6364 11.886 14.4911 10.9091 15.5455 10.9091C16.5998 10.9091 17.4545 11.886 17.4545 13.0909C17.4545 14.2958 16.5998 15.2727 15.5455 15.2727Z"></path></svg>`,
	},
	{
		key: 'com.reddit',
		icon: '<img src="https://www.redditstatic.com/desktop2x/img/favicon/apple-icon-60x60.png">',
		url(x) { return `https://reddit.com/u/${x}`; },
	},
	{
		key: 'io.keybase',
		icon: '<img src="https://keybase.io/images/icons/icon-keybase-logo-48.png">',
		url(x) { return `https://keybase.io/${x}`; },
		fix: repair_social
	},
	{
		key: 'org.telegram',
		icon: '<img src="https://telegram.org/img/favicon-32x32.png">',
		url(x) { return `https://t.me/${x}`; },
		fix: repair_social
	},
	{
		key: 'com.linkedin',
		icon: '<img src="https://static.licdn.com/scds/common/u/images/logos/favicons/v1/favicon.ico">',
		url(x) { return `https://www.linkedin.com/in/${x}`; }
	},
	{
		type: TYPE_CONTENTHASH,
	},
	{
		type: TYPE_PUBKEY,
		bonus: true,
	},
	{
		coin: 0,
		name: 'btc',
		icon: `<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 500 500" role="img" class="sc-56a68b4b-0 nEsDk"><path fill="#F39321" d="M43.43 125.143c7.71-10.766 14.875-21.901 23.562-31.986 15.8-18.343 33.692-34.063 54.18-47.075 18.379-11.672 37.761-20.872 58.501-27.305 32.294-10.018 65.26-12.997 98.838-9.165 24.544 2.801 48.191 9.067 70.713 19.215 13.633 6.142 26.456 13.731 39.025 21.927 25.328 16.515 45.618 38.014 62.58 62.577 18.116 26.236 29.889 55.421 36.346 86.725 4.535 21.983 6.449 44.171 4.503 66.504-2.399 27.536-8.514 54.086-19.938 79.604-9.662 21.583-21.589 41.401-36.861 59.301-14.94 17.511-31.788 32.831-51.149 45.461-13.184 8.6-26.926 16.276-41.434 21.975-24.274 9.537-49.447 15.986-75.787 17.115-18.545.795-36.985.483-55.279-2.763-15.713-2.788-31.049-6.858-46.063-12.496-14.566-5.47-28.693-11.95-41.709-20.143-18.766-11.812-35.683-26.147-50.737-42.663-16.773-18.403-30.373-38.808-40.779-61.344-14.7-31.835-21.929-65.401-22.359-100.425-.162-13.173 1.349-26.244 3.105-39.283.126-.933-.002-1.899-.012-2.851 1.536-.952 1.4-2.618 1.677-4.071 3.906-20.483 10.494-40.059 19.418-58.906 3.162-6.674 7.525-12.764 9.659-19.928zm281.727 129.37c6.537-3.474 12.749-5.465 17.658-9.85 18.918-16.899 23.96-56.673-6.747-75.833-9.566-5.969-19.77-10.393-30.77-14.907 1.819-14.731 7.709-28.516 9.622-43.603-9.076-2.249-17.578-5.234-26.425-6.193l-10.674 41.837c-6.78-2.076-13.761-1.879-20.142-5.473 2.302-14.39 7.773-27.872 9.268-42.314-9.322-1.464-17.216-5.094-26.265-5.485l-10.586 42.215c-17.944-2.75-34.419-8.921-52.52-12.239-3.977 8.91-5.738 18.311-7.334 28.313 5.896 1.392 11.022 2.623 16.158 3.811 12.965 2.998 16.517 10.086 13.439 21.424-2.19 8.065-4.166 16.189-6.182 24.301-7.245 29.16-14.432 58.333-21.72 87.482-1.642 6.567-5.734 8.706-12.398 7.731-6.563-.96-12.757-3.907-19.99-3.693-3.136 10.032-9.378 18.871-11.588 29.946l51.344 13.08c-1.312 15.208-7.614 29.125-9.476 44.441l25.544 6.123c5.653-14.044 6.957-28.803 12.226-43.33 6.351 3.265 13.397 2.317 19.612 6.427l-10.178 42.077c8.986 3.216 17.753 4.528 26.758 6.77l10.578-42.386c2.123-1.091 3.676-.888 5.143-.574a132.886 132.886 0 0 0 42.676 2.14c12.368-1.373 23.343-6.088 32.148-15.372 9.791-10.323 14.71-22.952 17.078-36.535 1.93-11.065 1.436-22.277-5.06-32.071-5.091-7.674-12.084-13.53-21.197-18.26zM223.128 312.17c17.411 4.325 34.803 8.95 53.02 5.624 9.715-1.774 17.037-6.73 19.985-16.503 2.78-9.218 1.164-17.593-5.673-24.879-7.11-7.576-16.254-11.514-25.682-14.807-11.264-3.934-22.683-7.508-34.99-8.48l-13.972 56.788c2.981.929 5.117 1.712 7.312 2.257zm61.5-80.324c9.628-1.368 17.612-7.738 19.958-16.393 2.869-10.583-.337-19.865-8.902-26.178-9.718-7.163-20.908-10.807-32.47-13.337-4.307-.943-8.544-3.454-13.756-1.759l-12.599 51.209c16.457 4.155 31.611 8.753 47.769 6.458z"></path></svg>`,
		btc: {p2pkh: 0, p2sh: 5, hrp: 'bc', p2wpkh: 0, p2tr: 1},
		url(x) { return `https://blockstream.info/address/${x}`; },
	},
	{
		coin: 2,
		name: 'ltc',
		icon: `<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 500 500" role="img" class="sc-56a68b4b-0 nEsDk"><circle cx="249.8" cy="250.2" r="248.4" style="fill: rgb(51, 94, 159);"></circle><path d="m139.4 402.6 37-120.2-40.3 12.3 10.7-29.6 37-11.5 51.7-170.1c1.1-3.6 4.5-6.1 8.3-6.1h52.8c5.8 0 9.9 5.6 8.3 11.1l-42 140.4 37.9-10.7-6.9 28.6-39.1 11.8-27.3 87.2h139c4.2 0 7.2 4 6.1 8L360.5 398c-.8 2.7-3.2 4.6-6.1 4.6h-215z" style="fill: rgb(255, 255, 255);"></path></svg>`,
		btc: {p2pkh: 0x30, p2sh: 0x32, hrp: 'ltc', p2wpkh: 0},
		url(x) { return `https://litecoinspace.org/address/${x}`; }
	},
	{
		coin: 3,
		name: 'doge',
		icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2000 2000" role="img" class="sc-56a68b4b-0 nEsDk"><g fill="#c2a633"><path d="M1024 659H881.12v281.69h224.79v117.94H881.12v281.67H1031c38.51 0 316.16 4.35 315.73-327.72S1077.44 659 1024 659z"></path><path d="M1000 0C447.71 0 0 447.71 0 1000s447.71 1000 1000 1000 1000-447.71 1000-1000S1552.29 0 1000 0zm39.29 1540.1H677.14v-481.46H549.48V940.7h127.65V459.21h310.82c73.53 0 560.56-15.27 560.56 549.48 0 574.09-509.21 531.41-509.21 531.41z"></path></g></svg>`,
		btc: {p2pkh: 0x1E, p2sh: 0x16},
		url(x) { return `https://dogechain.info/address/${x}`; }
	},
	{
		coin:  8444,
		name: 'chia',
		icon: 'ğŸŒ±ï¸',
		bech32: {hrp: 'xch', type: Bech32.M},
		url(x) { return `https://xchscan.com/address/${x}`; },
		bonus: true
	},
	{
		evm: 0,
		name: 'default-evm',
		icon: '<img src="https://ethereum.org/favicon.ico">',
	},
	{
		evm: 137,
		name: 'polygon',
		icon: '<img src="https://assets-global.website-files.com/637359c81e22b715cec245ad/63f775c741010796d62770fd_polygon-favicon.png">',
		url(x) { return `https://polygonscan.com/address/${x}`; },
		//bonus: true,
	},
	{
		evm: 10,
		name: 'op',
		icon: '<img src="https://assets-global.website-files.com/611dbb3c82ba72fbc285d4e2/612d2f8f988b5f801bd0cf1e_favicon.png">',
		url(x) { return `https://optimistic.etherscan.io/address/${x}`; },
		//bonus: true,
	},
	{
		evm: 11155420,
		name: 'op-sepolia',
		chain: 11155111,
		icon: '<img src="https://assets-global.website-files.com/611dbb3c82ba72fbc285d4e2/612d2f8f988b5f801bd0cf1e_favicon.png">',
		url(x) { return `https://sepolia-optimistic.etherscan.io/address/${x}`; },
	},
	{
		evm: 8453,
		name: 'base',
		icon: '<img src="https://base.org/document/favicon-32x32.png">',
		url(x) { return `https://basescan.org/address/${x}`; },
	},
	{
		evm: 84532,
		name: 'base-sepolia',
		chain: 11155111,
		icon: '<img src="https://base.org/document/favicon-32x32.png">',
		url(x) { return `https://sepolia.basescan.org/address/${x}`; },
	},
	{
		evm: 42161,
		name: 'arb1',
		icon: '<img src="https://arbitrum.foundation/favicon.ico">',
		url(x) { return `https://arbiscan.io/address/${x}`; },
	},
	{
		evm: 421614,
		name: 'arb1-sepolia',
		chain: 11155111,
		icon: '<img src="https://arbitrum.foundation/favicon.ico">',
		url(x) { return `https://sepolia.arbiscan.io/address/${x}`; },
	},
	{
		evm: 59144,
		name: 'linea',
		icon: '<img src="https://linea.build/favicon-32x32.png">',
		url(x) { return `https://lineascan.build/address/${x}`; },
	},
	{
		evm: 59141,
		name: 'linea-sepolia',
		chain: 11155111,
		icon: '<img src="https://linea.build/favicon-32x32.png">',
		url(x) { return `https://sepolia.lineascan.build/address/${x}`; },
	},
	{
		evm: 534352,
		name: 'scroll',
		url(x) { return `https://scrollscan.com/address/${x}`; },
	},
	{
		evm: 534351,
		chain: 11155111,
		name: 'scroll-sepolia',
		url(x) { return `https://sepolia.scrollscan.com/address/${x}`; },
	},
	{
		evm: 43114,
		name: 'avax',
		icon: '<img src="https://assets-global.website-files.com/632993e1d1acbfa5635afd0b/63515267b3214c6dda03ea97_Favicon.png">',
		url(x) { return `https://snowtrace.dev/address/${x}`; },
		bonus: true,
	},
	{
		evm: 100,
		legacy: 700,
		name: 'gnosis', // xdai
		url(x) { return `https://gnosisscan.io/address/${x}`; },
		bonus: true,
	},
	{
		evm: 324,
		name: 'zksync',
		url(x) { return `https://explorer.zksync.io/address/${x}`; },
		bonus: true,
	},
	{
		evm: 7777777,
		name: 'zora',
		url(x) { return `https://explorer.zora.energy/address/${x}`; },
		bonus: true,
	},
	{
		coin: 714,
		name: 'bnb',
		bech32: {hrp: 'bnb', type: 1},
		url(x) { return `https://explorer.bnbchain.org/address/${x}`; },
		bonus: true,
	},
	{
		coin: 118,
		name: 'atom',
		icon: '<img src="https://atomscan.com/img/icons/chains/atom.svg">',
		bech32: {hrp: 'cosmos', type: 1},
		url(x) { return `https://atomscan.com/account/${x}`; },
		bonus: true
	},
	{
		coin: 195,
		name: "tron",
		base58check: true,
		url(x) { return `https://tronscan.org/#/address/${x}`; },
		bonus: true,
	},
	{
		coin: 501,
		name: 'sol',
		base58: true,
		url(x) { return `https://explorer.solana.com/address/${x}`; },
		bonus: true,
	},
	{
		coin: 1815,
		name: 'ada',
		icon: '<img src="https://raw.githubusercontent.com/spothq/cryptocurrency-icons/master/32/color/ada.png">',
		bech32: {hrp: 'addr', type: 1},
		url(x) { return `https://cexplorer.io/address/${x}`; },
		bonus: true
	},
	{
		evm: 56,
		name: 'bsc',
		url(x) { return `https://bscscan.com/address/${x}`; },
		bonus: true,
	},
	{
		evm: 250,
		legacy: 1007,
		name: 'ftm',
		url(x) { return `https://explorer.fantom.network/address/${x}`; },
		bonus: true,
	},
	{
		evm: 42220,
		legacy: 52752,
		name: 'celo',
		url(x) { return `https://explorer.celo.org/mainnet/address/${x}`; },
		bonus: true,
	},
	{
		evm: 81457,
		name: 'blast',
		url(x) { return `https://blastscan.io/address/${x}`; },
		bonus: true,
	},
	// {
	// 	type: TYPE_ADDR,
	// 	evm: 5,
	// 	name: 'goerli',
	// 	url(x) { return `https://goerli.etherscan.io/address/${x}`; },
	// 	bonus: true,
	// 	testnet: true,
	// },
	// {
	// 	type: TYPE_ADDR,
	// 	evm: 11155111 ,
	// 	name: 'sepolia',
	// 	url(x) { return `https://sepolia.etherscan.io/address/${x}`; },
	// 	bonus: true,
	// 	testnet: true,
	// },
	{
		key: 'description',
	},
	{
		key: 'avatar',
		format() {},
	},
	{
		key: 'header',
		url: false,
		format(data, a) {
			let spinner = create('div', {className: ['avatar', 'spinner']});
			a.append(spinner);
			fetch_resource_url(data).then(res => {
				if (!a.isConnected) return;
				spinner.remove();
				if (res.error) {
					a.append(create('span', {
						className: ['tags', 'changed'],
						innerHTML: 'âŒï¸ Failed',
						title: res.error
					}));
					make_click_copy(a, data);
				} else {
					a.href = res.url;
					a.append(create('img', {
						src: res.url,
						style: {width: '100%', maxWidth: '512px'}
					}));
					a.append(create('span', {className: ['tags', 'minor'], innerText: res.type}));
					a.classList.add('rtrim');
				}
			});
		},
	},
	{
		key: 'verifications',
		format() {},
	}
].map(prepare_record);
function expand_record(rec) {
	if (typeof rec === 'string') {
		return {key: rec};
	} else if (Number.isInteger(rec)) {
		return rec < 0 ? {evm: rec} : {coin: rec};
	} else {
		return {...rec};
	}
}
function prepare_record(rec) {
	try {
		if (typeof rec.key === 'string') {
			rec.type = TYPE_TEXT;
		} else if (typeof rec.coin !== 'undefined') {
			rec.coin = BigInt(rec.coin);
			rec.evm = chain_from_coin(rec.coin);
			rec.type = TYPE_ADDR;
		} else if (typeof rec.evm !== 'undefined') {
			rec.evm = BigInt(rec.evm);
			// https://docs.ens.domains/ensip/11
			if (rec.evm >= EVM_BIT) throw new Error('invalid chain');
			rec.type = TYPE_ADDR;
			rec.coin = rec.evm + EVM_BIT;
		} else if (!rec.type) {
			throw new Error('unknown type');
		}
		return rec;
	} catch (err) {
		throw new Error(`${err.message}: ${JSON.stringify(rec)}`);
	}
}

const location0 = new URL(window.location.href);

let debug_enabled;
let debug_settings;
let window_provider;
let active_provider;
let active_chain;
let resolve_timer = RESOLVE_MODE_IDLE;
let resolve_state;
let network_state;
let history_timer;
let rpc_count = 0;
let lookup_count = 0;
let last_fetch_request;

version_span.innerHTML = `v${versions.version}`;
version_span.title = `Library: ${versions.version} (${versions.built})\nUnicode: ${versions.unicode}\nCLDR: ${versions.cldr}`;
version_span.addEventListener('click', () => {
	window.alert(Object.entries(versions).map(([k, v]) => `[${k}]\n${v}`).join('\n\n'));
});
Object.defineProperty(window, 'Debug', {
	get() { return {RECORDS, CHAINS, network_state, resolve_state, versions}; }
});

function keycap(i) {
	return String.fromCodePoint(0x30+i, 0xFE0F, 0x20E3);
}
const KEYCAP_MINUS = 'â–ï¸';
const KEYCAP_NAME = 'Keycap';
const DIGIT_MAP = new Map(Array.from({length: 10}, (_, i) => [keycap(i), i]));
const DIGITS_MAP = new Map();
function add_digits(name, digits, extra = {}) {
	explode_cp(digits).forEach((cp, i) => DIGIT_MAP.set(cp, {name, i, ...extra}));
	DIGITS_MAP.set(name, digits);
}
add_digits('ASCII', '0123456789');
add_digits('Arabic', 'Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©', {mixed: 1});
[[0x6F4, 4], [0x6F5, 5], [0x6F6, 6]].forEach(([cp, i]) => {
	DIGIT_MAP.set(cp, {name: 'Extended Arabic', i, mixed: 1});
});
add_digits('CJK', 'ã€‡ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹');
add_digits('Devangari', 'à¥¦à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯');
add_digits('Thai', 'à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™');
//add_digits('Bengali', 'à§¦à§§à§¨à§©à§ªà§«à§¬à§­à§®à§¯');
//add_digits('Tamil', 'à¯¦à¯§à¯¨à¯©à¯ªà¯«à¯¬à¯­à¯®à¯¯');

for (let btn of $$('#examples button:not([id]), button[data-name]')) {
	let name = btn.innerText;
	if (btn.dataset.name) name = btn.dataset.name;
	if (typeof btn.dataset.raw !== 'string') name = replace_escapes(name);
	if (!btn.innerText || btn.innerText.includes('{')) btn.innerText = name;
	let meta = typeof btn.dataset.meta === 'string' || name.includes(':') || is_checksum_address(name);
	try {
		if (meta || name !== ens_normalize(name)) {
			btn.classList.add('mapped');
		}
	} catch (err) {
		btn.classList.add('error');
	}
	if (!meta) name = add_dot_eth(name);
	if (typeof btn.dataset.escape === 'string') name = apply_escapes_where(name);
	if (!btn.title) btn.title = meta ? name : `${name}\n${explode_cp(name).map(hex_cp).join(' ')}`;
	btn.addEventListener('click', () => {
		input_field.value = name;
		if (btn.dataset.skip) skip_norm_check.checked = true;
		if (options_div.getBoundingClientRect().top > window.innerHeight * .9) {
			options_div.scrollIntoView(); // scuffed
		}
		let delay = parseInt(btn.dataset.delay)|0;
		if (delay > 0) {
			schedule_resolve(delay);
		} else {
			resolve();
		}
	});
}
for (let x of $$('[data-tokenize]')) {
	let components = !!x.dataset.parts;
	x.replaceWith(dom_from_tokens(ens_tokenize(replace_escapes(x.dataset.tokenize)), {
		components,
		emoji(a, {emoji}) {
			a.href = `#${encodeURIComponent(String.fromCodePoint(...emoji))}`;
			a.addEventListener('click', () => {
				show_components_check.checked = components;
				save_settings();
			});
		},
		tld: true
	}));
}
resolve_btn.addEventListener('click', e => {
	if (e.altKey) {
		let name = input_field.value;
		let pos = name.indexOf('.');
		input_field.value = pos >= 0 ? name.slice(pos+1) : '';
	}
	resolve();
});
input_field.addEventListener('keydown', e => {
	if (e.key === 'Enter') {
		e.stopPropagation();
		if (e.shiftKey) input_field.value = add_dot_eth(input_field.value.trim(), true);
		resolve();
	} else if (e.key === 'Escape') {
		e.preventDefault();
		input_field.value = '';
		resolve();
	}
});
input_field.addEventListener('input', () => {
	if (parse() && auto_resolve_check.checked) schedule_resolve();
});

window.addEventListener('storage', e => {
	if (e.type === 'storage' && e.key === STORAGE_RECENT) {
		sync_recent(e.newValue);
	}
});
function sync_recent(saved) {
	recent_optgroup.innerHTML = '';
	try {
		JSON.parse(saved).reverse().forEach(x => add_recent(x, false));
	} catch (err) {
	}
}
recent_select.addEventListener('change', () => {
	let option = recent_select.selectedOptions[0];
	recent_select.selectedIndex = -1;
	if (!option) return;
	if (recent_optgroup.contains(option)) {
		input_field.value = option.value;
		resolve();
	} else if (option.value === 'reset') {
		recent_select.classList.add('hide');
		recent_optgroup.innerHTML = '';
		localStorage[STORAGE_RECENT] = '[]';
	}
});
function add_recent(name, save = true) {
	if (!name) return;
	let found;
	for (let x of recent_optgroup.children) {
		if (x.value === name) {
			recent_optgroup.prepend(x); // move to top
			found = true;
			break;
		}
	}
	if (!found) {
		while (recent_optgroup.childElementCount >= 25) { // max
			recent_optgroup.lastChild.remove();
		}
		let option = new Option();
		option.value = name;
		if (is_checksum_address(name)) {
			option.innerHTML = `ğŸ ï¸ ${name}`;
		} else {
			try {
				let norm = ens_normalize(name);
				option.innerHTML = `${norm === name ? 'âœ…ï¸' : 'â˜‘ï¸'} ${name}`;
			} catch (err) {
				option.innerHTML = `âŒï¸ ${apply_escapes_where(name, cp => should_escape(cp) || cp == 0x20)}`;
			}
		}
		recent_optgroup.prepend(option);
	}
	recent_select.selectedIndex = -1;
	recent_select.classList.remove('hide');
	if (save) {
		localStorage[STORAGE_RECENT] = JSON.stringify([...recent_optgroup.children].map(x => x.value));
	}
}

function get_selected_input() {
	let {value, selectionStart, selectionEnd} = input_field;
	if (selectionEnd > selectionStart) {
		value = value.slice(selectionStart);
	}
	return replace_escapes(value);
}
function resolve_random_emoji(only_singles) {
	let name = '';
	let pool = only_singles ? EMOJI.filter(cps => cps.length == 1 || (cps.length == 2 && cps[1] === 0xFE0F)) : EMOJI;
	while ([...name].length < MIN_ETH_LENGTH) {
		name += ens_normalize(str_from_cps(pool[Math.random() * pool.length|0]));
	}
	input_field.value = add_dot_eth(name);
	skip_norm_check.checked = false;
	resolve();
}
$('#find_emoji_btn').addEventListener('click', e => {
	if (e.altKey) {
		resolve_random_emoji();
	} else if (e.shiftKey) {
		resolve_random_emoji(true);
	} else {
		let url = './emoji.html';
		let value = get_selected_input();
		let token = ens_tokenize(value).find(x => x.emoji);
		if (token) url += `#q=${encodeURIComponent(String.fromCodePoint(...token.cps))}`;
		create_link(url).click();
	}
});
$('#chars_btn').addEventListener('click', e => {
	let url = './chars.html';
	let value = get_selected_input();
	if (value) url += `#${value.codePointAt(0).toString(16)}`;
	create_link(url).click();
});
$('#confused_btn').addEventListener('click', e => {
	create_link(`./confused.html#${encode_uri_component_surrogate_escaped(input_field.value.replaceAll('.', ''))}`).click();
});
nf_btn.addEventListener('click', () => {
	let s0 = input_field.value;
	let s1 = replace_escapes(s0);
	let s2 = apply_escapes_where(str_from_cps(nfd(explode_cp(s1))));
	let s3 = apply_escapes_where(str_from_cps(nfc(explode_cp(s1))));
	if (s2 === s3 && s2 === apply_escapes_where(s1)) return; // do nothing
	input_field.value = s0 == s2 ? s3 : s2;
	resolve();
});
escape_btn.addEventListener('click', e => {
	let s0 = input_field.value;
	let s1 = replace_escapes(s0);
	let s2 = apply_escapes_where(s1, undefined, e.altKey);
	let s3 = apply_escapes_where(s1, () => true, e.altKey);
	let set = [...new Set([s1, s2, s3])];
	let pos = set.indexOf(s0);
	input_field.value = set[(pos + 1) % set.length];
	update_location();
});
$('#copy_link_btn').addEventListener('click', () => {
	navigator.clipboard.writeText(get_page_url(true));
});
$('#copy_example_btn').addEventListener('click', () => {
	let url = get_page_url();
	url.hash = '#vitalik.eth';
	navigator.clipboard.writeText(url);
});

auto_resolve_check.addEventListener('input', () => {
	save_settings();
	if (auto_resolve_check.checked && input_field.value) {
		resolve();
	}
});
show_details_check.addEventListener('input', () => {
	save_settings();
	sync_settings();
});
show_records_check.addEventListener('input', () => {
	save_settings();
	sync_settings();
	if (show_records_check.checked && resolve_state && resolve_state.skipped_records) resolve();
});
show_components_check.addEventListener('input', () => {
	save_settings();
	update_exploded();
});
skip_norm_check.addEventListener('input', resolve);
force_ltr_check.addEventListener('input', () => {
	save_settings();
	sync_settings();
});
function sync_settings() {
	input_field.classList.toggle('force_ltr', force_ltr_check.checked);
	output_div.classList.toggle('hide_recs', !show_records_check.checked);
	output_div.classList.toggle('hide_details', !show_details_check.checked);
}

function sync_examples() {
	if (examples_div.classList.contains('hide')) {
		examples_btn.innerText = 'ğŸ‘€ Examples';
		options_div.prepend(examples_btn);
	} else {
		examples_btn.innerText = 'ğŸ™ˆ Hide Examples';
		examples_div.prepend(examples_btn);
	}
}
examples_btn.addEventListener('click', () => {
	examples_div.classList.toggle('hide');
	save_settings();
	sync_examples();
});

chain_select.replaceChildren(...CHAINS.map(x => create('option', {value: x.id}, x.name)));
chain_select.addEventListener('change', () => update_network());
mainnet_btn.addEventListener('click', () => {
	chain_select.value = 1;
	update_network();
});
browser_btn.addEventListener('click', () => {
	chain_select.value = window_provider.__chain.id;
	update_network();
});

function sync_debug() {
	debug_div.classList.toggle('hide', !debug_enabled);
	enable_debug_btn.classList.toggle('hide', !!debug_enabled);
	if (debug_enabled) {
		debug_ta.value = Object.keys(debug_settings).length ? stringify(debug_settings, DEBUG_INDENT) : '';
	}
}
enable_debug_btn.addEventListener('click', () => {
	debug_enabled = true;
	save_settings();
	sync_debug();
	debug_ta.scrollIntoView();
});
$('#clean_debug_btn').addEventListener('click', () => {
	debug_ta.value = '';
	apply_debug();
});
$('#disable_debug_btn').addEventListener('click', () => {
	debug_enabled = false;
	save_settings();
	sync_debug();
	if (resolve_state.debug) resolve();
});
$('#apply_debug_btn').addEventListener('click', apply_debug);
function apply_debug() {
	try {
		let settings = JSON.parse(debug_ta.value.trim() || '{}');
		if (!is_object(settings)) throw new Error('expected object');
		let {ccip, records, resolver} = settings;
		if (ccip) {
			if (typeof ccip === 'string') {
				settings.ccip = {'*': ccip};
			} else if (is_object(ccip)) {
				settings.ccip = Object.fromEntries(Object.entries(ccip).map(([k, v]) => [k === '*' ? k : ethers.getAddress(k.toLowerCase()), new URL(v).toString()])); // validate and format
			} else {
				throw new Error('expected "ccip" {address: endpoint}');
			}
		}
		if (resolver) {
			if (!is_object(resolver)) {
				throw new Error('expected "resolver" {name: address}');
			}
			settings.resolver = Object.fromEntries(Object.entries(resolver).map(([k, v]) => [ens_normalize(k), ethers.getAddress(v)])); // validate and format
		}
		if (records) {
			if (!Array.isArray(records)) throw new Error('expected "records" array');
			for (let x of records) {
				prepare_record(expand_record(x)); // only validate
			}
		}
		let dirty = stringify(debug_settings) !== stringify(settings);
		if (dirty) {
			debug_settings = settings;
			save_settings();
		}
		sync_debug(); // pretty
		if (debug_settings !== resolve_state.debug) resolve();
	} catch (err) {
		window.alert(err.message);
	}
}
function stringify(json, indent) {
	return JSON.stringify(json, (_, x) => {
		if (typeof x === 'bigint') {
			return `0x${x.toString(16)}`;
		} else {
			return x;
		}
	}, indent);
}
debug_ta.addEventListener('keydown', e => {
	if (e.key === 'Enter' && e.shiftKey) {
		e.preventDefault();
		apply_debug();
	} else if (e.key === 'Tab') {
		e.preventDefault();
		document.execCommand('insertText', false, DEBUG_INDENT);
	}
});
debug_ta.placeholder = `{
	// resolver rewrites: name -> contract
	"resolver": {
		"domain.fake": "0x32aC8A721A0d9Ce85F88599228297BBa8E183044"
	},
	// ccip endpoint rewrites: contract -> endpoint
	"ccip": {
		"0x32aC8A721A0d9Ce85F88599228297BBa8E183044": "https://localhost:80/"
	},
	// additional records
	"records": [
		"avatar" or {"key": "avatar"}, // text()
		1234     or {"coin": 1234},    // addr()
		-5       or {"evm": 5}         // addr() via ENSIP-11
	],
	// misc interface stuff
	"jazz": true,    // debug jazz icons
	"fuzes": true,   // debug wrapper fuses interface
	"primary": true, // debug primary normalization
}`.replaceAll('\t', DEBUG_INDENT);
function set_page_url(url) {
	apply_page_url(url);
	if (!update_network()) {
		resolve();
	}
}
window.addEventListener('popstate',   e => set_page_url(new URL(e.state || '', location0)));
window.addEventListener('hashchange', e => set_page_url(new URL(e.newURL)));
window.addEventListener('unload', () => {}); // prevent weird restore behavior

// cleanup non-namespaced keys
// TODO: remove me
for (let k of Object.keys(localStorage)) {
	if (!k.includes('.')) {
		localStorage.removeItem(k);
	}
}

function save_settings() {
	localStorage[STORAGE_SETTINGS] = stringify({
		hide_examples: examples_div.classList.contains('hide'),
		auto_resolve: auto_resolve_check.checked,
		show_details: show_details_check.checked,
		show_components: show_components_check.checked,
		show_records: show_records_check.checked,
		force_ltr: force_ltr_check.checked,
		debug_enabled,
		debug_settings
	});
}
try {
	let settings = JSON.parse(localStorage[STORAGE_SETTINGS]);
	examples_div.classList.toggle('hide', !!settings.hide_examples);
	auto_resolve_check.checked = settings.auto_resolve;
	show_details_check.checked = settings.show_details;
	show_components_check.checked = settings.show_components;
	show_records_check.checked = settings.show_records;
	force_ltr_check.checked = settings.force_ltr;
	({debug_enabled, debug_settings} = settings);
} catch (err) {
}

// one-time parse options
parse_check(show_details_check, 'details');
parse_check(show_records_check, 'records');
parse_check(show_components_check, 'components');
function parse_check(check, key) {
	let value = location0.searchParams.get(key);
	if (value === null) return;
	check.checked = is_truelike_str(value);
}
if (location0.searchParams.has('debug')) {
	try {
		debug_settings = JSON.parse(location0.searchParams.get('debug'));
		debug_enabled = true;
	} catch (err) {
	}
}

if (!is_object(debug_settings)) debug_settings = {};
sync_recent(localStorage[STORAGE_RECENT]);
sync_settings();
sync_examples();
sync_debug();
apply_page_url(location0);
input_field.focus();

const ccipReadFetchOld = ethers.AbstractProvider.prototype.ccipReadFetch;
ethers.AbstractProvider.prototype.ccipReadFetch = function(tx, calldata, urls) {
	lookup_count++;
	try {
		let rewrite = resolve_state.debug.ccip[tx.to] || resolve_state.debug.ccip['*'];
		if (rewrite) urls = [rewrite];
	} catch (err) {
	}
	if (resolve_state.debug?.ccip_proxy) {
		urls = urls.map(x => resolve_state.debug.ccip_proxy.replace('$', encodeURI(x)));
	}
	return ccipReadFetchOld.call(this, tx, calldata, urls);
};

if (window.ethereum) {
	// 20240913: on browser launch, window.ethereum is wonky
	// https://github.com/MetaMask/metamask-extension/issues/27150
	if (ethereum._state) {
		let killer = setTimeout(() => window.location.reload(), 1000);
		let monitor = setInterval(() => {
			if (ethereum._state.initialized) {
				clearInterval(monitor);
				clearTimeout(killer);
				init();
			}
		}, 100);
	} else {
		init();
	}
	function init() {
		window_provider = new ethers.BrowserProvider(ethereum, 'any');
		add_ccip_timeout(window_provider);
		window.__provider = window_provider;
		window.__ethereum = ethereum;
		// we cant access request.preflightFunc, this is the next best thing
		let send = window_provider.send.bind(window_provider);
		window_provider.send = async (...a) => {
			if (a[0] === 'eth_call') ++rpc_count;
			try {
				return await send(...a);
			} catch (err) {
				// 20240913: brave/metamask/infura bug???
				if (err.info?.error?.data?.originalError) {
					err.data = err.info.error.data.originalError.data;
				}
				throw err;
			}
		};
		const timer = setTimeout(() => set_window_network(), 2000);
		if (ethereum.isConnected()) {
			window_provider._detectNetwork().then(connected, () => {});
		}
		ethereum.on('connect', ({chainId}) => {
			connected(ethers.Network.from(parseInt(chainId)));
		});
		function connected(network) {
			clearTimeout(timer);
			ethereum.on('chainChanged', chainId => set_window_network(ethers.Network.from(parseInt(chainId))));
			ethereum.once('disconnect', () => set_window_network());
			set_window_network(network);
		}
	}
} else {
	update_network();
}

async function change_window_to_chain(chain) {
	let chainId = `0x${chain.id.toString(16)}`;
	try {
		await window_provider.send('wallet_switchEthereumChain', [{chainId}]);
		// throws on cancel request
		// throws on unknown provider
	} catch (err) {
		if (is_user_rejection(err)) return;
		if (err.error && err.error.code === 4902) { // unrecognized chain
			let {public: rpc} = chain;
			if (!rpc) throw new Error(`Unknown RPC for ${chain.name}\nNetwork: ${format_dec_hex(chain.id)}`);
			try {
				// https://eips.ethereum.org/EIPS/eip-3085
				await window_provider.send('wallet_addEthereumChain', [{
					chainId,
					chainName: chain.name,
					blockExplorerUrls: [chain.explorer],
					nativeCurrency: {
						name: `${chain.name} ETH`,
						symbol: 'ETH',
						decimals: 18
					},
					rpcUrls: [rpc]
				}]);
				set_window_network(await window_provider._detectNetwork());
				return;
			} catch (err2) {
				if (is_user_rejection(err2)) return;
				err = err2;
			}
		}
		throw err;
	}
}
function set_window_network(network) {
	window_provider.__network = network;
	window_provider.__chain = null;
	if (network) {
		let chain_id = Number(network.chainId); // BigInt
		let chain = CHAINS.find(x => x.id === chain_id);
		if (chain) {
			window_provider.__chain = chain;
		}
	}
	update_network();
}
function update_network() {
	let changed;
	let chain_id = parseInt(chain_select.value);
	let chain = CHAINS.find(x => x.id === chain_id) || CHAINS[0];
	if (window_provider && window_provider.__chain === chain) {
		active_provider = window_provider;
	} else {
		let old = active_provider;
		if (old === window_provider || active_chain !== chain) {
			//let request = new ethers.FetchRequest(chain.rpc || `https://${chain.name.toLowerCase()}.infura.io/v3/f36f6a8638134ac09f9400d3a7008dfe`);
			//let request = new ethers.FetchRequest(`https://rpc.ankr.com/${chain.ankr}/4f33b3901537986c548375fa2d307572637cca0f4a4f17d5a4944ca27fee5ea9`)
			let request = new ethers.FetchRequest(chain.drpc);
			request.preflightFunc = req => {
				last_fetch_request = req;
				++rpc_count;
				return req;
			};
			active_provider = new ethers.JsonRpcProvider(request, chain.id, {
				batchMaxCount: 3,
				//batchStallTime: 0,
				staticNetwork: true
			});
			add_ccip_timeout(active_provider);
		}
		if (old && old !== window_provider && old !== active_provider) {
			setTimeout(() => old.destroy(), 0);
		}
	}
	if (active_chain !== chain) {
		let init = !active_chain;
		changed = true;
		active_chain = chain;
		network_state = {
			// registry contract address is static on all supported chains
			ens: new ethers.Contract('0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e', [
				'function resolver(bytes32 node) external view returns (address)',
				'function owner(bytes32 node) external view returns (address)',
			], active_provider),
			// multicall3 contract address is static on all supported chains
			// https://www.multicall3.com/deployments
			multicall: new ethers.Contract('0xcA11bde05977b3631167028862bE2a173976CA11', [
				`function tryAggregate(bool requireSuccess, tuple(address target, bytes data)[] memory calls) public view returns (tuple(bool ok, bytes data)[] memory returnData)`
			], active_provider),
		};
		if (input_field.value) {
			schedule_resolve(0);
		} else if (init) {
			parse();
		}
	} else {
		// reconnect to the current provider
		for (let [k, x] of Object.entries(network_state)) {
			if (x instanceof ethers.Contract) {
				network_state[k] = x.connect(active_provider);
			}
		}
	}
	let using_window = active_provider === window_provider;
	update_location();
	document.body.classList.toggle('testnet', !active_chain.is_mainnet);
	chain_select.title = `Network: ${format_dec_hex(active_chain.id)}`;
	mainnet_btn.classList.toggle('hide', !!active_chain.is_mainnet);
	browser_btn.classList.toggle('hide', !(!using_window && window_provider && window_provider.__chain && !window_provider.__chain.is_mainnet));
	provider_div.replaceChildren(create('div', {className: 'network'}, 'using ', create_explorer_address_link(network_state.ens.target, {
		innerHTML: using_window ? 'Browser' : active_chain.rpc ? 'Public RPC' : 'dRPC',
		title: 'ENS Registry Contract',
		contract: true
	})));
	if (!using_window && window_provider && window_provider.__network) {
		provider_div.append(create('button', {
			innerHTML: 'Switch Browser', //`Browserâ†’${active_chain.name}`,
			title: 'Change browser to match selected network',
			click() {
				change_window_to_chain(active_chain);
			}
		}));
		if (!window_provider.__chain) {
			let {name} = window_provider.__network;
			if (name === 'unknown') {
				name = format_dec_hex(window_provider.__network.chainId);
			}
			provider_div.append(create('div', {className: 'notice', innerHTML: `ğŸš«ï¸ Browser: ${name}`}));
		}
	}
	return changed;
}
function add_ccip_timeout(provider) {
	provider.on('debug', x => {
		if (x.action === 'sendCcipReadFetchRequest') {
			//x.request.timeout = 10000; // currently 5 minutes (doesn't work)
			setTimeout(() => x.request.cancel(), 10000);
			last_fetch_request = x.request;
		}
	});
}

function should_stop_resolving() {
	return resolve_timer !== RESOLVE_MODE_IDLE;
}
function check_abort() {
	if (should_stop_resolving()) throw new Error('aborted');
}

function schedule_resolve(delay = 1000) {
	clearTimeout(resolve_timer);
	if (is_working()) {
		resolve_timer = [Date.now() + delay]; // encode as future time
	} else {
		primary_loader.classList.remove('hide'); // pre-start
		resolve_timer = setTimeout(resolve, delay);
	}
}

function stop_resolving() {
	clearTimeout(resolve_timer);
	resolve_timer = RESOLVE_MODE_EMPTY;
	primary_loader.classList.add('hide');
}

function apply_page_url(url) {
	chain_select.value = (CHAINS.find(x => url.searchParams.has(x.slug)) || CHAINS[0]).id;
	skip_norm_check.checked = url.searchParams.has('skip');
	input_field.value = decodeURIComponent(url.hash.slice(1));
	if (input_field.value.endsWith('_!')) { // backwards compat
		input_field.value = input_field.value.slice(0, -2);
		skip_norm_check.checked = true;
	}
}
function get_page_url(debug) {
	let input = input_field.value;
	let url = new URL(location0);
	let args = [];
	if (!active_chain.is_mainnet) args.push(active_chain.slug);
	if (skip_norm_check.checked) args.push('skip');
	if (debug && debug_enabled) args.push(`debug=${encodeURIComponent(stringify(debug_settings))}`);
	url.search = args.join('&');
	url.hash = input ? '#' + encode_uri_component_surrogate_escaped(input) : '';
	return url;
}
function get_page_title() {
	let title = 'ENS Resolver';
	let input = input_field.value;
	if (input) {
		title += `: â€œ${input}â€`;
		if (skip_norm_check.checked) {
			title += ' (!)';
		}
	}
	if (!active_chain.is_mainnet) {
		title += ` @ ${active_chain.name}`;
	}
	return title;
}
function update_location() {
	let url = get_page_url().toString();
	if (!window.history.state) {
		window.history.replaceState(null, null, url);
	} else if (window.history.state != url) {
		window.history.pushState(null, null, url);
	}
	document.title = get_page_title();
	clearTimeout(history_timer);
}
function parse() {
	if (!active_chain) return; // wait for init
	update_location();
	let input0 = input_field.value;
	let width = ens_tokenize(input0, {nf: false}).reduce((a, x) => {
		if (x.type === 'valid') return x.cps.reduce((b, y) => b + (is_combining_mark(y, true) ? 0.5 : 1), a);
		return a + (x.emoji ? 2 : 1);
	}, 0);
	input_field.classList.toggle('small',   width >= 21);
	input_field.classList.toggle('smaller', width >= 36);
	let skip = skip_norm_check.checked;
	nf_btn.disabled = !input0;
	escape_btn.disabled = !input0;
	show_components_label.classList.add('hide');
	output_div.innerHTML = '';
	clock_span.innerHTML = '';
	resolve_state = {};
	if (!input0) {
		stop_resolving();
		output_div.append(...readme_dom);
		return;
	}
	// TODO: conslidate this code with resolve()
	let input = replace_escapes(input0);
	if (resolve_timer === RESOLVE_MODE_EMPTY) {
		resolve_timer = RESOLVE_MODE_IDLE;
	}
	if (is_checksum_address(input)) {
		let row = create_row('Address');
		row.append(create_explorer_address_link(input));
		add_row_tag(row, create_reverse_resolve_btn(input));
		output_div.append(row);
		return true;
	}
	let row = create_row(INPUT_NAME);
	let tokens = ens_tokenize(input);
	if (tokens.some(x => x.emoji)) show_components_label.classList.remove('hide');
	make_exploded(row, input, false);
	add_input_features(row, input);
	output_div.append(row, create_breakdown_row(input, true));
	try {
		let norm = ens_normalize(input);
		if (norm === input) {
			make_normalized(row, norm);
		} else {
			add_row_tag(row, create_tag('fail', 'Normalized'));
			if (!skip) {
				add_transformed_row(input);
				let norm_row = create_row('Normalized');
				make_exploded(norm_row, norm, true);
				make_normalized(norm_row, norm);
				add_ensip1_tag(norm_row, input, true);
				output_div.append(norm_row, create_breakdown_row(norm));
			}
		}
		add_ensip1_tag(row, input);
		//output_div.append(create_dns_row(norm));
		return true;
	} catch (err) {
		row.classList.add('error');
		add_row_tag(row, create_tag('norm', err));
		if (skip) return true;
		add_ensip1_tag(row, input);
		stop_resolving();

		// if there is a fully ignorable label
		let collapsed = ens_split(input).filter(x => !x.tokens || x.tokens.length).map(x => str_from_cps(x.input)).join('.');
		if (collapsed !== input) {
			add_row_tag(row, create('button', {
				innerText: 'ğŸ’¥ï¸ Collapse Empty Labels',
				click() {
					input_field.value = collapsed;
					resolve();
				}
			}));
		}

		// if there is whitespace
		let stripped = input.replace(/\s+/g, '');
		if (stripped !== input) {
			add_row_tag(row, create('button', {
				innerText: 'âœ‚ï¸ Strip Whitespace',
				click() {
					input_field.value = stripped;
					resolve();
				}
			}));
		}

		// if there are likely unmapped mistakes
		const SLOPPY_MAP = new Map([
			[0x2F, 0x2044],
			[0x3002, 0x2E],
			[0xFF0E, 0x2E],
			[0xFF61, 0x2E],
		]);
		let sloppy = str_from_cps(explode_cp(input).map(x => SLOPPY_MAP.get(x) || x))
		if (sloppy !== input) {
			add_row_tag(row, create('button', {
				innerHTML: 'ğŸ’£ï¸ Unsafe Replace',
				title: `Replace the following characters:` + [...SLOPPY_MAP.entries()].map(([a, b]) => {
					return `\n"${safe_str_from_cps([a])}" ${hex_cp(a)} â†’ "${safe_str_from_cps([b])}" ${hex_cp(b)}`
				}).join(''),
				click() {
					input_field.value = sloppy;
					resolve();
				}
			}));
		}

		// if there are disallowed characters
		if (tokens.some(x => x.type === 'disallowed')) {
			try {
				ens_normalize(stripped);
			} catch (err) {
				// and they aren't just whitespace
				add_row_tag(row, create('button', {
					innerHTML: 'âŒ Remove Disallowed',
					click() {
						input_field.value = str_from_cps(tokens.flatMap(t => t.type === 'nfc' ? t.tokens0 : t).flatMap(t => {
							switch (t.type) {
								case 'disallowed': return [];
								case 'valid': return t.cps;
								case 'emoji': return t.input;
								default: return t.cp;
							}
						}));
						resolve();
					}
				}));
			}
		}

		// if there are normalizable parts
		if (tokens.some(x => x.type === 'nfc' || x.type === 'ignored' || x.type === 'mapped' || (x.type === 'emoji' && x.input.includes(0xFE0F)))) {
			add_row_tag(row, create('button', {
				innerHTML: 'ğŸ’ªï¸ Force Normalize',
				title: 'Apply normalization to each character separately',
				click() {
					input_field.value = str_from_cps(tokens.flatMap(token => {
						switch (token.type) {
							case 'ignored': return []; // removes ignored (dangerous)
							case 'mapped': // applies known mappings
							case 'emoji': // removes FE0F from known emoji
							case 'nfc':
							case 'valid': return token.cps;
							default: return token.cp;
						}
					}));
					resolve();
				}
			}));
		}
	}
}

function add_transformed_row(input) {
	if (ens_tokenize(input).some(x => x.type === 'nfc' || x.type === 'mapped')) {
		let row = create_row('Transform');
		row.classList.add('transform');
		make_detailed(row);
		make_exploded(row, input, true);
		output_div.append(row);
	}
}
function add_input_features(row, input) {
	add_row_tag(row, create_dot_eth_button(input));
	if (/^0x[0-9a-f]{40}$/i.test(input)) {
		add_row_tag(row, create_resolve_btn(ethers.getAddress(input.toLowerCase()), 'ğŸ› ï¸ Fix Checksum'));
	}
	add_row_tag(row, create_copy_btn(input));
	add_row_tag(row, create_namehash_button(input));
	let ncp = create_tag('length', [...input].length);
	ncp.title = `${bytes_from_utf8(input).length} bytes`;
	make_detailed(ncp, true);
	add_row_tag(row, ncp);
}
function create_dns_row(name, {replaced, contenthash} = {}) {
	let row = create_row(replaced ? 'Alternative DNS' : 'DNS');
	row.classList.add('dns');
	row.classList.remove('available'); // bug when inserted later
	try {
		const MAX_LABEL = 63;
		const MAX_NAME = 253;
		const VALID_REGEX = /^[-0-9a-z]*$/i;
		let encoded = name.split('.').map(label => {
			let cps = explode_cp(label);
			try {
				let encoded = puny_encoded(cps);//.toLowerCase();
				if (!VALID_REGEX.test(encoded)) {
					let first = [...encoded].find(ch => !VALID_REGEX.test(ch));
					throw new Error(`unsupported ASCII: "${safe_str_from_cps(explode_cp(first))}"`);
				}
				if (encoded === label) {
					if (label.startsWith('xn--')) throw new Error('punycode literal');
					if (label.slice(2, 4) === '--') throw new Error('invalid label extension');
					// 20230123: WHATWG URL uses "CheckHyphens" false
					//if (label.startsWith('-')) throw new Error('leading hyphen');
					//if (label.endsWith('-')) throw new Error('trailing hyphen');
				}
				if (encoded.length > MAX_LABEL) throw new Error(`too long: ${encoded.length} > ${MAX_LABEL}`);
				return encoded;
			} catch (err) {
				throw new Error(`Invalid label "${safe_str_from_cps(cps, 63)}": ${err.message}`);
			}
		}).join('.');
		if (encoded.length > MAX_NAME) {
			throw new Error(`Name too long: ${encoded.length} > ${MAX_NAME}`);
		}
		let browser;
		try {
			browser = new URL(`https://${name}`).host;
		} catch (ignored) {
		}
		row.append(create_main_span(encoded));
		add_row_tag(row, create_copy_btn(encoded));
		if (browser) {
			if (encoded === browser) {
				if (encoded === name) {
					add_row_tag(row, create_tag('good', 'Verbatim'));
				} else {
					add_row_tag(row, create_tag('star', 'Punycoded'));
				}
			} else if (encoded.toLowerCase() === browser) {
				add_row_tag(row, create_tag('warn', 'Uppercase'));
			} else {
				add_row_tag(row, create_tag('stop', 'Mangled'));
				add_row_tag(row, create_copy_btn(browser));
			}
		} else {
			add_row_tag(row, create_tag('stop', 'Incompatible'));
		}
		if (!replaced) {
			add_alternative_btn(row, name);
		}
		if (name.includes('\u200D')) {
			add_row_tag(row, create_tag('warn', 'ZWJ'));
		}
		if (active_chain.is_mainnet) {
			if (encoded.endsWith('.eth')) {
				let group = create('div', {className: ['grouped', 'external']});
				if (contenthash) {
					add_row_tag(row, create_link(`https://${encoded}.limo`, {button: 'â†—ï¸ .limo', className: 'external'}));
				} else {
					add_row_tag(group, create_link(`https://${encoded}.limo`, {innerHTML: '.limo'}));
				}
				add_row_tag(group, create_link(`https://${encoded}.link`, {innerHTML: '.link'}));
				add_row_tag(group, create_link(`https://${encoded}.li`,   {innerHTML: '.li',}));
				add_row_tag(group, create_link(`https://${encoded}.xyz`,  {innerHTML: '.xyz',}));
				add_row_tag(group, create_link(`https://${encoded}.co`,   {innerHTML: '.co',}));
				row.append(group);
			} else {
				add_row_tag(row, create_link(`https://${encoded}`, {button: 'â†—ï¸ Website', className: 'external'}));
			}
		}
		add_row_tag(row, create_link(`../../punycode.js/test/demo.html#u=${encode_uri_component_surrogate_escaped(name)}`, {button: EMOJI_CHECK}));
	} catch (err) {
		row.classList.add('invalid');
		add_row_tag(row, create_tag('fail', err));
		if (!replaced) {
			add_alternative_btn(row, name);
		}
	}
	return row;

}

// try some transformations
function add_alternative_btn(row, name) {
	let alt = name;
	try {
		alt = ens_beautify(alt);
	} catch (err) {
	}
	alt = str_from_cps(explode_cp(name).map(cp => {
		if (cp >= 0x660 && cp <= 0x669) {
			return cp + 0x90; // try other arabic digits
		} else {
			return cp;
		}
	}));
	if (alt !== name) {
		add_row_tag(row, create('button', {
			innerText: 'ğŸ¥ˆï¸ Try Alternative',
			click() {
				row.replaceWith(create_dns_row(alt, {replaced: true}));
			}
		}));
	}
}

function is_safe_ascii(cp) {
	// same as:
	//return !should_escape(cp) && cp != 0x20;
	return cp >= 0x21 && cp <= 0x7E;
}
function unicode_escape_cp(cp) {
	return `\\u${hex_cp(cp).padStart(4, '0')}`; // be nice
}
function unicode_escape(s) {
	return explode_cp(s).map(unicode_escape_cp).join('');
}
function entity_escape(s) {
	return explode_cp(s).map(cp => is_safe_ascii(cp) ? String.fromCodePoint(cp) : `&#x${hex_cp(cp)};`).join('');
}
// escape where escape_fn is true (default: non-ascii)
// unicode: use \u-format
function apply_escapes_where(s, escape_fn, unicode) {
	if (!escape_fn) escape_fn = cp => !is_safe_ascii(cp);
	return explode_cp(s).map(cp => {
		return escape_fn(cp) ? unicode ? unicode_escape_cp(cp) : quote_cp(cp) : String.fromCodePoint(cp);
	}).join('');
}
function replace_escapes(s) {
	// match: \u{HEX}, {HEX}, \uXXXX, [0xHEX], [DEC]
	return s.replace(/(?:(?:(?:\\u)?\{([0-9a-f]+)\}|\\u([0-9a-f]{4}))|(?:\[((?:0x[0-9a-f]+)|[0-9]+)\]))/uig, (_, hex1, hex2, num) => {
		try {
			return String.fromCodePoint(num ? parseInt(num) : parseInt(hex1 || hex2, 16));
		} catch (err) {
			return 'ï¿½';
		}
	});
}
function encode_uri_component_ens_escaped(s) {
	return s.split('.').map(x => {
		try {
			if (ens_normalize(x) === x) {
				return encodeURIComponent(x);
			}
		} catch (err) {
		}
		return `[${labelhash(x).slice(2)}]`; // support unlinkable/unnormalized stuff
	}).join('.');
}
function encode_uri_component_surrogate_escaped(s) {
	return encodeURIComponent(apply_escapes_where(s, is_surrogate));
}
function create_link(url, {button, buttonClass, ...args} = {}) {
	let a = create('a', {
		href: url,
		target: '_blank',
		innerText: url,
		...args
	});
	if (button) {
		a.classList.add('button');
		a.replaceChildren(create('button', {
			innerHTML: button,
			className: buttonClass,
			click(e) {
				e.stopPropagation(); // prevent copy
			}
		}));
	}
	try {
		new URL(url, location0);
	} catch (err) {
		a.classList.add('invalid');
	}
	return a;
}
function create_ens_link(name, title = 'ENS') {
	try {
		if (ens_normalize(name) === name) {
			return create_link(`${active_chain.manager}/${encode_uri_component_surrogate_escaped(name)}`, {button: title, buttonClass: 'ens', className: 'ens'});
		}
	} catch (err) {
	}
}
function create_explorer_address_link(addr, {innerHTML, anchor = '', contract, className, ...a} = {}) {
	if (!innerHTML) {
		innerHTML = addr;
		className = 'addr';
	}
	if (contract && !anchor) anchor = '#readContract';
	return create_link(`${active_chain.explorer}/address/${addr}${anchor}`, {innerHTML, title: `Explorer: ${addr}`, className, ...a});
}
function create_jazz_icon(address) {
	let {addrs, debug} = resolve_state;
	let i = addrs.get(address);
	if (debug && debug.jazz) address += addrs.size; // force unique
	if (!i) addrs.set(address, i = addrs.size + 1);
	return create('span', {innerHTML: i, className: ['jazz', `addr${i}`]});
	//return create('span', {innerHTML: i, className: 'jazz', style: {backgroundColor: `hsl(${((i+1)*83)%360} 75 50)`}});
}
function make_click_copy(el, raw, {hint} = {}) {
	if (el.title) el.title += `\n(Click to Copy)`;
	el.dataset.copy = raw;
	el.addEventListener('click', function(e) {
		e.preventDefault();
		e.stopPropagation();
		let {copy, alt, shift} = this.dataset;
		if (e.altKey) {
			copy = alt || explode_cp(copy).map(hex_cp).join(' ');
		} else if (e.shiftKey) {
			copy = shift || '0x' + Array.from(bytes_from_utf8(copy), hex_cp).join('');
		}
		const cls = 'copied';
		$$(`.${cls}`).forEach(x => x.classList.remove(cls));
		navigator.clipboard.writeText(copy);
		this.classList.add(cls);
		setTimeout(() => this.classList.remove(cls), 2000);
	});
	return el;
}
function create_copy_btn(raw, {small, value, alt} = {}) {
	let btn = create('button', {className: 'copy'});
	if (small) btn.classList.add('small');
	if (alt) btn.dataset.alt = alt;
	btn.title = value ? raw : make_exploded_utf8_title(raw);
	make_click_copy(btn, raw);
	return btn;
}
function make_exploded_utf8_title(raw) {
	let cps = explode_cp(raw);
	return [
		raw,
		cps.map(hex_cp).join(' '),
		`[ALT] Codepoints (${cps.length})`,
		`[SHIFT] UTF-8 Bytes (${bytes_from_utf8(raw).length})`,
	].join('\n');
}
function get_reverse_name(addr, chain = 1n) {
	let slug;
	if (chain === 1n) {
		slug = 'addr';
	} else if (chain === 0n) {
		slug = 'default';
	} else {
		slug = (EVM_BIT + chain).toString(16);
	}
	if (addr) {
		slug = `${addr.slice(2).toLowerCase()}.${slug}`;
	}
	return `${slug}.reverse`;
}
function parse_reverse_name(name) {
	const match = name.match(/^(?:([a-f0-9]+)\.|)(addr|default|[0-9a-f]+)\.reverse$/);
	if (!match) return;
	let [_, address, coin] = match;
	if (address) address = `0x${address}`;
	let offchain;
	if (coin === 'default') {
		coin = EVM_BIT;
	} else if (coin === 'addr') {
		coin = 60n;
	} else {
		coin = BigInt('0x' + coin);
		offchain = true;
	}
	const evm = chain_from_coin(coin);
	const is_evm = typeof evm === 'bigint';
	const network = is_evm ? CHAIN_NAMES.get(evm) : RECORDS.find(x => x.coin == coin)?.name;
	return {address, coin, evm, is_evm, network, offchain};
}
function create_reverse_resolve_btn(addr) {
	const select = create('select', {
		change() {
			input_field.value = get_reverse_name(addr, BigInt(this.value));
			resolve();
		},
	});
	select.append(create('option', {disabled: true, selected: true}, 'Reverse Name'));
	for (const [id, name] of CHAIN_NAMES) {
		select.append(create('option', {value: id.toString(10)}, name));
	}
	return select;
	//return create_resolve_btn(get_reverse_name(addr), 'â™»ï¸ Reverse Name');
}
function create_resolve_btn(name, innerHTML = 'â†©ï¸ Resolve') {
	let title = `Resolve: ${name}`;
	let addr = is_address(name);
	if (addr) {
		title += `\n[ALT] Reverse Name`;
	}
	return create('button', {
		innerHTML,
		title,
		click(e) {
			input_field.value = addr && e.altKey ? get_reverse_name(name) : name;
			resolve();
		}
	});
}
function create_main_span(text) {
	return create('span', {className: 'maxh'}, create('span', {innerText: text, className: ['main', 'long']}));
}
function upgrade_split_type(info) {
	let flat = flatten_tokens(info.tokens);
	info.confusing = determine_confusion(str_from_cps(info.input), flat);
	info.style = determine_style(flat);
}

function flatten_tokens(tokens) {
	return tokens.flatMap(t => t.is_emoji ? String.fromCodePoint(...t) : t);
}

// from https://raffy.antistupid.com/eth/ens-regs.html
function determine_confusion(label, flat) {
	let match;
	if (/[Ä…Ã§Ä™ÅŸÃ¬Ã­Ã®Ã¯ÇÅ‚]/u.test(label)) {
		return 'Rare';
	} else if (/l\d{2,}/i.test(label) || /\d{2,}l/i.test(label)) {
		return 'Digits+L';
	} else if (has_repeated_run(flat, 10)) {
		return 'Many';
	} else if (match = get_similar_emoji(flat)) {
		return match;
	} else if (/^0x[0-9a-f]{18,}/i.test(label)) {
		return is_address(label) ? 'Address' : 'Address-like';
	}
}
function determine_style(flat) {
	if (flat.length < 2) return;
	let palindrome = true;
	for (let a = 0, b = flat.length - 1; palindrome && a < b; a++, b--) {
		palindrome = flat[a] === flat[b];
	}
	if (palindrome) {
		if (flat.every(x => flat[0] === x)) {
			return `Repeated (${flat.length})`;
		} else {
			return 'Palindrome';
		}
	}
}

function has_repeated_run(flat, thres) {
	let prev, count;
	for (let x of flat) {
		if (prev !== x) {
			prev = x;
			count = 1;
		} else if(++count >= thres) {
			return true;
		}
	}
}

function get_similar_emoji(flat) {
	let set = new Set(flat.filter(x => typeof x === 'string'));
	if (!set.size) return;
	let conflicts = [
		['ğŸ‡ºğŸ‡¸', 'ğŸ‡ºğŸ‡²'],
		['â¤', 'â™¥'],
	];
	for (let [primary, ...similar] of conflicts) {
		let p = set.has(primary);
		let n = similar.reduce((a, x) => a + +set.has(x), 0);
		if (p && n) {
			return `Mixed ${ens_beautify(primary)}`;
		} else if (!p && n) {
			return `Similar ${ens_beautify(primary)}`;
		}
	}
}

function make_normalized(row, name) {
	row.classList.add('normalized');
	let span = create('span', {
		title: 'Normalized Form',
		innerHTML: `âœ…ï¸`,
		className: 'normalized',
	});
	let split = ens_split(name);
	if (split.length > 1 && split[split.length-1].type === 'ASCII') {
		split.pop(); // remove ASCII TLD
	}
	let pure_ascii = split.every(x => x.type === 'ASCII');
	split.forEach(upgrade_split_type);
	if (pure_ascii) {
		span.classList.add('ascii');
		span.innerHTML = 'ASCII';
	} else {
		let types = new Set(split.map(x => x.type));
		if (types.has('Latin') && types.has('ASCII')) {
			types.delete('ASCII');
		}
		if (split.some(x => x.emoji)) {
			types.add('Emoji');
		} else {
			types.delete('Emoji');
		}
		span.innerHTML += ` ${[...types].sort().join('+')}`;
	}
	if (split.some(x => x.confusing)) {
		add_row_tag(row, create_tag('confusing', 'Possibly<br>Confusing'));
	}
	add_row_tag(row, span);
	try {
		if (name === ens_beautify(name)) {
			add_row_tag(row, create_pretty_tag());
		}
	} catch (err) {
	}
}

function make_detailed(el, invert) {
	el.classList.add(invert ? 'inv_detailed' : 'detailed');
}
function make_locked(row) {
	row.classList.add('locked');
}
async function make_contract(addr, row) {
	if (await is_contract(addr)) {
		row.classList.add('contract');
	}
}
function make_exploded(row, name, is_norm, components) {
	let before = !is_norm;
	let tokens_div = create_exploded(name, before, components);
	let old = row.querySelector('.exploded');
	if (old) {
		old.replaceWith(tokens_div);
	} else {
		row.append(tokens_div);
	}
}
function create_ethmoji_row(tokens, suffix) {
	let row = create_row('Ethmoji');
	row.classList.add('category', 'ethmoji');
	make_detailed(row);
	let tally = new Map();
	let last;
	for (let token of tokens) {
		let form = str_from_cps(token.emoji);
		let rec = tally.get(form);
		if (!rec) {
			rec = {form, count: 0, ...token};
			tally.set(form, rec);
		}
		++rec.count;
	}
	tally = [...tally.values()];
	let formula = create('div', {className: 'formula'});
	for (let rec of tally.values()) {
		formula.append(create_link(`./emoji.html#q=${str_from_cps(rec.cps)}`, {innerHTML: `${rec.form}<sup>${rec.count}</sup>`}));
	}
	row.append(formula);
	let span_grade = create('span');
	let min_repeated;
	if (tally.length == 1) {
		let ncp = tally[0].cps.length;
		let repeat = 1 + Math.max(0, MIN_ETH_LENGTH - ncp);
		if (tally[0].count === repeat) {
			add_row_tag(row, create_tag('fire', repeat == 1 ? 'Single' : 'Shortest'));
		} else {
			min_repeated = str_from_cps(tally[0].cps).repeat(repeat);
		}
	} else {
		add_row_tag(row, `Unique (${tally.length})`);
	}
	if (min_repeated) {
		add_row_tag(row, create_resolve_btn(min_repeated + suffix, 'â†©ï¸ Shortest'));
	}
	return row;
}

function create_digits_row(norm, group, values, negative, suffix) {
	let row = create_row('Integer'); // `${name0} Digits`
	row.classList.add('category', 'integer');
	make_detailed(row);
	let sign = negative ? '-' : '';
	let form = sign + values.join('');
	row.append(create('code', {innerText: form, className: ['main', 'long']}));
	if (values.length == (negative ? 2 : 3)) {
		add_row_tag(row, create_tag('fire', 'Shortest'));
	}
	// let pad = 0;
	// while (values[pad] === 0) pad++;
	// if (pad) {
	// 	add_row_tag(row, `Zero Pad (${pad})`);
	// }
	let btn = create_resolve_btn((negative ? KEYCAP_MINUS : '') + values.map(keycap).join('') + suffix, KEYCAP_NAME);
	btn.disabled = group === KEYCAP_NAME;
	add_row_tag(row, btn);
	for (let [name, digits] of DIGITS_MAP) {
		//if (name0 === name) continue;
		let btn = create_resolve_btn(sign + values.map(x => digits.charAt(x)).join('') + suffix, name);
		btn.disabled = group === name;
		add_row_tag(row, btn);
	}
	return row;
}

async function add_resolver_info(row, resolver, context) {
	let name = RESOLVER_NAMES[resolver.target];
	if (name && active_chain.is_mainnet) {
		add_row_tag(row, create_tag('good', name));
	} else if (resolver.__info.tor) {
		add_row_tag(row, create_tag('good', 'TOR'));
	}
	if (resolver.__info.dnssec_oracle) {
		add_row_tag(row, create_tag('good', 'DNSSEC', resolver.__info.dnssec_oracle));
	}
	const rev_match = parse_reverse_name(resolver.__name);
	if (rev_match) {
		add_row_tag(row, create_tag('good', rev_match.offchain ? 'Offchain Reverse' : 'Reverse'));
	}
	let resolve;
	if (context && resolver.__info.edns) {
		resolve = async x => resolver['resolve(bytes,bytes,bytes)'](resolver.__dns_encoded, x, context);
		add_row_tag(row, create_tag('special', 'Wildcard DNS'));
	} else if (resolver.__info.wild) {
		resolve = async x => resolver['resolve(bytes,bytes)'](resolver.__dns_encoded, x);
		add_row_tag(row, create_tag('special', 'Wildcard'));
	} else if (!await is_contract(resolver.target)) {
		add_row_tag(row, create_tag('fail', 'Not a Contract'));
	}
	if (resolver.__info.wild && resolver.__basename) {
		if (resolver.__dropped) {
			add_row_tag(row, create('span', {innerText: resolver.__dropped, className: 'dist', title: 'Distance to Basename'}));
			add_row_tag(row, create_resolve_btn(resolver.__basename, `â†©ï¸ Basename: <code class="framed">${ens_beautify(resolver.__basename)}</code>`));
		} else {
			add_row_tag(row, 'Basename');
		}
	}
	if (resolve && resolver.__dns_encoded) {
		add_row_tag(row, create('button', {
			innerText: 'ğŸ”ï¸ Gateways',
			async click() {
				add_spinner(this);
				this.disabled = true;
				const calls = [];
				if (rev_match?.offchain) {
					const name = get_reverse_name(ethers.ZeroAddress, rev_match.evm);
					const calldata = resolver.interface.encodeFunctionData('name(bytes32)', [namehash(name)]);
					calls.push(resolver['resolve(bytes,bytes)'](dns_encoded_from(name), calldata));
				} else {
					calls.push(resolve(resolver.interface.encodeFunctionData('addr(bytes32,uint256)', [resolver.__node, 1n << 255n])));
					calls.push(resolve(resolver.interface.encodeFunctionData('addr(bytes32,uint256)', [resolver.__node, 60n])));
					calls.push(resolve(resolver.interface.encodeFunctionData('text(bytes32,string)', [resolver.__node, '__dne'])));
					calls.push(resolve(resolver.interface.encodeFunctionData('name(bytes32)', [resolver.__node])));
				}
				const settled = await Promise.allSettled(calls);
				const gateways = new Set();
				const verifiers = new Set();
				for (const res of settled) {
					if (res.reason instanceof Error && res.reason.revert?.name === 'OffchainLookup') {
						for (let g of res.reason.revert.args.gateways) {
							gateways.add(g.replace(/data\=0x[0-9a-f]*/i, 'data=0x'));
						}
						try {
							const [verifier] = ethers.AbiCoder.defaultAbiCoder().decode(['(address, bytes, (bytes), bytes4, bytes)'], res.reason.revert.args.carry)[0]; 
							verifiers.add(verifier);
						} catch (err) {
						}
					}
				}
				if (verifiers.size) {
					const sub_row = create_row('Unruggable Verifier');
					row.insertAdjacentElement('afterend', sub_row);
					for (const x of verifiers) {
						add_row_tag(sub_row, create_explorer_address_link(x, {contract: true}));
						add_row_tag(sub_row, create_copy_btn(resolver.target, {value: true}));
					}
				}
				if (gateways.size) {
					const sub_row = create_row('Gateways');
					row.insertAdjacentElement('afterend', sub_row);
					for (const x of gateways) {
						add_row_tag(sub_row, create('span', {className: ['raw', 'long'], innerText: x}));
					}
					this.remove();
				} else {
					this.innerText = `âš ï¸ Unknown Gateways`;
				}
			}
		}));
	}
	if (resolve) {
		add_spinner(row);
		get_safe_primary(resolver.target).catch(() => {}).then((name) => {
			remove_temporary(row);
			if (name) {
				row.querySelector('.addr').innerHTML = name;
			}
		});
	}
}

function add_ensip1_tag(row, input, is_norm) {
	const OLD_NAME = 'ENSIP-1';
	let tag = create('span', {className: ['tags', 'ensip1']});
	try {
	 	let norm1 = eth_ens_namehash.normalize(input);
		let norm15;
		try {
			norm15 = ens_normalize(input);
		} catch (err) {
		}
		 // norm1 exists but norm15 might not
		let html = OLD_NAME;
		if (norm15 !== input && norm1 !== norm15) { // change + disagree
			html += `: âš ï¸<b>Diff Norm</b>`;
		}
		if (norm1 === input) { // ensip1 === input
			tag.innerHTML = html;
			tag.title = SAME_AS_INPUT;
		} else if (norm1 === norm15) { // we agree but we dont match the input
			throw new Error('not normalized');
		} else { // we disagree
			tag = create_resolve_btn(norm1, `â†©ï¸ ${html}`);
			//tag.title = [[15, norm15], [1, norm_1]].map(([i, s]) => `[ENSIP-${i}] ${s ? safe_str_from_cps(explode_cp(s)) : 'âŒï¸'}`).join('\n');
		}
	} catch (err) {
		tag.innerHTML = `âŒï¸ ${OLD_NAME}`;
		tag.title = err.message;
	}
	add_row_tag(row, tag);
}

function add_nft_links(row, name, contract, token) {
	let group = create('div', {className: ['grouped', 'external']});
	add_row_tag(group, create_link(`${active_chain.metadata}/${contract}/${token}`, {innerHTML: 'Metadata'}));
	add_row_tag(group, create_link(`${active_chain.explorer}/nft/${contract}/${BigInt(token)}`, {innerHTML: 'Explorer'}));
	if (active_chain.opensea) {
		add_row_tag(group, create_link(`${active_chain.opensea}${contract}/${BigInt(token)}`, {innerHTML: OPENSEA_NAME}));
	}
	if (active_chain.is_mainnet) {
		try {
			let encoded = encodeURIComponent(name);
			if (encoded.endsWith('.eth')) {
				add_row_tag(group, create_link(`https://${VISION_HOST}/name/${encoded.slice(0, -4)}`, {innerHTML: VISION_NAME}));
			}
			//add_row_tag(group, create_link(`http://predomain.eth.limo/#/domain/${encoded}`, {innerHTML: 'Predomain'}));
			add_row_tag(group, create_link(`http://ethfollow.xyz/${encoded}`, {innerHTML: 'EFP'}));
		} catch (err) {
		}
	}
	row.append(group);
}

// https://github.com/adraffy/keccak.js/blob/main/src/utils.js#L96
function bytes_from_utf8(s) {
	let v = [];
	for (let pos = 0, len = s.length; pos < len; ) {
		let cp = s.codePointAt(pos++);
		if (cp < 0x800) {
			if (cp < 0x80) {
				v.push(cp);
			} else {
				v.push(0xC0 | (cp >> 6), 0x80 | (cp & 0x3F));
			}
		} else {
			if (cp < 0x10000) {
				v.push(0xE0 | (cp >> 12), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
			} else {
				v.push(0xF0 | (cp >> 18), 0x80 | ((cp >> 12) & 0x3F), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
				pos++;
			}
		}
	}
	return Uint8Array.from(v);
}
function utf8_from_bytes(v) {
	let cps = [];
	for (let i = 0, n = v.length; i < n; ) {
		let x = v[i++];
		if (x < 0x80) {
			cps.push(x);
		} else if (x < 0xE0) {
			cps.push(((x & 0x1F) << 6) | req_utf8_cont(v, i++));
		} else if (x < 0xF0) {
			cps.push(((x & 0x0F) << 12) | (req_utf8_cont(v, i++) << 6) | req_utf8_cont(v, i++));
		} else {
			cps.push(((x & 0x07) << 18) | (req_utf8_cont(v, i++) << 12) | (req_utf8_cont(v, i++) << 6) | req_utf8_cont(v, i++));
		}
	}
	return str_from_cps(cps);
}
function req_utf8_cont(v, i) {
	let x = v[i];
	if ((x & 0xC0) != 0x80) throw new Error(`malformed utf8 at ${i}: expected continuation`);
	return x & 0x3F;
}
function create_exploded(name, before, components) {
	// tokenize each label separately so we can show major/minor errors
	// flatten non-errors tokens into wrapper
	let split = ens_split(name);
	let wrapper = create('div', {className: ['tokens', 'exploded', 'maxh']});
	let first = true;
	for (let i = 0; i < split.length; i++) {
		if (i > 0) {
			wrapper.append(...dom_from_tokens(ens_tokenize('.')).children);
		}
		let {input, error} = split[i];
		let label = str_from_cps(input);
		let tokens = dom_from_tokens(ens_tokenize(label), {
			before,
			tld: i === split.length-1,
			components: components || show_components_check.checked,
			emoji(a, {emoji}) {
				a.href = `./emoji.html#q=${encodeURIComponent(String.fromCodePoint(...emoji))}`;
				a.target = '_blank';
			},
		});
		if (error) {
			tokens.classList.add('error');
			if (first) {
				tokens.classList.add('first');
				first = false;
			}
			wrapper.append(tokens);
		} else {
			wrapper.append(...tokens.children);
		}
	}
	wrapper.dataset.name = name;
	if (before) wrapper.dataset.before = 1;
	if (components) wrapper.dataset.components = 1;
	return wrapper;
}
function update_exploded() {
	for (let x of output_div.querySelectorAll('.exploded')) {
		let tokens_div = create_exploded(x.dataset.name, x.dataset.before, x.dataset.components);
		if (x.dataset.downgraded) {
			apply_downgrade(tokens_div);
		}
		x.replaceWith(tokens_div);
	}
}

function apply_downgrade(tokens_div) {
	tokens_div.dataset.downgraded = '1';
	for (let x of tokens_div.querySelectorAll('.disallowed')) {
		x.classList.add('ignored');
		x.classList.remove('disallowed');
	}
}

function add_reg_exp_tags(row, exp, now) {
	let span = create_tag('reg', `âœï¸ Registered until ${new Date(exp).toLocaleDateString()}`);
	add_row_tag(row, span);
	if (exp - now < 45 * 86400) {
		add_row_tag(row, create_tag('warn', `Expires in ${format_dur(exp - now)}`));
	} else {
		span.innerHTML += ` (${format_dur(exp - now)})`;
	}
}
function create_dot_eth_button(name) {
	let added = add_dot_eth(name);
	if (added !== name) {
		let btn = create_resolve_btn(added, '<b>.eth</b> <span class="key">shift+enter</span>');
		btn.classList.add('rtrim');
		return btn;
	}
}
function create_elapsed(dt, rpcs, lookups, final) {
	let tag = create_tag('elapsed', format_dur(dt, final ? 2 : 1));
	if (lookups || final) {
		tag.prepend(create('span', {innerText: `${lookups}âœˆ`, className: 'requests', title: 'Offchain Lookups'}));
	}
	if (rpcs || final) {
		tag.prepend(create('span', {innerText: `${rpcs}â‡…`, className: 'requests', title: 'RPC Requests'}));
	}
	return tag;
}
function create_elapsed_since() {
	const now = Date.now();
	let {t, r, l} = resolve_state;
	let dt = now - t;
	let dr = rpc_count - r;
	let dl = lookup_count - l;
	resolve_state.t = now;
	resolve_state.r = rpc_count;
	resolve_state.l = lookup_count;
	if (dt || dr || dl) return create_elapsed(dt, dr, dl);
}
function create_pretty_tag() {
	return create_tag('clean', PRETTY_NAME, 'Beautified Form');
}
function create_tag(type, value, title) {
	if (!value) return;
	let span = create('span', {className: 'tags', title});
	if (value instanceof Error) {
		value = value.message;
		span.classList.add('long');
	}
	switch (type) {
		case 'star':
			type = 'attn';
			value = `â­ï¸ ${value}`;
			break;
		case 'norm':
			make_detailed(span, true);
			// fallthru
		case 'warn':
			type = 'note';
			value = `âš ï¸ ${value}`;
			break;
		case 'fire':
			value = `ğŸ”¥ï¸ ${value}`;
			break;
		case 'fail':
			value = `âŒï¸ ${value}`;
			break;
		case 'stop':
			type = 'fail';
			value = `ğŸ›‘ï¸ ${value}`;
			break;
	}
	span.innerHTML = value;
	span.classList.add(type);
	return span;
}
function add_row_tag(row, tag) {
	if (!tag) return;
	if (typeof tag === 'string') {
		tag = create('span', {innerHTML: tag});
	}
	tag.classList.add('tags');
	row.append(tag);
	return tag;
}

function create_namehash_button(name) {
	let node = namehash(name);
	let btn = create('button', {innerHTML: 'ğŸ†”ï¸'});
	make_detailed(btn, true);
	make_click_copy(btn, node);
	let lines = [`Namehash: ${node}`];
	try {
		let hex = ethers.hexlify(dns_encoded_from(name));
		btn.dataset.alt = hex;
		lines.push(`[ALT] DNS-encoded: ${hex}`);
	} catch (err) {
	}
	lines.push('(Click to Copy)');
	btn.title = lines.join('\n');
	return btn;
}
function create_namehash_breakdown(name) {
	let node = namehash(name);
	let div = create('div', {className: 'hash'});
	div.append(create_link(`../../keccak.js/test/demo.html#algo=namehash&s=${encode_uri_component_surrogate_escaped(name)}&escape=1`, {innerText: 'Namehash:'}));
	div.append(create('code', {innerText: node, className: 'long'}));
	div.append(create_copy_btn(node, {small: true, value: true}));
	return div;
}
function create_dns_breakdown(name) {
	let div = create('div', {className: 'hash'});
	div.append(create('b', {innerText: 'Length:'}));
	div.append(create_tag('length', [...name].length));
	div.append(create_tag('bytes', bytes_from_utf8(name).length));
	div.append(' â€¢ ')
	div.append(create('b', {innerText: 'DNS-encoded:'}));
	try {
		let v = dns_encoded_from(name);
		div.append(create_tag('bytes', v.length), create_copy_btn(ethers.hexlify(v), {small: true, value: true}));
	} catch (err) {
		div.append(create('span', {innerText: 'ğŸš«ï¸', title: err.message}));
	}
	return div;
}
function create_breakdown_row(name, before) {
	let outer = create('div', {className: 'breakdown'});
	if (resolve_state.available) outer.classList.add('available');
	make_detailed(outer);
	outer.append(create_namehash_breakdown(name));
	outer.append(create_dns_breakdown(name));
	let split = ens_split(name);
	for (let i = 0; i < split.length; i++) {
		let info = split[i];
		info.index = i;
		info.cps = before || !info.output ? info.input : info.output;
		info.label = str_from_cps(info.cps);
	}
	for (let info of split) {
		let row = create('div', {className: 'label'});

		//row.append(create_tag('index', info.index+1));

		let span_name = create('span', {className: ['name', 'long']});
		if (info.label) {
			span_name.innerText = info.label;
			row.append(span_name);
			row.append(create_copy_btn(info.label, {small: true}));
		}
		if (info.label) {
			row.append(create_tag('length', info.cps.length));
			row.append(create_tag('bytes', bytes_from_utf8(info.label).length));
		}
		if (info.error) {
			row.classList.add('error');
			row.append(create('span', {innerText: `âŒï¸ ${info.error.message}`, className: 'error'}));
		} else if (compare_arrays(info.input, info.output)) { // mapped or nfc
			row.classList.add('mapped');
			row.append(create_tag('note', 'Normalizable'));
		} else {
			row.classList.add('valid');
			upgrade_split_type(info);
			if (info.confusing) {
				row.append(create_tag('confusing', info.confusing));
			}
			if (info.type.startsWith('Restricted[')) {
				let script = info.type.slice(11, -1);
				row.append(create_link(`https://www.compart.com/en/unicode/scripts/${script}`, {innerHTML: `âš ï¸ ${script} (Restricted)`, className: ['tags', 'restricted']}));
			} else if (info.type !== 'Emoji') {
				row.append(create_tag('type', info.type));
			}
			if (info.emoji) {
				row.append(create_tag('emoji', 'Emoji'));
			}
			if (info.style) {
				row.append(create_tag('good', info.style));
			}
		}
		outer.append(row);

		if (info.label) {
			let hash = labelhash(info.label);
			let hash_div = create('div', {className: ['hash', 'minor', 'first']});
			hash_div.append(create_link(`../../keccak.js/test/demo.html#algo=keccak-256&s=${encode_uri_component_surrogate_escaped(info.label)}&escape=1`, {innerHTML: 'Labelhash:'}));
			hash_div.append(create('code', {innerText: hash, className: 'long'}));
			hash_div.append(create_copy_btn(hash, {small: true, value: true}));
			outer.append(hash_div);

			let parent = split.slice(info.index + 1).map(x => x.label).join('.');
			if (NFT_DOMAINS.has(parent)) {
				let token = BigInt(hash).toString();
				let token_div = create('div', {className: ['hash', 'minor']});
				token_div.append(create('b', {innerText: 'Token:'}));
				token_div.append(create('code', {innerText: token, className: 'long'}));
				token_div.append(create_copy_btn(token, {small: true, value: true}));
				outer.append(token_div);
			}
		}
	}
	return outer;
}

function create_row(label) {
	let row = create('div', {className: 'row'});
	if (resolve_state.available) row.classList.add('available');
	if (label) {
		let span = create('span', {className: 'row-label'});
		if (typeof label === 'string') {
			span.innerHTML = label;
		} else {
			span.append(label);
		}
		row.append(span);
	}
	return row;
}
function add_spinner(row) {
	row.append(create('div', {innerHTML: '<div class="spinner"></div>', className: 'temporary'}));
}
function remove_temporary(row) {
	for (let x of row.querySelectorAll('.temporary')) {
		x.remove();
	}
}

function trim_trailing_decimal_zeros(s) {
	return s.includes('.') ? s.replace(/\.?0*$/, '') : s;
}
function format_dur(t, n = 1) {
	if (t < 500) return `${Math.ceil(t)}ms`;
	t /= 1000;
	let unit;
	if (t < 60) {
		unit = 's';
	} else {
		t /= 60;
		if (t < 60) {
			unit = 'm';
		} else {
			t /= 60;
			if (t < 24) {
				unit = 'Êœ';
			} else {
				t /= 24;
				if (t < 365) {
					unit = 'á´…';
				} else {
					t /= 365;
					unit = 'Ê';
				}
			}
		}
	}
	return trim_trailing_decimal_zeros(t.toFixed(n)) + unit;
}

function is_working() {
	return resolve_btn.disabled || !active_chain;
}
function resolve() {
	if (!active_chain) return;
	if (is_working()) {
		last_fetch_request?.cancel();
		resolve_timer = [0]; // ASAP
		return;
	}
	clearTimeout(resolve_timer);
	resolve_timer = RESOLVE_MODE_IDLE;
	let input = input_field.value;
	let skip = skip_norm_check.checked;
	// replace marketplace URL with token:XXX
	if (input.includes('://')) {
		try {
			let url = new URL(input);
			if ([VISION_HOST, 'ens.vision', 'www.ens.vision'].some(x => x === url.host)) {
				// /name/%F0%9F%91%A9%F0%9F%8F%BC%E2%80%8D%F0%9F%A6%BC%E2%80%8D%E2%AC%85
				let v = url.pathname.toLowerCase().split('/').filter(x => x);
				if (v.length >= 2 && v[0] === 'name') {
					input_field.value = input = add_dot_eth(decodeURIComponent(v[1]));
				}
			} else {
				// generalized handler
				// https://opensea.io/assets/ethereum/0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401/65925476150180752387929572463320899353544457962160224303512375154243473029563
				// https://opensea.io/assets/ethereum/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				// https://www.gem.xyz/asset/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				// https://element.market/assets/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				let v = url.pathname.toLowerCase().split('/').filter(x => x);
				if (v.length >= 2 && /^[a-f0-9]+$/i.test(v[v.length-1])) {
					// TODO: fix this, use ensure_nft() and ensure_wrapper()
					if (v[v.length-2] === '0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85') {
						input_field.value = input = `token:${v[v.length-1]}`;
					} else if (v[v.length-2] === '0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401') {
						input_field.value = input = `wrapped:${v[v.length-1]}`;
					}
				}
			}
		} catch (err) {
		}
	}
	let match;
	// replace token:XXX with ens subgraph label (or fail)
	if (match = input.match(/^(?:labelhash|token):(0x[a-f0-9]+|[0-9]+)$/i)) {
		let hash = bytes32_from(match[1]);
		resolve_btn.disabled = true;
		return (async() => {
			try {
				//if (!active_chain.is_mainnet) throw new Error(`token: only works on mainnet`);
				// 20240720: was https://api.thegraph.com/subgraphs/name/ensdomains/ens
				const API_KEY = 'bed3a6cc6de79eb96724b610aeb6e03b';
				const SUBGRAPH_ID = '5XqPmWe6gjyrJtFn9cLy237i4cWw2j9HcUJEXsP5qGtH';
				let res = await fetch(`https://gateway-arbitrum.network.thegraph.com/api/${API_KEY}/subgraphs/id/${SUBGRAPH_ID}`, {
					method: 'POST',
					body: JSON.stringify({
						query: `{domains(where:{labelhash:"${hash}"}){labelName}}`
					})
				});
				if (!res.ok) throw new Error(`HTTP Error ${r.status}`);
				let {data: {domains}} = await res.json();
				if (!domains.length) throw new Error(`Unknown labelhash preimage: ${hash}`);
				let label = domains[0].labelName;
				if (!label) throw new Error(`Unknown labelhash preimage: ${hash}`);
				let hash0 = labelhash(label);
				if (hash0 !== hash) throw new Error(`Incorrect labelhash preimage: "${label}")\n\nExpected: ${hash}\nComputed: ${hash}`);
				input_field.value = add_dot_eth(label);
				setTimeout(resolve, 0);
			} catch (err) {
				window.alert(err.message);
				stop_resolving();
			}
			resolve_btn.disabled = false;
		})();
	} else if (match = input.match(/^(?:namehash|wrapped):(0x[a-f0-9]+|[0-9]+)$/i)) {
		let hash = bytes32_from(match[1]);
		resolve_btn.disabled = true;
		return (async () => {
			try {
				await ensure_wrapper();
				let v = ethers.getBytes(await network_state.wrapper.names(hash));
				if (!v.length) throw new Error(`Unknown namehash preimage: ${hash}`);
				input_field.value = labels_from_dns_encoded(v).join('.');
				setTimeout(resolve, 0);
			} catch (err) {
				window.alert(err.message);
				stop_resolving();
			}
			resolve_btn.disabled = false;
		})();
	}
	// input convenience: expand range
	if (match = input.match(/^range:([0-9a-f]+)\.\.([0-9a-f]+)$/i)) {
		let lo = parseInt(match[1], 16);
		let hi = parseInt(match[2], 16);
		if (hi >= lo) {
			input = str_from_cps(Array(1 + hi - lo).fill().map((_, i) => lo + i));
		}
	}
	// input convenience: HEX HEX HEX => {HEX}{HEX}
	if (/^\s*[0-9a-f]{2,}(\s+[0-9a-f]{2,})+\s*$/i.test(input)) {
		input = input.trim().split(/\s+/).map(x => `{${x}}`).join('');
	}
	// input convenience: entities
	input = input.replace(/&#?[0-9a-z]+;/gui, x => {
		entity_span.innerHTML = x;
		return apply_escapes_where(entity_span.innerText);
	});
	input_field.value = input;
	let name = replace_escapes(input);
	add_recent(name);
	const url = get_page_url();
	if (!parse() && (!input || !skip)) {
		primary_loader.classList.add('hide');
		history_timer = setTimeout(() => {
			// commit the error to history
			window.history.replaceState(url.toString(), null, url);
		}, 2000);
		return;
	}
	resolve_btn.disabled = true;
	primary_loader.classList.remove('hide');
	const t0 = Date.now();
	const r0 = rpc_count;
	const l0 = lookup_count;
	resolve_state = {
		name, input, skip, url,
		addrs: new Map(),
		chain: active_chain,
		t0, t: t0,
		r0, r: r0,
		l0, l: l0,
	};
	if (debug_enabled) resolve_state.debug = debug_settings;
	resolve1(name, skip).catch(err => console.error(err)).then(() => {
		clock_span.innerHTML = create_elapsed(Date.now() - t0, rpc_count - r0, lookup_count - l0, true).innerHTML;
		resolve_btn.disabled = false;
		if (Array.isArray(resolve_timer)) {
			setTimeout(resolve, Math.max(0, resolve_timer[0] - Date.now()));
		} else {
			primary_loader.classList.add('hide');
			// commit resolve() to history
			window.history.replaceState(url.toString(), null, url);
		}
	});
}

async function resolve1(input, skip_norm) {
	output_div.innerHTML = '';

	let input_is_address = is_checksum_address(input);
	let input_row;
	let normed_row;
	let reverse_row;
	let name_norm;
	let norm_err;

	if (input_is_address) {
		input_row = create_row('Address');
		input_row.append(create_jazz_icon(input));
		input_row.append(create_explorer_address_link(input));
		add_row_tag(input_row, create_copy_btn(input, {value: true}));
		add_row_tag(input_row, create_reverse_resolve_btn(input));
		add_owner_links(input_row, input);

		let rev_name = get_reverse_name(input);

		let rev_details = create('div', {className: ['breakdown']});
		make_detailed(rev_details);
		let rev_div = create('div', {innerHTML: `<b>Reverse Name:</b> <code class="long">${rev_name}</code>`, className: 'hash'});
		rev_div.append(create_copy_btn(rev_name, {small: true, value: true}));
		rev_details.append(rev_div, create_namehash_breakdown(rev_name), create_dns_breakdown(rev_name));
		output_div.append(input_row, rev_details);

		let resolver_row = create_row('Reverse Resolver');
		add_spinner(resolver_row);
		output_div.append(resolver_row);

		make_contract(input, input_row);
		if (should_stop_resolving()) return;

		let resolver, last_err;
		try {
			resolver = await get_resolver(rev_name);
		} catch (err) {
			last_err = err;
		}
		if (should_stop_resolving()) return;
		remove_temporary(resolver_row);
		add_row_tag(resolver_row, create_elapsed_since());

		let rev = await try_reverse_registrar();
		if (should_stop_resolving()) return;
		if (network_state.reverse) {
			add_row_tag(input_row, create_link('https://raffy.antistupid.com/eth/ens-reverse.html', {
				button: 'âœï¸ Set Primary'
			}));
		}

		if (last_err) {
			resolver_row.classList.add('error');
			add_row_tag(resolver_row, create_tag('warn', last_err));
			return;
		} else if (!resolver) {
			add_row_tag(resolver_row, create_tag('stop', 'Primary Not Set'));
			return;
		}

		resolver_row.append(create_explorer_address_link(resolver.target, {contract: true}));
		add_row_tag(resolver_row, create_copy_btn(resolver.target, {value: true}));
		add_resolver_info(resolver_row, resolver);

		reverse_row = normed_row = create_row('Primary');
		add_spinner(reverse_row);
		output_div.append(reverse_row);
		let primary;
		[{data: primary, error: last_err}] = await fetch_records(resolver, [{type: TYPE_NAME}]);
		if (should_stop_resolving()) return;
		remove_temporary(reverse_row);
		add_row_tag(reverse_row, create_elapsed_since());
		if (last_err) {
			reverse_row.classList.add('error');
			add_row_tag(reverse_row, create_tag('warn', last_err));
			return;
		} else if (!primary) {
			add_row_tag(reverse_row, create_tag('stop', 'Primary is Null'));
			return;
		}

		make_exploded(reverse_row, primary, false);
		add_input_features(reverse_row, primary);
		output_div.append(create_breakdown_row(primary, true));

		try {
			name_norm = ens_normalize(primary);
		} catch (err) {
			reverse_row.classList.add('error');
			add_row_tag(reverse_row, create_tag('norm', err));
			add_row_tag(reverse_row, create_resolve_btn(primary));
			if (!skip_norm) return;
			name_norm = primary;
			norm_err = err;
		}
		if (!norm_err) {
			if (name_norm === primary) {
				add_row_tag(reverse_row, create_resolve_btn(primary));
				make_normalized(reverse_row, name_norm);
			} else {
				add_row_tag(reverse_row, create_tag('fail', 'Normalized'));
				let row = normed_row = create_row('Normalized Primary');
				make_exploded(row, name_norm, true);
				add_row_tag(row, create_copy_btn(name_norm));
				add_row_tag(row, create_resolve_btn(name_norm));
				add_row_tag(row, create_namehash_button(name_norm));
				make_normalized(row, name_norm);
				output_div.append(row);
				output_div.append(create_breakdown_row(name_norm));
			}
		}
	} else {

		// the input is a name
		input_row = normed_row = create_row(INPUT_NAME);
		input_row.classList.add('input');
		make_exploded(input_row, input, false);
		add_row_tag(input_row, create_ens_link(input));
		output_div.append(input_row);
		output_div.append(create_breakdown_row(input, true));
		add_input_features(input_row, input);
		try {
			name_norm = ens_normalize(input);
		} catch (err) {
			input_row.classList.add('error');
			add_row_tag(input_row, create_tag('norm', err));
			if (!skip_norm) return; // i think this is always true
			name_norm = input;
			norm_err = err;
		}
		
		if (!norm_err) {
			if (name_norm === input) {
				make_normalized(input_row, name_norm);
				//make_exploded(input_row, input, false);
			} else  {
				add_row_tag(input_row, create_tag('fail', 'Normalized'));
				if (skip_norm) {
					name_norm = input;
				} else {
					add_transformed_row(input);
					let row = normed_row = create_row('Normalized');
					make_exploded(row, name_norm, true);
					make_normalized(row, name_norm);
					add_row_tag(row, create_copy_btn(name_norm));
					add_row_tag(row, create_resolve_btn(name_norm));
					add_row_tag(row, create_ens_link(name_norm));
					add_row_tag(row, create_namehash_button(name_norm));
					add_ensip1_tag(row, name_norm, true);
					output_div.append(row, create_breakdown_row(name_norm));
				}
			}
		}
		add_ensip1_tag(input_row, input);
	}

	let sep_pos = name_norm.indexOf('.');
	if (sep_pos == -1) sep_pos = name_norm.length;
	if (sep_pos > 0) {
		let prefix = name_norm.slice(0, sep_pos);
		let suffix = name_norm.slice(sep_pos);
		let tokens = ens_tokenize(prefix);
		if (tokens.every(t => t.type === 'emoji')) {
			input_row.after(create_ethmoji_row(tokens, suffix));
			let negative = str_from_cps(tokens[0].emoji) == KEYCAP_MINUS;
			if (negative) tokens = tokens.slice(1);
			let values = tokens.map(x => x.emoji[0] - 0x30);
			if (values.every(x => x >= 0 && x < 10)) {
				input_row.after(create_digits_row(name_norm, KEYCAP_NAME, values, negative, suffix));
			}
		} else {
			let negative = prefix.startsWith('-');
			if (negative) prefix = prefix.slice(1);
			if (prefix) {
				let cps = explode_cp(prefix);
				let digits = cps.map(cp => DIGIT_MAP.get(cp));
				if (digits.every(x => x)) {
					let values = digits.map(x => x.i);
					let name0 = digits[0].name;
					if (digits.every(x => x.name === name0)) {
						input_row.after(create_digits_row(name_norm, name0, values, negative, suffix));
					} else {
						let first = digits[0].mixed;
						if (first && digits.every(x => x.mixed == first)) {
							let row = create_digits_row(name_norm, 'Arabic', values, negative, suffix);
							add_row_tag(row, create_tag('warn', 'Mixed Digits'));
							input_row.after(row);
						} else {
							let row = create_digits_row(name_norm, 'Numeric', values, negative, suffix);
							add_row_tag(row, create_tag('warn', 'Multiple Scripts'));
							input_row.after(row);
						}
					}
				}
			}
		}
	}

	let rev_match = parse_reverse_name(name_norm);
	if (rev_match) {
		let row = create_row('Reverse Address');
		const {address, coin, is_evm, evm, network} = rev_match;
		const select = create('select', {
			change() {
				input_field.value = get_reverse_name(address, BigInt(this.value));
				resolve();
			},
		});
		for (const [id, name] of CHAIN_NAMES) {
			select.append(create('option', {value: id.toString(10)}, name));
		}
		if (!is_evm || !network) {
			select.prepend(create('option', {disabled: true}, network ? `Non-EVM: ${network}` : 'Unknown EVM'));
			select.selectedIndex = 0;
		} else {
			select.value = evm;
		}
		if (address) {
			try {
				const addr = is_evm ? ethers.getAddress(address) : address;
				add_row_tag(row, create_copy_btn(addr));
				if (is_evm) {
					//row.append(create_main_span(addr));
					add_row_tag(row, create_resolve_btn(addr));
				}
			} catch (err) {
				row.classList.add('error');
				add_row_tag(row, create_tag('warn', 'Invalid Address'));
			}
		}
		row.append(create_tag('raw', is_evm ? `chain(${evm || '0'})` : `coin(${coin})`, `CoinType: ${format_dec_hex(coin)}`));
		row.append(select);
		output_div.append(row);
	} else {
		let form, pretty;
		try {
			form = ens_beautify(name_norm);
			pretty = true;
		} catch (err) {
		}
		if (skip_norm && form !== name_norm) {
			form = name_norm;
			pretty = false;
		}
		let row = create_row(pretty ? 'Beautified' : 'Unnormalized');
		if (pretty) row.classList.add('pretty');
		row.append(create_main_span(form));
		add_row_tag(row, create_copy_btn(form));
		if (input === form) {
			add_row_tag(row, skip_norm ? SAME_AS_INPUT : create_tag('good', SAME_AS_INPUT));
		} else if (name_norm === form) {
			add_row_tag(row, create_tag('good', SAME_AS_NORM));
		} else if (pretty) {
			add_row_tag(row, create_resolve_btn(form));
			add_row_tag(row, create_pretty_tag());
		}
		add_ensip1_tag(row, form);
		if (!pretty) {
			input_row.querySelector('.ensip1')?.remove();
		}
		output_div.append(row);
		output_div.append(create_dns_row(name_norm));
	}

	// at this point, we have a name
	// lookup the name
	let resolver, resolver_err;
	let resolver_row = create_row('Resolver');
	add_spinner(resolver_row);
	output_div.append(resolver_row);
	try {
		resolver = await get_resolver(name_norm);
	} catch (err) {
		resolver_row.classList.add('error');
		add_row_tag(resolver_row, create_tag('warn', err));
	}
	if (should_stop_resolving()) return;
	remove_temporary(resolver_row);
	add_row_tag(resolver_row, create_elapsed_since());

	if (resolver) {
		resolver_row.append(create_explorer_address_link(resolver.target, {contract: true}));
		add_row_tag(resolver_row, create_copy_btn(resolver.target, {value: true}));
		add_resolver_info(resolver_row, resolver);
	} else if (resolver === null) {
		add_row_tag(resolver_row, create_tag('warn', `Not Set`));
	}

	const impls_row = create_row(create_link('https://docs.ens.domains/contract-api-reference/.eth-permanent-registrar#discovery', {innerHTML: 'Interfaces'}));
	impls_row.classList.add('impls');
	output_div.append(impls_row);
	let owner;
	if (name_norm === 'eth') {
		add_spinner(impls_row);
		await load_known_interfaces(impls_row, resolver);
		if (should_stop_resolving()) return;
		remove_temporary(impls_row);
		add_row_tag(impls_row, create_elapsed_since());
	} else {
		impls_row.classList.add('hide');
		resolver_row.append(create('button', {
			innerText: 'ğŸ”ï¸ Interfaces',
			style: { order: 10 },
			async click() {
				const t0 = Date.now();
				const reqs = rpc_count;
				this.remove();
				impls_row.classList.remove('hide');
				add_spinner(impls_row);
				await load_known_interfaces(impls_row, resolver);
				if (!impls_row.isConnected) return;
				remove_temporary(impls_row);
				add_row_tag(impls_row, create_elapsed(Date.now() - t0, rpc_count - reqs));
			}
		}))
	}

	//let dns_txt_address;
	if (resolver && resolver.__info.dnssec_oracle) {
		// https://blog.ens.domains/post/gasless-dnssec
		let ens1_row = create_row(create_link('https://support.ens.domains/en/articles/8834820-offchain-gasless-dnssec-names-in-ens', {innerHTML: 'DNS <code style="color: #58f">ENS1</code>'}));
		add_spinner(ens1_row);
		ens1_row.classList.add('dns');
		output_div.append(ens1_row);
		let host = name_norm.split('.').map(puny_encoded).join('.');
		let target, context, inspect;
		try {
			let url = new URL('https://1.1.1.1/dns-query');
			url.searchParams.set('name', host); // cannot fail
			url.searchParams.set('type', 'TXT');
			let res = await fetch(url, {
				headers: {accept: 'application/dns-json'}
			});
			if (res.ok) {
				let json = await res.json();
				inspect = create('button', {
					innerText: EMOJI_INSPECT,
					click() {
						window.alert(JSON.stringify(json, null, '  '));
					}
				});
				let {Answer = []}  = json;
				const prefix = '"ENS1 ';
				let rec = Answer.find(x => x.type === 16 && x.data.startsWith(prefix) && x.data.endsWith('"'));
				if (!rec) throw new Error('No record found');
				const inner = rec.data.slice(prefix.length, -1);
				let pos = inner.indexOf(' ');
				if (pos == -1) pos = inner.length;
				target = inner.slice(0, pos);
				context = bytes_from_utf8(inner.slice(pos + 1));
				add_row_tag(ens1_row, create('span', {className: ['raw', 'long'], innerText: inner}));
				add_row_tag(ens1_row, create_copy_btn(rec.data.slice(1, -1)));
			} else if (res.status == 504) {
				throw new Error('DNS query timeout');
			} else {
				throw new Error(`HTTP ${res.status}`);
			}
		} catch (err) {
			ens1_row.classList.add('error');
			add_row_tag(ens1_row, create_tag('warn', err));
		}
		if (should_stop_resolving()) return;
		remove_temporary(ens1_row);
		add_row_tag(ens1_row, inspect);
		add_row_tag(ens1_row, create_link(`https://dnssec-debugger.verisignlabs.com/${host}`, {innerText: 'Verisign', className: 'external'}));

		add_row_tag(ens1_row, create_elapsed_since());
		if (target) {
			let target_row = create_row('DNSSEC Resolver');
			add_spinner(target_row);
			target_row.classList.add('dns');
			output_div.append(target_row);
			try {
				if (is_address(target)) {
					target = ethers.getAddress(target.toLowerCase());
				} else {
					let r = await get_resolver(target);
					if (should_stop_resolving()) return;
					target = await fetch_addr60(r);
					if (should_stop_resolving()) return;
				}
				let info = await get_resolver_info(target);
				if (should_stop_resolving()) return;
				target_row.append(create_explorer_address_link(target, {contract: true}));
				add_row_tag(target_row, create_copy_btn(target, {value: true}));
				let dns_resolver = contract_for_resolver(target);
				dns_resolver.__info = info;
				['__node', '__dns_encoded', '__basename', '__dropped'].forEach(x => dns_resolver[x] = resolver[x]);
				add_resolver_info(target_row, dns_resolver, info.edns && context);
				//   dnsname.ens.eth https://etherscan.io/address/0x238A8F792dFA6033814B18618aD4100654aeef01#code
				// 2.dnsname.ens.eth https://etherscan.io/address/0x08769D484a7Cd9c4A98E928D9E270221F3E8578c#code
				/*
				if (info.edns) {
					add_row_tag(target_row, create_tag('special', 'Wildcard DNS'));
					if (args.length == 2) {
						resolver.__only_addr = true; // prevent querying extra records that dont exist (yet)
						let addr = args[1];
						if (is_address(addr)) {
							dns_txt_address = ethers.getAddress(addr.toLowerCase());
							add_row_tag(target_row, create_resolve_btn(addr, 'â†©ï¸ Address'));
							//make_detailed(ens1_row); // hide it by default
						} else if (addr) {
							add_row_tag(target_row, create_tag('fail', 'Invalid address', addr));
						} else {
							add_row_tag(target_row, create_tag('fail', 'Missing address'));
						}
					}
				}
				*/
			} catch (err) {
				target_row.classList.add('error');
				target_row.append(create_tag('warn', err));
			}
			if (should_stop_resolving()) return;
			remove_temporary(target_row);
			add_row_tag(target_row, create_elapsed_since());
		}
	}

	let parent_domain = name_norm.slice(sep_pos+1);
	let nft_backed = NFT_DOMAINS.has(name_norm.slice(sep_pos+1));
	let nft_contract;
	let nft_token;

	let in_grace;
	let available;
	let avail_row = create_row('Availability');
	add_spinner(avail_row);
	if (parent_domain === 'eth') {
		let label = name_norm.slice(0, sep_pos);
		nft_token = labelhash(label);
		let avail_err;
		let expiry;
		let len = Array.from(label).length;
		let premium;
		output_div.append(avail_row);
		try {
			await ensure_eth_nft();
			check_abort();
			nft_contract = network_state.eth_nft;
			[available, expiry] = await Promise.all([
				nft_contract.available(nft_token),
				nft_contract.nameExpires(nft_token)
			]);
			check_abort();
			if (available) {
				premium = await network_state.price_oracle.premium(label, expiry, 0);
			}
		} catch (err) {
			avail_err = err;
		}
		remove_temporary(avail_row);
		if (should_stop_resolving()) return;
		add_row_tag(avail_row, create_elapsed_since());
		add_row_tag(avail_row, create_tag('length', len));
		if (avail_err) {
			avail_row.classList.add('error');
			add_row_tag(avail_row, create_tag('warn', avail_err));
		} else if (len < MIN_ETH_LENGTH) {
			add_row_tag(avail_row, create_tag('fail', `Too Short`));
			if (len > 0) {
				let padded = Array(1 + Math.max(0, MIN_ETH_LENGTH - len)).fill(label).join('');
				add_row_tag(avail_row, create_resolve_btn(add_dot_eth(padded), 'â†©ï¸ Repeat until 3+'));
			}
		} else if (available) {
			add_row_tag(avail_row, create_ens_link(name_norm, 'Available to Register'));
			let ether = parseFloat(ethers.formatEther(premium));
			if (ether) {
				add_row_tag(avail_row, create_tag('warn', `${ether.toFixed(ether < 1 ? 4 : 2)}Î Premium`));
			}
			//add_row_tag(avail_row, create_typed_tag('fire', 'Available'));
			//add_row_tag(avail_row, create_ens_link(name_norm, {title: 'Register'}));
		} else {
			let exp = Number(expiry) * 1000;
			let {grace_period} = network_state;
			let end = exp + grace_period;
			let now = Date.now();
			if (now >= exp && now <= end) {
				in_grace = true;
				add_row_tag(avail_row, create_tag('warn', `Grace period (${format_dur(grace_period)}) ends in ${format_dur(end - now)}`));
			} else {
				add_reg_exp_tags(avail_row, exp, now);
			}
		}
		if (expiry) {
			const exp = Number(expiry);
			const exp_gr = exp + network_state.grace_period / 1000;
			add_row_tag(avail_row, create_copy_btn([
				`Expiry: ${new Date(exp * 1000).toISOString()} (${expiry})`,
				`Grace: ${new Date(exp_gr * 1000).toISOString()} (${exp_gr})`,
			].join('\n'), {value: true}));
		}
		if (nft_contract) {
			avail_row.querySelector('.row-label').title = `Grace: ${format_dur(network_state.grace_period)}\nPremium: ${format_dur(network_state.premium_period)}`;
		}
		avail_row.append(create('div', {className: ['grouped', 'external']}, create_link(`https://www.ensvolution.xyz/?name=${encode_uri_component_surrogate_escaped(name_norm)}`, {innerHTML: 'ENSvolution'})));
	} else if (nft_backed) {
		let label = name_norm.slice(0, sep_pos);
		nft_token = labelhash(label);
		let avail_url;
		let avail_err;
		output_div.append(avail_row);
		try {
			let address = await network_state.ens.owner(namehash(parent_domain));
			check_abort();
			if (is_null_hex(address)) throw new Error('Missing backing contract');
			nft_contract = new ethers.Contract(address, [
				'function available(uint256 id) external view returns(bool)',
				'function ownerOf(uint256 id) external view returns (address)',
			], active_provider);
			available = await nft_contract.available(nft_token);
			check_abort();
			if (active_chain.is_mainnet && parent_domain === 'art') {
				avail_url = `https://protocol.art/api/art-tokens?exact=${encodeURIComponent(label)}`;
				if (available) {
					try {
						let res = await fetch(avail_url);
						let {Items} = await res.json();
						available = !Items.length;
					} catch (ignored) {
					}
				}
			}
		} catch (err) {
			avail_err = err;
		}
		remove_temporary(avail_row);
		if (should_stop_resolving()) return;
		add_row_tag(avail_row, create_elapsed_since());
		add_row_tag(avail_row, create_tag('length', Array.from(label).length));
		if (nft_contract) {
			let old = avail_row.querySelector('.row-label');
			old.replaceChildren(create_explorer_address_link(nft_contract.target, {innerHTML: old.innerHTML, contract: true}));
		}
		if (avail_err) {
			avail_row.classList.add('error');
			add_row_tag(avail_row, create_tag('warn', avail_err));
		} else {
			add_row_tag(avail_row, create_tag(available ? 'good' : 'fail', 'Available'));
			if (avail_url) {
				add_row_tag(avail_row, create_link(avail_url, {button: 'ğŸ”ï¸ Details', className: 'external'}));
			}
		}
	}
	
	resolve_state.available = available; // true|false|undefined

	// get the owner
	let is_wrapped, nft_owner;
	if ((!resolver || !resolver.__dropped) && (!nft_backed || available !== undefined)) {
		let node = namehash(name_norm);
		let wrapped_data;
		let wrapped_row = create_row(WRAPPER_NAME);
		add_spinner(wrapped_row);
		let unwrappable;
		try {
			dns_encoded_from(name_norm);
		} catch (err) {
			unwrappable = true;
		}
		if (!available) {
			output_div.append(wrapped_row);
			let wrapped_err;
			try {
				await ensure_wrapper();
				if (should_stop_resolving()) return;
				if (!unwrappable) {
					if (in_grace) {
						is_wrapped = await network_state.ens.owner(node) === network_state.wrapper.target;
					} else {
						is_wrapped = await network_state.wrapper.isWrapped(node);
					}
					if (should_stop_resolving()) return;
					if (is_wrapped) {
						// 0x000000006433a888000000005c7b61a99d922e9a4451ed62ebbbedbf1627ab47
						// use raw storage access since wrapper nukes information when expired
						// wrapped_data = await network_state.wrapper.getData(node);
						let slot = ethers.solidityPackedKeccak256(['uint256', 'uint256'], [node, 1]);
						let raw = await active_provider.getStorage(network_state.wrapper.target, slot);
						if (should_stop_resolving()) return;
						owner = ethers.getAddress(ethers.dataSlice(raw, 12, 32));
						let now = Date.now();
						let exp = parseInt(ethers.dataSlice(raw, 0, 8)) * 1000;
						let fuses = parseInt(ethers.dataSlice(raw, 8, 12));
						let expired = exp && exp < now;
						wrapped_data = {expired, now, exp, raw, slot, fuses};
						if (expired) {
							resolve_state.available = available = true;
							wrapped_row.classList.add('available');
						}
					}
				}
			} catch (err) {
				wrapped_err = err;
			}
			if (should_stop_resolving()) return;
			if (wrapped_err) {
				wrapped_row.classList.add('error');
				add_row_tag(wrapped_row, create_tag('warn', wrapped_err));
			} else if (unwrappable) {
				add_row_tag(wrapped_row, create_tag('warn', 'Unwrappable'));
			} else if (!is_wrapped) {
				add_row_tag(wrapped_row, 'Unwrapped');
			}
			if (network_state.wrapper) {
				const old = wrapped_row.querySelector('.row-label');
				old.replaceChildren(create_explorer_address_link(network_state.wrapper.target, {
					innerHTML: is_wrapped ? 'Wrapped' : WRAPPER_NAME, 
					contract: true
				}));
			}
			if (is_wrapped) {
				resolver_row.append(create('button', {
					innerHTML: 'ğŸ”ï¸ Wrapper Aware',
					title: 'According to ENS Manager App',
					style: { order: 10 },
					async click() {
						add_spinner(this);
						this.disabled = true;
						try {
							// https://github.com/ensdomains/ens-app-v3/blob/main/src/hooks/resolver/useResolverIsAuthorised.ts#L54-L60
							await resolver.setAddr.estimateGas(node, 60n, ethers.ZeroAddress, {
								from: owner
							});
							add_row_tag(resolver_row, create_tag('good', 'âœ…ï¸ Wrapper Aware'));
						} catch (err) {
							add_row_tag(resolver_row, create_tag('stop', 'Not Wrapper Aware'));
						}
						this.remove();
					}
				}));
				add_nft_links(normed_row, name_norm, network_state.wrapper.target, node);
			} else if (nft_contract) {
				add_nft_links(normed_row, name_norm, nft_contract.target, nft_token);
			}
		} else if (unwrappable) {
			output_div.append(wrapped_row);
			add_row_tag(wrapped_row, create_tag('stop', 'Unwrappable'));
		}
		remove_temporary(wrapped_row);
		add_row_tag(wrapped_row, create_elapsed_since());

		let owner_row = create_row(available ? 'Last Owner' : 'Owner');
		add_spinner(owner_row);
		let owner_err;
		let checked_nft;
		output_div.append(owner_row);
		try {
			if (is_wrapped) {
				let {fuses, expired, now, exp} = wrapped_data;
				if (resolve_state.debug && resolve_state.debug.fuses) fuses = 0x7FFFF;
				if (fuses & 0x10000) { // PARENT_CANNOT_CONTROL
					if (fuses & 0x00001) { // CANNOT_UNWRAP
						add_row_tag(wrapped_row, create_tag('good', 'ğŸ”’ï¸ Locked'));
					} else {
						add_row_tag(wrapped_row, create_tag('good', 'ğŸ•Šï¸ Emancipated'));
					}
					if (!(fuses & 0x20000)) { // !IS_DOT_ETH
						add_reg_exp_tags(wrapped_row, exp, now); // note: this includes grace for .eth subs
						if (fuses & 0x40000) { // CAN_EXTEND_EXPIRY => no approval needed
							add_row_tag(wrapped_row, create_tag('warn', 'Public Extendable'));
						} else {
							add_row_tag(wrapped_row, create_tag('warn', 'Extension requires approval'));
						}
					}
				} else {
					add_row_tag(wrapped_row, create_tag('good', 'ğŸï¸ Wrapped')); // â™¾ï¸
				}
				if (fuses & 0x00002) add_row_tag(wrapped_row, 'ğŸš«ï¸ Burn Fuses');
				if (fuses & 0x00004) {
					add_row_tag(wrapped_row, 'ğŸš«ï¸ Transfer');
					make_locked(owner_row);
				}
				if (fuses & 0x00008) {
					add_row_tag(wrapped_row, 'ğŸš«ï¸ Set Resolver');
					make_locked(resolver_row);
				}
				if (fuses & 0x00010) add_row_tag(wrapped_row, 'ğŸš«ï¸ Set TTL');
				if (fuses & 0x00020) add_row_tag(wrapped_row, 'ğŸš«ï¸ Subdomain');
				if (fuses & 0x00040) add_row_tag(wrapped_row, 'ğŸš«ï¸ Approve');
				if (expired) {
					add_row_tag(wrapped_row, `Expired ${format_dur(now - exp)} ago`);
				}
			} else {
				owner = await network_state.ens.owner(node);
				if (should_stop_resolving()) return;
				if (is_null_hex(owner)) owner = false;
				if (!owner && nft_contract) {
					checked_nft = true;
					owner = await nft_contract.ownerOf(nft_token).catch(() => {});
					if (is_null_hex(owner)) owner = false;
				}
			}
		} catch (err) {
			owner_err = err;
		}
		if (should_stop_resolving()) return;
		make_contract(owner, owner_row);
		remove_temporary(owner_row);
		if (should_stop_resolving()) return;
		add_row_tag(owner_row, create_elapsed_since());
		if (owner_err) {
			owner_row.classList.add('error');
			owner_row.append(create_tag('warn', owner_err));
		} else if (!owner) {
			if (available) {
				add_row_tag(owner_row, create_tag('reg', 'ğŸŒ»ï¸ Not Set'));
			} else {
				add_row_tag(owner_row, create_tag('warn', 'Not Set'));
			}
		} else {
			owner_row.append(create_explorer_address_link(owner));
			add_row_tag(owner_row, create_copy_btn(owner, {value: true}));
			// if the input was an address, we can validate
			if (input_is_address) {
				add_row_tag(reverse_row, create_tag(owner === input ? 'good' : 'fail', 'Owned'));
				if (owner === input) {
					add_row_tag(owner_row, SAME_AS_INPUT);
				}
			}
			if (owner !== input) {
				add_row_tag(owner_row, create_resolve_btn(owner));
				add_owner_links(owner_row, owner);
			}
			if (active_chain.is_mainnet && parent_domain === 'art') {
				add_row_tag(avail_row, create_link(`https://protocol.art/account/${owner}`, {button: 'ğŸ› ï¸ Configure', className: 'external'}));
			}
			if (!is_wrapped && !available && !checked_nft && nft_contract) {
				let nft_row = create_row(create_explorer_address_link(nft_contract.target, {innerHTML: NFT_OWNER_NAME, contract: true}));
				add_spinner(nft_row);
				nft_row.classList.add('nft');
				output_div.append(nft_row);
				try {
					nft_owner = await nft_contract.ownerOf(nft_token);
					if (is_null_hex(nft_owner)) nft_owner = false;
				} catch (err) {
				}
				if (should_stop_resolving()) return;
				if (nft_owner && nft_owner !== owner) {
					owner_row.querySelector('.row-label').innerHTML = MANAGER_NAME;
					owner_row.insertAdjacentElement('beforebegin', nft_row); // move up
					nft_row.append(create_jazz_icon(nft_owner));
					let a = create_explorer_address_link(nft_owner);
					nft_row.append(a);
					make_contract(nft_owner, nft_row);
					add_row_tag(nft_row, create_copy_btn(nft_owner, {value: true}));
					let owner_ref = nft_owner;
					try {
						let norm = await get_safe_primary(nft_owner, owner);
						if (norm.endsWith('.' + name_norm)) { // proper subdomain
							owner_ref = norm; // swap
							let sub = norm.slice(0, -(name_norm.length + 1));
							a.innerHTML = `<b>${ens_beautify(sub)}</b>.${ens_beautify(name_norm)}`;
							add_row_tag(nft_row, create_tag('good', 'Subdomain'));
						} else {
							a.innerHTML = ens_beautify(norm);
							//add_row_tag(nft_row, create_typed_tag('good', 'Owned'));
						}
					} catch (err) {
					}
					if (owner_ref !== input) {
						add_row_tag(nft_row, create_resolve_btn(owner_ref));
					}
					add_owner_links(nft_row, nft_owner);
					add_row_tag(nft_row, create_elapsed_since());
					remove_temporary(nft_row);
				} else {
					nft_row.remove();
				}
			}
			owner_row.append(create_jazz_icon(owner));
		}
	}
	if (should_stop_resolving()) return;

	// add address
	let address;
	if (resolver) {
		let address_err;
		let address_row = create_row('ETH Address');
		add_spinner(address_row);
		address_row.classList.add('addr');
		output_div.append(address_row);
		try {
			address = await fetch_addr60(resolver);
		} catch (err) {
			address_err = err;
		}
		if (should_stop_resolving()) return;
		if (rev_match && (address_err ? address_err.code === 'CALL_EXCEPTION' : !address)) {
			add_row_tag(address_row, 'Not Supported');
		} else if (address_err) {
			if (address_err.code === 'BAD_DATA' && address_err.value === '0x') {
				add_row_tag(address_row, create_tag('fail', 'No Response'));
			} else if (address_err.code === 'CALL_EXCEPTION' && address_err.shortMessage == 'missing revert data') {
				add_row_tag(address_row, create_tag('fail', 'Empty Revert'));
			} else {
				address_row.classList.add('error');
				add_row_tag(address_row, create_tag('warn', address_err));
			}
		} else if (!address) {
			add_row_tag(address_row, create_tag('warn', 'Not Set'));
		} else {
			if (should_stop_resolving()) return;
			make_contract(address, address_row);
			address_row.append(create_jazz_icon(address));
			address_row.append(create_explorer_address_link(address));
			address_row.append(create_copy_btn(address, {value: true}));
			if (input_is_address) {
				if (address === input) {
					add_row_tag(input_row, create_tag('fire', 'Primary'));
					add_row_tag(address_row, SAME_AS_INPUT);
				} else if (address) {
					add_row_tag(address_row, create_resolve_btn(address));
					add_row_tag(address_row, create_tag('warn', 'Different from Owner'));
				}
			} else if (owner === address) {
				if (nft_owner && nft_owner !== address) {
					add_row_tag(address_row, create_tag('good', `Same as ${MANAGER_NAME}`));
				} else {
					add_row_tag(address_row, create_tag('good', 'Same as Owner'));
				}
			} else if (nft_owner === address) {
				add_row_tag(address_row, create_tag('good', `Same as ${NFT_OWNER_NAME}`));
			} else {
				add_row_tag(address_row, create_resolve_btn(address));
				// if (dns_txt_address && address !== dns_txt_address) {
				// 	add_row_tag(address_row, create_tag('fail', 'Same as DNS'));
				// }
				if (owner) {
					add_row_tag(address_row, create_tag('fail', 'Owner'));
				}
				add_owner_links(address_row, address);
			}
		}
		remove_temporary(address_row);
		add_row_tag(address_row, create_elapsed_since());

		let show_recs = show_records_check.checked;
		if (!show_recs) resolve_state.skipped_records = true;
		if (show_recs) {
			let records_row = create_row(create_link('https://docs.ens.domains/contract-api-reference/publicresolver', {innerHTML: 'Records'}));
			add_spinner(records_row);
			records_row.classList.add('records');
			records_row.dataset.records = '1';
			output_div.append(records_row);
			if (address && active_chain.is_mainnet) add_epf_row(address);
			if (resolver.__unreachable) {
				add_row_tag(records_row, create_tag('stop', 'Unreachable'));
			//} else if (resolver.__only_addr) {
			//	add_row_tag(records_row, `Wildcard DNSSEC resolver only supports <code>addr()</code>`);
			} else {
				let records = [...RECORDS.filter(x => !x.chain || x.chain === active_chain.id)];
				if (rev_match) {
					if (rev_match.address) {
						records = [{type: TYPE_NAME, force: true}];
					} else {
						records = RECORDS.filter(x => x.coin === rev_match.coin);
					}
				}
				if (resolver.__info.tor) {
					records.push({
						type: TYPE_TEXT,
						node: resolver.__basenode,
						key: 'ccip.context',
						class: 'raw'
					});
				}
				if (resolve_state.debug && Array.isArray(resolve_state.debug.records)) {
					for (let x of resolve_state.debug.records) {
						try {
							records.push(prepare_record(expand_record(x)));
						} catch (err) {
						}
					}
				}
				let info = {};
				let results = await fetch_records(resolver, records, info);
				let good_count = 0;
				let fail_count = 0;
				let skip_count = 0;
				for (let {rec, data, error, skipped} of results) {
					let a = create('a', {className: 'record', target: '_blank'});
					switch (rec.type) {
						case TYPE_NAME: {
							a.innerHTML = `<b>primary</b>`;
							if (error) break;
							if (!data) {
								if (!rec.force) continue;
								a.append(create_tag('warn', 'Not Set'));
								break;
							}
							a.append(dom_from_tokens(ens_tokenize(data), {components: false, before: true, tld: true}));
							try {
								if (ens_beautify(data) === data) {
									a.append(create_pretty_tag());
								}
							} catch (err) {
								a.append(create_tag('fail', err));
							}
							a.append(create_resolve_btn(data));
							a.classList.add('rtrim');
							a.title = make_exploded_utf8_title(data);
							make_click_copy(a, data);
							break;
						}
						// https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/profiles/IAddressResolver.sol
						case TYPE_ADDR: {
							let {name, coin, evm} = rec;
							const is_evm = typeof evm !== 'undefined';
							if (!name && is_evm) name = `chain(${evm})`;
							if (!name) name = `coin(${coin})`;
							if (rec.icon) a.innerHTML = rec.icon;
							a.append(create('b', {innerText: name}));
							if (error) break;
							if (is_null_hex(data)) continue;
							try {
								let v = ethers.getBytes(data);
								let lines = [`Name: ${name}`, `Type: ${format_dec_hex(coin)}`];
								let address;
								if (is_evm) {
									address = ethers.getAddress(data);
									lines.push(`Network: ${format_dec_hex(evm)}`);
								} else if (rec.btc) {
									address = format_btc_address(v, rec.btc);
								} else if (rec.bech32) {
									address = new Bech32(rec.bech32.hrp, convert(v, 8, 5, true), rec.bech32.type).toString();
								} else if (rec.base58) {
									address = Base58BTC.encode(v);
								} else if (rec.base58check) {
									address = base58check(v);
								}
								if (address) {
									lines.unshift(address);
									//let show = true;
									if (is_evm) {
										//show = !resolve_state.addrs.has(address);
										a.append(create_jazz_icon(address));
									}
									//if (show)
									a.append(create('span', {innerHTML: address, className: ['addr', 'long']}));
									if (rec.url) {
										a.href = rec.url(encodeURIComponent(address));
										//if (rec.testnet) a.classList.add('testnet');
										let btn = create_copy_btn(address, {value: true});
										btn.dataset.alt = data;
										btn.title = [address, ALT_RAW].join('\n');;
										a.append(btn);
										a.classList.add('rtrim');
									} else {
										make_click_copy(a, address);
										a.dataset.alt = data;
										lines.push(ALT_RAW);
									}
								} else {
									lines.unshift('Unknown encoding', data);
									make_click_copy(a, data);
								}
								a.title = lines.join('\n');
							} catch (err) {
								a.append(create_tag('fail', err));
								a.append(create_copy_btn(data, {value: true}));
								a.classList.add('rtrim');
							}
							break;
						}
						// https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/profiles/ITextResolver.sol
						case TYPE_TEXT: {
							if (rec.icon) a.innerHTML = rec.icon;
							a.append(create('b', {innerText: rec.key}));
							if (error) break;
							data = data.trim(); // silent error for empty-able string
							if (!data) continue;
							if (rec.key === 'verifications') {
								fetch_verifications(data, owner, name_norm);
								//continue;
							}
							//a.innerHTML = rec.icon || `<b>${rec.key}</b>`;
							let fixed = data;
							if (rec.url) {
								let prefix = rec.url('');
								if (data.startsWith(prefix)) {
									fixed = fixed.slice(prefix.length);
								}
							}
							if (rec.fix) {
								fixed = rec.fix(fixed);
							}
							if (fixed !== data) {
								a.append(create('span', {
									className: ['tags', 'changed'],
									innerHTML: 'âš ï¸ Changed',
									title: `Original: ${data}\nChange: ${fixed}`}));
								data = fixed;
							}
							a.dataset.key = rec.key;
							a.dataset.value = data;
							let text = rec.format ? rec.format(data, a) : data;
							if (text) {
								a.append(create('span', {innerText: text, className: text.length > 32 ? 'long' : null}));
							}
							if (rec.ens) {
								try {
									if (ens_normalize(data) === name_norm) {
										a.append(create('span', {innerText: 'Same as ENS', className: ['tags', 'good']}));
									}
								} catch (err) {
								}
							}
							if (rec.url) {
								a.href = rec.url(data);
								a.classList.add('rtrim');
								a.append(create_copy_btn(data));
							} else if (rec.url !== false) {
								make_click_copy(a, data);
							}
							a.title = `${data}\nText: ${rec.key}`;
							if (rec.class) {
								a.classList.add(...[rec.class].flat());
							}
							if (rec.key === 'avatar') {
								let spinner = create('div', {className: ['avatar', 'spinner']});
								normed_row.append(spinner);
								fetch_resource_url(data, new Set([owner, address].filter(x => x))).then(res => {
									if (!normed_row.isConnected) return;
									if (res.error) {
										a.append(create('span', {
											className: ['tags', 'changed'],
											innerHTML: 'âŒï¸ Failed',
											title: res.error
										}));
										spinner.replaceWith(create('span', {className: 'avatar', innerText: 'âŒï¸'}));
									} else {
										let img = new Image();
										a.append(create('span', {className: ['tags', 'minor'], innerText: res.type}));
										if (res.fixed) {
											a.append(create('span', {
												className: ['tags', 'changed'],
												innerHTML: 'âš ï¸ Changed',
												title: res.fixed
											}));
										}
										if (res.owned === false) {
											img.classList.add('not_owner');
											a.append(create('span', {
												className: ['tags', 'changed'],
												innerHTML: 'âŒï¸ Not Owner'
											}));
										}
										const avatar_a = create('a', {className: 'avatar', target: '_blank', href: res.url});
										spinner.replaceWith(avatar_a);
										avatar_a.append(spinner);
										img.addEventListener('load', () => avatar_a.replaceChildren(img));
										img.addEventListener('error', () => avatar_a.replaceChildren(img));
										img.src = res.url;
									}
									a.classList.add('rtrim');
								});
							}
							break;
						}
						// https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/profiles/IPubkeyResolver.sol
						case TYPE_PUBKEY: {
							a.innerHTML = `<b>pubkey</b>`;
							if (error) break;
							let [x, y] = data;
							if (is_null_hex(x) && is_null_hex(y)) continue;
							a.classList.add('rtrim');
							let raw = ethers.concat([x, y]);
							let addr = ethers.getAddress('0x' + ethers.keccak256(ethers.concat([x, y])).slice(-40));
							let temp = create_explorer_address_link(addr);
							a.href = temp.href;
							a.title = temp.title;
							let match;
							if (addr === nft_owner) {
								match = NFT_OWNER_NAME;
							} else if (addr === address) {
								match = MANAGER_NAME;
							}
							a.append(create_jazz_icon(addr));
							// add a short address?
							a.append(create_resolve_btn(addr));
							if (match) {
								a.append(create('span', {innerText: `Same as ${NFT_OWNER_NAME}`, className: ['tags', 'good']}));
							}
							a.append(make_click_copy(create('button', {innerText: 'x', title: x}), x));
							a.append(make_click_copy(create('button', {innerText: 'y', title: y}), y));
							//a.title = [address, ALT_RAW].join('\n');
							//make_click_copy(a, address);
							//a.dataset.alt = raw;
							break;
						}
						// https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/profiles/IContentHashResolver.sol
						// https://docs.ens.domains/ensip/7
						// https://github.com/multiformats/multicodec/blob/master/table.csv
						case TYPE_CONTENTHASH: {
							a.innerHTML = `<b>${rec.type}</b>`;
							if (error) break;
							if (is_null_hex(data)) continue;
							a.classList.add('rtrim');
							let buf = ethers.getBytes(data);
							let rep, url;
							try {
								let [proto, pos] = uvarint.read(buf);
								let cid;
								buf = buf.subarray(pos);
								switch (proto) {
									//case 0xE2: // IPLD
									case 0xE3: { // IPFS
										cid = CID.from(buf);
										rep = cid.toString();
										url = `ipfs://${rep}`;
										a.append(create_link(url_from_ipfs_path(rep), {button: 'ğŸ†”ï¸ IPFS'}));
										break;
									}
									case 0xE5: { // IPNS
										cid = CID.from(buf);
										rep = cid.toString('k'); // base36 for urls
										url = `ipns://${rep}`;
										a.append(create_link(`https://${rep}.ipfs2.eth.limo/`, {button: 'â†—ï¸ IPNS'}));
										break;
									}
									case 0xE4: { // Swarm
										// https://docs.ethswarm.org/docs/develop/access-the-swarm/upload-and-download
										// https://gateway.ethswarm.org/access/
										cid = CID.from(buf);
										rep = cid.toString();
										a.append(create_link(`https://${rep}.bzz.link/`, {button: 'Swarm'}));
										url = `bzz://${rep}`;
										break;
									}
									//case 0xE8: // DNSLink
									case 0x1BC: { // onion v2
										// https://support.torproject.org/onionservices/v2-deprecation/
										rep = Base32.encode(buf);
										if (rep.length !== 16) throw new Error('bad length');
										url = `http://${rep}.onion`;
										a.append(create_link(`http://${rep}.onion.to/`, {button: 'Onion'}));
										a.append(create_tag('warn', 'Deprecated'));
										break;
									}
									case 0x1BD: { // onion v3
										// https://www.tor2web.org/
										rep = Base32.encode(buf);
										if (rep.length !== 56) throw new Error('bad length');
										url = `http://${rep}.onion`;
										a.append(create_link(`http://${rep}.onion.to/`, {button: 'Onion'}));
										a.append(create('span', {className: ['tags', 'minor'], innerText: 'v3'}));
										break;
									}
									case 0xB19910: { // skylink
										// https://support.skynetlabs.com/key-concepts/skylinks
										rep = Base64URL.encode(buf);
										if (rep.length != 46) throw new Error('bad length');
										url = `sia://${rep}`;
										a.append(create_link(`https://siasky.net/${rep}`, {button: 'Skylink'}));
										break;
									}
									case 0xB29910: { // arweave
										// https://docs.arweave.org/developers/arweave-node-server/http-api
										if (buf.length != 32) throw new Error('not sha256');
										rep = Base64URL.encode(buf);
										url = `ar://${rep}`;
										a.append(create_link(`https://arweave.net/${rep}`, {button: 'Arweave'}));
										a.append(create_link(`https://viewblock.io/arweave/tx/${rep}`, {button: EMOJI_INSPECT}));
										break;
									}
									default: throw new Error(`unknown protocol: ${proto}`);
								}
								let lines = [url, `Protocol: ${format_dec_hex(proto)}`];
								if (cid) {
									lines.push(`CID: Version: ${format_dec_hex(cid.version)} / Codec: ${format_dec_hex(cid.codec)} / Bytes: ${buf.length}`);
									lines.push(`Hash: Codec: ${format_dec_hex(cid.hash.codec)} / Bytes: ${cid.hash.data.length}`);
									a.append(create_link(`https://cid.ipfs.tech/#${cid}`, {button: EMOJI_INSPECT}));
								}
								lines.push(`Raw: ${data}`, ALT_RAW);
								a.dataset.alt = data;
								a.title = lines.join('\n');
								make_click_copy(a, url);
								// upgrade the decentralized website link
								$('.row.dns')?.replaceWith(create_dns_row(name_norm, {replaced: false, contenthash: rep}));
							} catch (err) {
								a.append(create_tag('fail', err));
								make_click_copy(a, data, {hint: true});
							}
							a.append(create_link(`../../cid.js/test/demo.html#${data}`, {button: EMOJI_CHECK}));
							break;
						}
					}
					if (error) {
						if (skipped) {
							skip_count++;
						} else {
							fail_count++;
							if (resolve_state.debug) {
								a.append(create_tag('fail', error));
								a.classList.add('rtrim');
								records_row.append(a);
								console.debug(error);
							}
						}
					} else {
						records_row.append(a);
						good_count++;
					}
				}
				let null_count = results.length - good_count - fail_count - skip_count;

				if (records.length) {
					let tally = create('span', {className: 'tally'});
					let call_count = good_count + null_count + fail_count; // dont include skipped
					if (call_count > good_count) tally.append(create('span', {className: 'total', innerText: call_count, title: 'Total Records'}));
					if (good_count) tally.append(create('span', {className: 'pass', innerText: good_count, title: 'Non-null Records'}));
					if (null_count) tally.append(create('span', {className: 'none', innerText: null_count, title: 'Null Records'}));
					if (fail_count) tally.append(create('span', {className: 'fail', innerText: fail_count, title: 'Erroring Records'}));
					if (skip_count) tally.append(create('span', {className: 'skip', innerText: skip_count, title: 'Skipped Records'}));
					add_row_tag(records_row, tally);
					if (info.multicalled) {
						add_row_tag(records_row, create_tag('good', resolver.__info.wild ? 'Wildcard Multicall' : 'Multicall'));
					}
				} else {				
					add_row_tag(records_row, 'None');
				}
			}
			if (should_stop_resolving()) return;
			remove_temporary(records_row);
			add_row_tag(records_row, create_elapsed_since());
		}
	}

	if (input_is_address || !address) return; // nothing more to do

	// lookup primary from eth address
	let primary, primary_err;
	let primary_row = create_row('Primary');
	add_spinner(primary_row);
	let rev_resolver;
	output_div.append(primary_row);
	//primary_row.append(create_jazz_icon(address)); // only true in the forward direction
	try {
		rev_resolver = await get_resolver(get_reverse_name(address));
		if (rev_resolver) {
			if (should_stop_resolving()) return;
			let [{data, error}] = await fetch_records(rev_resolver, [{type: TYPE_NAME}]);
			if (error) throw error;
			if (resolve_state.debug && resolve_state.debug.primary) data = data.toUpperCase();
			primary = data;
		}
	} catch (err) {
		primary_err = err;
	}
	if (should_stop_resolving()) return;
	remove_temporary(primary_row);
	add_row_tag(primary_row, create_elapsed_since());
	if (primary_err) {
		primary_row.classList.add('error');
		add_row_tag(primary_row, create_tag('warn', primary_err));
		return;
	}
	if (!primary) {
		add_row_tag(primary_row, create_tag('warn', 'Not Set'));
		return;
	}
	make_exploded(primary_row, primary, false);

	// lets check if it's normalized
	let primary_norm;
	try {
		primary_norm = ens_normalize(primary);
		if (primary_norm === name_norm) {
			if (owner === address) {
				add_row_tag(normed_row, create_tag('fire', 'Primary Owner'));
			} else {
				add_row_tag(normed_row, create_tag('good', 'Primary'));
			}
		}
	} catch (err) {
		primary_row.classList.add('error');
		add_row_tag(primary_row, create_tag('norm', err));
	}

	if (primary === input) {
		add_row_tag(primary_row, SAME_AS_INPUT);
	} else if (primary === name_norm) {
		add_row_tag(primary_row, SAME_AS_NORM);
	} else {
		add_row_tag(primary_row, create_copy_btn(primary));
		add_row_tag(primary_row, create_resolve_btn(primary));
		add_ensip1_tag(primary_row, primary);
	}
	add_row_tag(primary_row, create_reverse_resolve_btn(address));

	if (primary === name_norm) {
		primary_row.classList.add('normalized');
		return;
	}
	output_div.append(create_breakdown_row(primary, true));
	if (primary === primary_norm) {
		make_normalized(primary_row, primary_norm);
		return;
	}
	if (!primary_norm) return;
	add_row_tag(primary_row, create_tag('fail', 'Normalized'));

	let primary_norm_row = create_row('Normalized Primary');
	make_exploded(primary_norm_row, primary_norm, true);
	output_div.append(primary_norm_row);
	if (primary_norm === input) {
		add_row_tag(primary_norm_row, SAME_AS_INPUT);
		primary_norm_row.classList.add('normalized');
		return;
	}
	if (name_norm === primary_norm) {
		add_row_tag(primary_norm_row, SAME_AS_NORM);
		primary_norm_row.classList.add('normalized');
	} else {
		add_row_tag(primary_norm_row, create_copy_btn(primary_norm));
		add_ensip1_tag(primary_norm_row, primary_norm, true);
		add_row_tag(primary_norm_row, create_resolve_btn(primary_norm));
		make_normalized(primary_norm_row, primary_norm);
	}
	output_div.append(create_breakdown_row(primary_norm));
}

function add_epf_row(address) {
	let row = create_row(create_link(`https://ethfollow.xyz/`, {innerHTML: 'EFP'}));
	row.classList.add('efp');
	add_spinner(row);
	output_div.append(row);
	(async () => {
		const t0 = Date.now();
		let got_list;
		try {
			async function fetch_epf(path) {
				const res = await fetch('https://api.ethfollow.xyz' + path);
				if (!res.ok) throw new Error(`http ${res.status}`);
				return res.json();
			}
			const {primary_list} = await fetch_epf(`/api/v1/users/${address}/primary-list`);
			got_list = true;
			if (!row.isConnected) return;
			// https://docs.ethfollow.xyz/api/users/stats/
			// https://docs.ethfollow.xyz/api/users/details/
			const [stats, details] = await Promise.all([
				fetch_epf(`/api/v1/lists/${primary_list}/stats?live=false`),
				fetch_epf(`/api/v1/users/${address}/details`),
			]);
			if (!row.isConnected) return;
			row.append(create('a', {
				className: 'record',
				href: `https://opensea.io/assets/base/0x0e688f5dca4a0a4729946acbc44c792341714e08/${primary_list}`,
				target: '_blank'
			}, create('b', null, 'Primary List'), primary_list));

			function add_rank(label, key) {
				const rank = details.ranks[key];
				if (rank) {
					row.append(create('span', {className: ['record', 'rtrim']}, create('b', null, label), create_tag('minor', `#${rank}`)));
				}
			}
			add_rank('Top 8', 'top8_rank');
			add_rank('Blocks', 'blocks_rank');
			add_rank('Mutuals', 'mutuals_rank');

			row.append(create('span', {className: ['record', 'rtrim']}, create('b', null, 'Followers'), stats.followers_count, create_tag('minor', `#${details.ranks.followers_rank}`)));
			row.append(create('span', {className: ['record', 'rtrim']}, create('b', null, 'Following'), stats.following_count, create_tag('minor', `#${details.ranks.following_rank}`)));

			add_row_tag(row, create_link(`https://ethfollow.xyz/${address}`, {button: 'â†—ï¸ Follow'}));
			add_row_tag(row, create_link(`https://api.ethfollow.xyz/api/v1/users/${address}/qr`, {button: 'ğŸ™¾ QR Code'}));
		} catch (err) {
			row.classList.add('error');
			add_row_tag(row, create_tag('warn', err));
		}
		if (got_list) {
			remove_temporary(row);
			add_row_tag(row, create_elapsed(Date.now() - t0, 0));
		} else {
			row.remove();
		}
	})();
}


function add_owner_links(row, owner) {
	let group = create('div', {className: ['grouped', 'external']});
	add_row_tag(group, create_link(`${active_chain.is_mainnet ? 'https://opensea.io/' : 'https://testnets.opensea.io/'}${owner}?tab=collected`, {innerHTML: OPENSEA_NAME}));
	if (active_chain.is_mainnet) {
		add_row_tag(group, create_link(`https://${VISION_HOST}/0x/${owner}`, {innerHTML: VISION_NAME}));
	}
	add_row_tag(group, create_link(`https://rainbow.me/${owner}`, {innerHTML: 'Rainbow'}));
	add_row_tag(group, create_link(`https://debank.com/profile/${owner}`, {innerHTML: 'Debank'}));
	row.append(group);
}
function is_user_rejection(err) {
	return err.shortMessage === 'user rejected action';
}
function parse_call_error(calldata) {
	let selector = calldata.slice(0, 10);
	let message = `<a href="https://www.4byte.directory/signatures/?bytes4_signature=${selector}" target="_blank"><code>${selector}</code></a>`;
	let error = {selector, code: 'CALL_EXCEPTION', data: '0x' + calldata.slice(10)};
	let desc = ERROR_ABI.parseError(calldata);
	if (desc) {
		error.desc = desc;
		if (desc.name === 'Error') {
			entity_span.innerText = desc.args[0];
			message = `<strong>${desc.signature}</strong> ${entity_span.innerHTML}`;
		} else if (desc.name === 'Panic') {
			message = `<strong>${desc.signature}</strong> â†’ ${desc.args[0]}`;
		} else {
			message = `<strong>${desc.name}(</strong>${[...desc.args].map((x, i) => {
				const {name, type} = desc.fragment.inputs[i];
				if (name === 'name' && type === 'bytes') {
					try {
						x = labels_from_dns_encoded(ethers.getBytes(x)).join('.');
						x = ens_beautify(x);
					} catch (err) {
					}
				}
				let rep = `<code>${x}</code>`;
				return name ? `${name}:${rep}` : rep;
			}).join(', ')}<strong>)</strong>`
		}
	}
	return Object.assign(new Error(`Call error: ${message}`), error);
}
function parse_ethers_error(err) {
	if (err.code === 'CALL_EXCEPTION' && err.data) {
		return parse_call_error(err.data);
	} else if (err.code === 'OFFCHAIN_FAULT') {
		if (err.reason === '404_MISSING_RESOURCE') {
			return new Error(`CCIP error: <b title="${err.info.url}">HTTP 404</b>`);
		}
		let {reason, errorMessages = ['unknown']} = err.info;
		if (reason) {
			return new Error(`CCIP error: ${errorMessages.join(' ')} <code>${reason}</code>`);
		}
	}
	return err;
}
async function fetch_addr60(resolver) {
	if (!resolver) throw new Error('Resolver not set');
	let [{data: address, error}] = await fetch_records(resolver, [{type: TYPE_ADDR, coin: 60n}]);
	if (error) throw error;
	if (!is_null_hex(address)) return ethers.getAddress(address);
}
async function fetch_records(resolver, records, info = {}) {
	const options = {enableCcipRead: true}; // 20240211: CCIP getting cached??? blockTag: 'latest'};
	const {target, interface: abi, __node, __dns_encoded, __info: {wild}} = resolver;
	if (records.length > 1 && !resolver.__unreachable) {
		let encoded = records.map(rec => {
			let frag = abi.getFunction(rec.type);
			let params = [rec.node || __node];
			switch (rec.type) {
				case TYPE_TEXT: params.push(rec.key); break;
				case TYPE_ADDR: params.push(rec.coin); break;
			}
			return abi.encodeFunctionData(frag, params);
		});
		try {
			let multi;
			if (wild) { // optimistic CCIP-multicall
				let frag = abi.getFunction('multicall');
				let data = await resolver['resolve(bytes,bytes)'](__dns_encoded, abi.encodeFunctionData(frag, [encoded]), options);
				[multi] = abi.decodeFunctionResult(frag, data);
			} else {
				multi = await network_state.multicall.tryAggregate(false, encoded.map(data => [target, data]));
				multi = multi.map(x => x.data);
			}
			if (multi && multi.length === records.length) {
				info.multicalled = true;
				return records.map((rec, i) => {
					let calldata = multi[i];
					try {
						let frag = abi.getFunction(rec.type);
						if ((calldata.length - 2) & 63) {
							return {rec, error: parse_call_error(calldata)};
						} else {
							let data = abi.decodeFunctionResult(frag, calldata);
							if (frag.outputs.length === 1) data = data[0];
							return {rec, data};
						}
					} catch (error) {
						return {rec, error};
					}
				});
			}
		} catch (err) {
		}
	}
	return Promise.all(records.map(async rec => {
		if (should_stop_resolving()) {
			return {rec, error: new Error('aborted')};
		}
		if (!resolve_state.debug && rec.bonus) {
			return {rec, error: new Error('skipped'), skipped: true};
		}
		if (resolver.__unreachable) {
			return {rec, error: new Error('unreachable'), skipped: true};
		}
		let params = [__node];
		if (rec.type === TYPE_ADDR && rec.coin == 60) { // try boomer method first
			const method = 'addr(bytes32)';
			try {
				let data;
				if (wild) {
					let frag = abi.getFunction(method);
					let calldata = await resolver['resolve(bytes,bytes)'](__dns_encoded, abi.encodeFunctionData(frag, params), options);
					[data] = abi.decodeFunctionResult(frag, calldata);
				} else {
					data = await resolver[method](__node, options);
				}
				return {rec, data};
			} catch (err) {
				if (err instanceof TypeError) { // fetch() network error?
					resolver.__unreachable = 'network';
				 	return {rec, error: err};
				} else {
					let error = parse_ethers_error(err);
					switch (error.desc && error.desc.name) { // currently thrown by OffchainDNS resolver
						case 'InvalidLabelCount': // unicode
						case 'CouldNotResolve':   // no records
							resolver.__unreachable = 'contract';
							return {rec, error};
					}
				}
			}
		}
		switch (rec.type) {
			case TYPE_TEXT: params.push(rec.key); break;
			case TYPE_ADDR: params.push(rec.coin); break;
		}
		try {
			let data;
			if (wild) {
				let frag = abi.getFunction(rec.type);
				data = await resolver['resolve(bytes,bytes)'](__dns_encoded, abi.encodeFunctionData(frag, params), options);
				data = abi.decodeFunctionResult(frag, data);
				if (frag.outputs.length === 1) data = data[0];
			} else {
				data = await resolver[rec.type](...params, options);
			}
			return {rec, data};
		} catch (err) {
			return {rec, error: parse_ethers_error(err)};
		}
	}));
}
async function fetch_resource_url(value, owner_set) {
	if (value.startsWith('data:')) {
		return {url: value, type: 'On-chain'};
	}
	const SEP = '://';
	let pos = value.indexOf(SEP);
	if (pos >= 0) {
		let proto = value.slice(0, pos).toLowerCase();
		let rest = value.slice(pos + SEP.length);
		let type;
		try {
			switch (proto) {
				case 'ipfs': {
					type = 'IPFS';
					let path = rest.replace(/^ipfs\//, ''); // drop leading /ipfs/
					CID.from(path.split('/', 1)[0]); // validate cid
					value = url_from_ipfs_path(path);
					break;
				}
				case 'ar': {
					type = 'Arweave';
					if (Base64URL.decode(rest).length != 32) throw new Error('expected sha256');
					value = `https://arweave.net/${rest}`;
					break;
				}
				case 'http':
				case 'https': {
					type = 'URL'; 
					break;
				}
			}
		} catch (err) {
			return {error: `Invalid ${type} URL: ${err.message}`};
		}
		if (type) {
			try {
				return {url: new URL(value).toString(), type, proto};
			} catch (err) {
				return {error: 'invalid url'};
			}
		}
	}
	if (value.startsWith('eip155:')) {
		let match = value.toLowerCase().match(/^eip155:([0-9]+)\/erc(721|1155):(0x[0-9a-f]{40})\/(0x[0-9a-f]+|[0-9]+)$/i);
		if (!match) {
			return {error: 'invalid avatar string'};
		}
		let chain_id = parseInt(match[1]);
		let erc = match[2];
		let address = match[3];
		let token = BigInt(match[4]);
		// TODO: check known chains
		if (chain_id !== active_chain.id) {
			return {error: `unsupported chain: ${format_dec_hex(chain_id)}`};
		}
		switch (erc) {
			case '721': {
				let contract = new ethers.Contract(address, [
					`function tokenURI(uint256) view returns (string)`,
					`function ownerOf(uint256) view returns (address)`,
				], active_provider);
				let nft_owner = await contract.ownerOf(token);
				return {
					address,
					token,
					owned: owner_set?.has(nft_owner),
					...await fetch_nft_image(await contract.tokenURI(token))
				};
			}
			case '1155': {
				let contract = new ethers.Contract(address, [
					`function uri(uint256) view returns (string)`,
					`function balanceOf(address, uint256) view returns (uint256)`,
				], active_provider);
				let balances = owner_set ? await Promise.all(Array.from(owner_set, x => contract.balanceOf(x, token))) : [];
				return {
					address,
					token,
					owned: balances.some(x => x > 0),
					...await fetch_nft_image(await contract.uri(token).then(url => url.replace('{id}', token.toString(16).padStart(64, '0'))))
				};
			}
			default: return {error: `unknown ERC-${erc}`};
		}
	}
	return {error: 'unknown format'};
}
async function fetch_nft_image(url0) {
	let {error, url: meta_url} = await fetch_resource_url(url0);
	if (error) {
		return {error: 'expected metadata url', cause: error};
	}
	// fix opensea bullshit
	let fixed;
	const opensea_v1 = 'https://api.opensea.io/api/v1/metadata/';
	if (meta_url.startsWith(opensea_v1)) {
		meta_url = `https://api.opensea.io/api/v2/metadata/ethereum/${meta_url.slice(opensea_v1.length)}`;
		fixed = `${OPENSEA_NAME} v1 â†’ v2`;
	}
	try {
		let res = await fetch(meta_url);
		if (res.ok) {
			let {image} = await res.json();
			if (typeof image !== 'string') {
				return {error: 'expected metadata "image"'};
			}
			let {error, url} = await fetch_resource_url(image);
			if (error) {
				return {error};
			}
			return {type: 'NFT', url, meta_url, fixed};
		} else {
			return {error: `HTTP ${res.status}: ${meta_url}`};
		}
	} catch (cause) {
		return {error: `fetch failure`, cause};
	}
}
async function try_reverse_registrar() {
	let {reverse} = network_state;
	if (reverse === undefined) {
		try {
			reverse = await network_state.ens.owner(namehash('addr.reverse'));
			if (is_null_hex(reverse)) reverse = null;
		} catch (err) {
			reverse = false;
		}
		network_state.reverse = reverse;
	}
	return reverse;
}
async function ensure_eth_resolver() {
	let {eth} = network_state;
	if (eth) return;
	if (eth === false) throw new Error(`No "eth" resolver`);
	network_state.eth = await get_resolver('eth', true) || false;
	return ensure_eth_resolver();
}
function contract_for_controller(address) {
	return new ethers.Contract(address, [
		'function owner() external view returns (address)',
		'function prices() external view returns (address)',
		'function nameWrapper() external view returns (address)',
	], active_provider);
}
function contract_for_price_oracle(address) {
	return new ethers.Contract(address, [
		'function premium(string calldata name, uint256 expires, uint256 duration) external view returns (uint256)',
		'function price(string calldata name, uint256 expires, uint256 duration) external view returns (uint256)',
		'function usdOracle() external view returns (address)',
	], active_provider);
}
async function ensure_wrapper() {
	let {wrapper, ens} = network_state;
	if (wrapper) return;
	if (wrapper === false) throw new Error(`Not implementated`);
	await ensure_eth_resolver();
	const {eth} = network_state;
	let address = await eth.interfaceImplementer(eth.__node, '0x019a38fe');
	if (is_null_hex(address)) {
		network_state.wrapper = false;
		return ensure_wrapper();
	}
	network_state.wrapper = new ethers.Contract(address, [
		'function isWrapped(bytes32 node) public view returns (bool)',
		'function getData(uint256 id) external view returns (address owner, uint32 fuses, uint64 expiry)',
		'function names(bytes32 node) public view returns (bytes)',
	], active_provider);
}
async function ensure_eth_nft() {
	let {eth_nft} = network_state;
	if (eth_nft) return;
	if (eth_nft === false) throw new Error(`Not implemented`);
	await ensure_eth_resolver();
	const {ens, eth} = network_state;
	let address = await ens.owner(eth.__node);
	check_abort();
	if (is_null_hex(address)) {
		network_state.eth_nft = false;
		return ensure_eth_nft();
	}
	eth_nft = new ethers.Contract(address, [
		'function available(uint256 id) external view returns(bool)',
		'function nameExpires(uint256 id) external view returns(uint256)',
		'function ownerOf(uint256 id) external view returns (address)',
		'function GRACE_PERIOD() external view returns (uint256)',
	], active_provider);
	let [grace_sec, controller_address] = await Promise.all([
		eth_nft.GRACE_PERIOD().then(Number).catch(() => 90*86400),
		eth.interfaceImplementer(eth.__node, IFACE_ETH_CONTROLLER)
	]);
	check_abort();
	let eth_controller = contract_for_controller(controller_address);
	let price_oracle = contract_for_price_oracle(await eth_controller.prices());
	check_abort();
	Object.assign(network_state, {
		eth_nft,
		eth_controller,
		price_oracle,
		grace_period: 1000 * grace_sec,
		premium_period: 1000 * 21*86400 // TODO: find this on-chain
	});
}
function labels_from_dns_encoded(v) {
	let labels = [];
	let pos = 0;
	while (true) {
		let n = v[pos++];
		if (!n) { // empty
			if (pos !== v.length) break; // must be last
			return labels;
		}
		if (v.length < pos+n) break; // overflow
		labels.push(utf8_from_bytes(v.subarray(pos, pos += n)));
	}
	throw new Error('invalid DNS-encoded name');
}
function dns_encoded_from(labels) {
	if (typeof labels === 'string') {
		labels = labels ? labels.split('.') : [];
	}
	const MAX_LABEL = 255;
	let v = [];
	for (let label of labels) {
		if (!label) throw new Error('invalid empty label');
		let u = bytes_from_utf8(label);
		if (u.length > MAX_LABEL) throw new Error(`too long: ${u.length} > ${MAX_LABEL}`);
		v.push(u.length, ...u);
	}
	v.push(0);
	return Uint8Array.from(v);
}
async function is_contract(address) {
	const {contracts} = active_chain;
	let is = contracts.get(address);
	if (is === undefined) {
		try {
			is = !is_null_hex(await active_provider.getCode(address));
			contracts.set(address, is);
		} catch (err) {
		}
	}
	return is;
}
async function multicall_tryAggregate(calls) {
	try {
		return await network_state.multicall.tryAggregate(false, calls);
	} catch (err) {
		// if a function doesnâ€™t exist on a contract compiled in solidity
		// version 0.4.11 or below, itâ€™ll revert and use all the gas available
		// assume call exception => out of gas
		if (err.code !== 'CALL_EXCEPTION') throw err;
	}
	return Promise.all(calls.map(async ({target, data}) => {
		try {
			let res = await active_provider.call({to: target, data});
			return [!((res.length - 2) & 63), res];
		} catch (err) {
			return [false, '0x', err];
		}
	}));
}
async function load_known_interfaces(row, resolver) {
	const iface_nft = {iface: '0x6ccb2df4', title: 'NFT (721)'};
	// https://docs.ens.domains/contract-api-reference/.eth-permanent-registrar
	const dynamic_frag = RESOLVER_ABI.getFunction('interfaceImplementer');
	const dynamic_ifaces = resolver.__info.impl ? [
		{iface: '0x019a38fe', title: `${WRAPPER_NAME} (1155)`},
		{iface: IFACE_ETH_CONTROLLER, title: 'Controller'},
		{iface: '0x018fac06', title: 'Old Controller'},
		{iface: '0x7ba18ba1', title: 'Old Registrar'},
		{iface: '0xd1a70fd3', title: 'Bulk Renewal'},
		iface_nft,
	] : [];
	const supports_frag = RESOLVER_ABI.getFunction('supportsInterface');
	const supports_ifaces = [
		{iface: '0x3b3b57de', title: 'AddrResolver', url: 'https://docs.ens.domains/ensip/1#contract-address-interface-'},
		{iface: '0xf1cb7e06', title: 'AddressResolver', url: 'https://docs.ens.domains/ensip/9'},
		{iface: '0x59d1d43c', title: 'TextResolver', url: 'https://docs.ens.domains/ensip/5'},
		{iface: '0xbc1c58d1', title: 'ContentHashResolver', url: 'https://docs.ens.domains/ensip/7'},
		{iface: '0x691f3431', title: 'NameResolver', url: 'https://docs.ens.domains/ensip/3'},
		{iface: '0xc8690233', title: 'PubkeyResolver', url: 'https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/profiles/IPubkeyResolver.sol'},
		{iface: '0x2203ab56', title: 'ABIResolver', url: 'https://docs.ens.domains/ensip/4'},
		{iface: '0x124a319c', title: 'InterfaceResolver', url: 'https://docs.ens.domains/ensip/8', supports: resolver.__info.impl},
		{iface: '0x9061b923', title: 'ExtendedResolver', url: 'https://docs.ens.domains/ensip/10', supports: resolver.__info.wild},
		{iface: '0x8ef98a7e', title: 'ExtendedDNSResolver', url: 'https://docs.ens.domains/ensip/17', supports: resolver.__info.edns},
		{iface: '0x73302a25', title: 'TheOffchainResolver', url: 'https://github.com/namestonehq/TheOffchainResolver.sol', supports: resolver.__info.edns},
	];
	const discovered = new Set();
	function add_iface(html, address, iface) {
		if (is_null_hex(address)) return;
		if (discovered.has(address)) return;
		discovered.add(address);
		const lines = [];
		if (iface) {
			html += ` <code>${iface.slice(2)}</code>`;
			lines.push(`${dynamic_frag.name}()`, `Interface: ${iface}`);
		} else {
			lines.push(`(derived)`);
		}
		lines.push(`Contract: ${address}`);
		html += ` <code class="prefix">${address.slice(0, 6)}</code>`;
		add_row_tag(row, create_explorer_address_link(address, {innerHTML: html, contract: true, className: 'iface', title: lines.join('\n')}));
	}
	const {target, __node} = resolver;
	try {
		const multi = [...await multicall_tryAggregate([
			...dynamic_ifaces.map(x => {
				return {target, data: RESOLVER_ABI.encodeFunctionData(dynamic_frag, [__node, x.iface])};
			}),
			...supports_ifaces.filter(x => !('supports' in x)).map(x => {
				return {target, data: RESOLVER_ABI.encodeFunctionData(supports_frag, [x.iface])};
			})
		])];
		if (should_stop_resolving()) return;
		for (const x of dynamic_ifaces) {
			const [ok, data] = multi.shift();
			if (!ok) continue;
			const [addr] = RESOLVER_ABI.decodeFunctionResult(dynamic_frag, data);
			if (is_null_hex(addr)) {
				if (x === iface_nft && resolver.__name === "eth") {
					add_iface(iface_nft.title, await network_state.ens.owner(__node));
				}
				continue;
			}
			add_iface(x.title, addr, x.iface);
			if (x.iface === IFACE_ETH_CONTROLLER) {
				const controller = contract_for_controller(addr);
				const oracle = await controller.prices().catch(() => {});
				if (!is_null_hex(oracle)) {
					add_iface('Price Oracle', oracle);
					add_iface('USD Oracle', await contract_for_price_oracle(oracle).usdOracle().catch(() => {}));
				}
				add_iface(WRAPPER_NAME, await controller.nameWrapper().catch(() => {}));
				add_iface('Public Resolver', await network_state.ens.resolver(namehash('resolver.eth')));
				//add_iface('DAO Wallet', await contract.owner().catch(() => ''));
			}
		}
		for (const x of supports_ifaces) {
			if ('supports' in x) {
				if (!x.supports) continue;
			} else {
				const [ok, data] = multi.shift();
				if (!ok) continue;
				const [supports] = RESOLVER_ABI.decodeFunctionResult(supports_frag, data);
				if (is_null_hex(supports)) continue;
			}
			add_row_tag(row, create_link(x.url, {
				innerHTML: `${x.title} <code>${x.iface.slice(2)}</code>`,
				title: `${supports_frag.name}()\nInterface: ${x.iface}`,
				className: ['iface', 'supports'],
			}));
			discovered.add(x.iface);
		}
		if (!discovered.size) {
			add_row_tag(row, 'None');
		}
	} catch (err) {
		add_row_tag(row, create_tag('warn', err));
	}
}
function fetch_verifications(data, owner, ens_name) {
	// note: this is super shitty and hacky
	let row = create_row('Verifications');
	row.classList.add('verifications');
	output_div.append(row);
	let urls;
	try {
		urls = JSON.parse(data);
		if (!Array.isArray(urls)) throw new Error('expected list of urls');
	} catch (err) {
		add_row_tag(row, create_tag('warn', err.message));
		return;
	}
	if (!urls.length) {
		row.remove();
		return;
	}
	const t0 = Date.now();
	let finished = 0;
	for (let url of urls) {
		let loader = create('a', {
			href: url,
			target: '_blank',
			className: 'record',
		});
		row.append(loader);
		try {
			url = new URL(url);
			let spinner = create('div', {className: ['spinner']});
			loader.append(spinner);
			loader.append(url.host); //create('b', {innerText: url.host}));
			(async () => {
				try {
					let res = await fetch(url);
					if (!res.ok) {
						let error;
						try {
							const {message} = await res.json();
							if (message) {
								error = message;
							}
						} catch (ignored) {
						}
						throw new Error(error ?? `HTTP ${res.status}`);
					}
					let json = await res.json();
					if (!row.isConnected) return;
					let {vp_token} = json;
					if (!vp_token) throw new Error('expected vp_token');
					if (!Array.isArray(vp_token)) vp_token = [vp_token];
					let ens = vp_token.find(token => token.credentialSubject.credentialType === 'Verified ENS');
					if (!ens) throw new Error('no ENS record');
					const {ensName, ethAddress} = ens.credentialSubject;
					//if (ensName !== ens_name) throw new Error(`wrong ENS name: ${ensName}`);
					//if (ethAddress !== owner) throw new Error(`wrong owner: ${ethAddress}`);
					for (let token of json.vp_token) {
						if (token === ens) continue;
						let a = create('a', {
							href: url,
							target: '_blank',
							className: 'record',
						});
						let [key, value] = extract_verificiation_kv(token);
						let rec = RECORDS.find(x => x.key === key);
						if (rec?.icon) a.innerHTML = rec.icon;
						a.append(create('b', {innerText: key}));
						a.title = `Issuer: ${ens.credentialSubject.credentialIssuer}`;
						rec = $(`.row.records [data-key="${key}"]`);
						if (rec && !rec.dataset.value.localeCompare(value, undefined, { sensitivity: "base" })) {
							rec.classList.add('verified');
						} else if (value) {
							a.classList.add('rtrim');
							if (value) a.append(create('span', {innerText: value}));
							a.append(create_copy_btn(value));
							if (rec) {
								a.append(create('span', {innerText: 'âš ï¸ Different', className: ['tags', 'changed']}));
							}
						}
						row.append(a);
					}
					loader.remove();
				} catch (err) {
					loader.append(create('span', {innerText: `âŒï¸ ${err.message}`, className: ['tags', 'changed']}));
					loader.classList.add('rtrim');
				}
				spinner.remove();
				finish();
			})();
		} catch (err) {
			loader.innerText = 'âŒï¸ Invalid URL';
			finish();
		}
		function finish() {
			if (++finished < urls.length) return;
			row.append(create_elapsed(Date.now() - t0)); //, finished));
		}
	}
}
function extract_verificiation_kv(token) {
	const subj = token.credentialSubject;
	const type = subj.credentialType;
	switch (type) {
		case 'Verified Account': {
			let key = subj.verificationSource;
			key = {
				X: 'com.twitter',
				Telegram: 'org.telegram',
				Discord: 'com.discord'
			}[key] ?? key;
			return [key, subj.username ?? subj.name];
		}
		case 'Verified Email': return ['email', subj.verifiedEmail];
		default: return [type];
	}
}
async function get_resolver_info(target) {
	const {resolvers, contracts} = active_chain;
	let info = resolvers.get(target);
	if (info === undefined) {
		info = {};
		if (contracts.get(target) !== false) { // isn't an EoA
			const multi = await multicall_tryAggregate([
				{target, data: RESOLVER_ABI.encodeFunctionData('supportsInterface', ['0x124a319c'])}, // IInterfaceResolver:   interfaceImplementer(bytes32,bytes4)
				{target, data: RESOLVER_ABI.encodeFunctionData('supportsInterface', ['0x9061b923'])}, // IExtendedResolver:    resolve(bytes,bytes)
				{target, data: RESOLVER_ABI.encodeFunctionData('supportsInterface', ['0x8ef98a7e'])}, // IExtendedDNSResolver: resolve(bytes,bytes,bytes)
				{target, data: RESOLVER_ABI.encodeFunctionData('supportsInterface', ['0x73302a25'])}, // TheOffchainResolver.sol
				{target, data: RESOLVER_ABI.encodeFunctionData('oracle')}
			]);
			check_abort();
			if (multi.some(x => x.ok)) contracts.set(target, true); // any success => is contract
			const [impl, wild, edns, tor, oracle] = multi;
			info.impl = impl.ok && !is_null_hex(impl.data);
			info.wild = wild.ok && !is_null_hex(wild.data);
			info.edns = edns.ok && !is_null_hex(edns.data);
			info.tor  =  tor.ok && !is_null_hex(tor.data );
			try {
				if (oracle.ok) {
					const [address] = RESOLVER_ABI.decodeFunctionResult('oracle', oracle.data);
					if (!is_null_hex(address)) {
						info.dnssec_oracle = address;
					}
				}
			} catch (err) {
			}
		}
		resolvers.set(target, info);
	}
	return info;
}
function contract_for_resolver(address) {
	return new ethers.Contract(address, RESOLVER_ABI, active_provider);
}
async function get_resolver(name0, skip_rewrite) {
	// returns resolver | null | throws
	const {ens} = network_state;
	let func = ens.interface.getFunction('resolver');
	let labels = name0.split('.');
	let domains = labels.map((_, i) => {
		let name = labels.slice(i).join('.');
		return {name, node: namehash(name)};
	});
	let multi = await multicall_tryAggregate(domains.map(x => {
		return {target: ens.target, data: ens.interface.encodeFunctionData(func, [x.node])};
	}));
	for (let i = 0; i < domains.length; i++) {
		let {name, node} = domains[i];
		let [address] = ens.interface.decodeFunctionResult(func, multi[i].data);
		if (!skip_rewrite) {
			try {
				let last = -1;
				for (const [suffix, rewrite] of Object.entries(resolve_state.debug.resolver)) {
					if (suffix.length > last && name === suffix || name.endsWith(`.${suffix}`)) {
						address = rewrite;
						last = suffix.length;
						break;
					}
				}
			} catch (err) {
			}
		}
		check_abort();
		if (is_null_hex(address)) continue;
		// https://github.com/ensdomains/ens-contracts/tree/staging/contracts/resolvers/profiles
		// https://docs.ens.domains/ensip/10
		let resolver = contract_for_resolver(address);
		let info = await get_resolver_info(address);
		if (i && !info.wild) break; // ancestor but not wildcard
		resolver.__info = info;
		resolver.__name = name0;
		resolver.__node = namehash(name0);
		resolver.__dropped = i; // truthy => virtual
		resolver.__basename = name;
		resolver.__basenode = node;
		if (info.wild) {
			try {
				resolver.__dns_encoded = dns_encoded_from(labels);
			} catch (err) {
				resolver.__unreachable = 'name too long';
			}
		}
		return resolver;
	}
	return null;
}
async function get_safe_primary(owner, alt_owner) {
	// return normalized primary if resolve(reverse(owner)) is owner or alt_owner | throws
	let rev_resolver = await get_resolver(get_reverse_name(owner));
	if (!rev_resolver) throw new Error('Primary not set');
	let [{data: primary, error}] = await fetch_records(rev_resolver, [{type: TYPE_NAME}]);
	check_abort();
	if (error) throw error;
	let name = ens_normalize(primary);
	if (!name) throw new Error('Primary is Null');
	let resolver = await get_resolver(name);
	check_abort();
	let address = await fetch_addr60(resolver);
	if (!address) throw new Error('Address not set');
	if (owner !== address && alt_owner !== address) throw new Error(`Address mismatch`);
	return name;
}
function repair_social(value, {prefix = '@', url = 1} = {}) {
	if (prefix && value.startsWith(prefix)) return value.slice(prefix.length);
	if (url) {
		try {
			if (Number.isInteger(url)) {
				const i = url;
				url = u => u.pathname.split('/')[i];
			}
			let fix = url(new URL(value));
			if (fix) return fix;
		} catch (err) {
		}
	}
	return value;
}
function base58check(v) {
	return Base58BTC.encode([...v, ...ethers.getBytes(ethers.sha256(ethers.sha256(v))).slice(0, 4)]);
}
// btc: {p2pkh: 0, p2sh: 5, hrp: 'bc', p2wpkh: 0, p2tr: 1},
function format_btc_address(v, {p2pkh, p2sh, hrp, p2wpkh, p2tr}) {
	let n = v.length;
	// P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
	if (Number.isInteger(p2pkh) && n >= 5 && v[0] == 0x76 && v[1] == 0xA9 && v[2] === n-5 && v[n-2] == 0x88 && v[n-1] == 0xAC) {
		v[2] = p2pkh;
		return base58check(v.subarray(2, -2));
	}
	// P2SH: OP_HASH160 <scriptHash> OP_EQUAL
	if (Number.isInteger(p2sh) && n >= 3 && v[0] == 0xA9 && v[1] == n-3 && v[n-1] == 0x87) {
		v[1] = p2sh;
		return base58check(v.subarray(1, -1));
	}
	try {
		let version = v[0];
		if (version) version -= 0x50;
		if (v[1] === v.length-2) {
			let v32 = convert(v.subarray(2), 8, 5);
			if (p2wpkh === version) {
				return new Bech32(hrp, [version, ...v32], 1).toString();
			}
			if (p2tr === version) {
				return new Bech32(hrp, [version, ...v32], Bech32.M).toString();
			}
		}
	} catch (err) {
	}
	throw new Error('invalid');
}
function strncmp(a, b) {
	return a ? a.localeCompare(b, undefined, {sensitivity: 'base'}) : a === b;
}
function create(el, args, ...a) {
	if (typeof el === 'string') el = document.createElement(el);
	if (args) {
		for (let [k, v] of Object.entries(args)) {
			if (!v) continue;
			if (v instanceof Function) {
				el.addEventListener(k, v);
			} else if (k === 'dataset' || k === 'style') {
				Object.assign(el[k], v);
			} else if (k === 'className') {
				for (let x of [v].flat(Infinity)) {
					if (typeof x === 'string') {
						el.classList.add(x);
					} else if (x) {
						Object.entries(x).forEach(([k, v]) => el.classList.toggle(k, !!v));
					}
				}
			} else {
				el[k] = v;
			}
		}
	}
	el.append(...a);
	return el;
}
function add_dot_eth(name, append) {
	const suffix = '.eth';
	if (name.endsWith('.')) name = name.slice(0, -1);
	if (name && !(append ? name.endsWith(suffix) : name.includes('.'))) name += suffix;
	return name;
}
function url_from_ipfs_path(s) {
	// 20240803: this is cors restricted
	//return `https://cloudflare-ipfs.com/ipfs/${s}`;
	return `https://ipfs.io/ipfs/${s}`;
}
function format_dec_hex(id) {
	return id < 10 ? id : `${id} (0x${id.toString(16).toUpperCase()})`;
}
function is_address(s) {
	return typeof s === 'string' && /^0x[0-9a-f]{40}$/i.test(s);
}
function is_checksum_address(s) {
	try {
		return is_address(s) && s === ethers.getAddress(s);
	} catch (ignored) {
	}
}
function is_null_hex(s) {
	return !s || /^0x0*$/.test(s);
}
function labelhash(s) {
	// TODO: consider [hash] form
	//if (/^\[[0-9a-f]{64}\]$/i.test(s)) {
	return ethers.keccak256(bytes_from_utf8(s));
}
function namehash(s) {
	let hash = ethers.ZeroHash;
	if (s) hash = s.split('.').reduceRight((h, x) => ethers.keccak256(h + labelhash(x).slice(2)), hash);
	return hash;
}
function bytes32_from(x) {
	return '0x' + BigInt(x).toString(16).padStart(64, '0').slice(-64);
}
function is_truelike_str(s) {
	return !/^(|0+|f|false|n|no|off)$/i.test(s);
}
function is_object(x) {
	return x && x.constructor === Object;
}
function chain_from_coin(x) {
	if (x === 60n) return 1n;
	if (x & EVM_BIT && BigInt.asUintN(32, x) === x) {
		return BigInt.asUintN(31, x);
	}
}
</script>
</body>
</html>
