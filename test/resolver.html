<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" type="image/png" href="./favicon.png">
<title>ENS Resolver</title>
<style>
:root {
	--btn-fill-color: #eee;
	--btn-hover-fill-color: #ccc;
	--btn-border-color: #888;
	--copied-color: #8f8;
	--confusing-color: #d47;
}
.hide {
	display: none !important;
}
.balloon {
	flex: 1;
}
.long {
	white-space: pre-wrap !important;
	word-break: break-word;
}
.force-ltr {
	direction: ltr;
	unicode-bidi: bidi-override;
}
a, button, select {
	cursor: pointer;
}
a.button {
	text-decoration: none;	
}
button {
	appearance: none;
	display: inline-flex;
	align-items: center;
	margin: 0;
	padding: 4px 8px;
	border: 1px solid var(--btn-border-color);
	border-radius: 4px;
	background-color: var(--btn-fill-color);
	color: #000;
	font-size: 100%;
	gap: 4px;
}
button:disabled {
	opacity: 50%;
	pointer-events: none;
}
button:hover {
	background-color: var(--btn-hover-fill-color);
}
button:hover:active {
	background-color: #aaa;
	/*transform: translate(0px, 1px);*/
}
.rtrim {
	padding-right: 4px !important;
}
body { 
	margin: 3rem; 
	background: #eee;
	display: flex;
	flex-direction: column;
	gap: 8px;
	overflow-y: scroll;
}
header {
	display: flex;
	flex-wrap: wrap;
	align-items: end;
	justify-content: space-between;
	gap: 4px 8px;
}
h1 {
	margin: 0;
}
#provider {
	font-size: 11pt;
	font-weight: normal;
	color: #666;
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 4px;
}
#provider button {
	font-size: 9pt;
	padding: 2px 6px;
}
#provider .notice {
	background-color: #fff;
	color: #000;
	padding: 1px 4px;
	border-radius: 4px;
	font-size: 90%;
}
#provider a {
	font-weight: bold;
}
#github {
	flex: 1;
	text-align: right;
	display: flex;
	flex-direction: column;
	order: 2;
	align-items: end;
	white-space: pre;
}
body.testnet {
	background: #ffe0ff;
}
.spinner {
	width: 32px;
	height: 32px;
	box-sizing: border-box;
	animation: spin 2s infinite linear;
	border: 5px solid #000;
	border-bottom-color: transparent;
	border-radius: 100%;
}
@keyframes spin {
	to { transform:rotate(360deg); }
}
#examples {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 4px;
	font-size: 11pt;
	padding-bottom: 6px;
	border-bottom: 2px solid #fff;
}
#examples b {
	font-size: 12pt;
}
#examples button:not([id]) {
	background: #fff;
	padding: 2px 4px;
	border: 2px solid transparent;
	transition: transform 0.1s;
	font-size: 10pt;
}
#examples button:not([id]):hover {
	border-color: #aaa;
	transform: scale(1.5);
}
#examples button:not([id]):hover:active {
	border-color: #000;
}
#examples button.mapped:not([id]) {
	border-color: #ccf;
}
#examples button.error:not([id]) {
	border-color: #fcc;
}
#examples a {
	background-color: #ffc;
}
#examples_btn {
	font-weight: bold;
}
#input {
	display: flex;
	align-items: stretch;
	gap: 8px;
}
#input input {
	box-sizing: border-box;
	width: 100%;
	padding: 8px;
	font-size: 20pt;
	line-height: 24pt;
	transition: font-size .5s ease-in-out;
}
#input input.small {
	font-size: 15pt;
}
#input input.smaller {
	font-size: 12pt;
}
#actions {
	min-height: 32px; /* spinner */
	display: flex;
	flex-wrap: wrap;
	justify-content: flex-end;
	align-items: stretch;
	gap: 8px;
}
.segmented {
	display: flex;
}
.segmented button:not(:last-child) {
	border-top-right-radius: 0;
	border-bottom-right-radius: 0;
}
.segmented button:not(:first-child) {
	border-left: 0;
	border-top-left-radius: 0;
	border-bottom-left-radius: 0;
}
#options {
	display: flex;
	flex-wrap: wrap;
	align-items: stretch;
	gap: 6px;
}
#options input {
	display: none;
}
#options label {
	display: flex;
	gap: 4px;
	align-items: center;
	padding: 2px 4px;
	border-radius: 4px;
	border: 2px solid #ccc;
	user-select: none;
	color: #666;
	background-color: #fff;
	white-space: pre;
}
#options :disabled + label {
	opacity: 0.5;
}
#options :not(:disabled) + label {
	cursor: pointer;
}
#options :not(:disabled) + label:hover {
	outline: 2px solid #000;
}
#options :checked + label {	
	color: #000;
}
#auto_resolve_check:checked + label {
	border-color: #5c5;
	background: linear-gradient(90deg, #fff, #cfc);
	font-style: italic;
}
#show_details_check:checked + label {
	border-color: #ca4;
	background-color: #edb;
	/* font: 85% monospace; */
	color: #432;
}
#show_components_check:checked + label {
	border-color: #0aa;
	background-color: #cff;
}
#show_records_check:checked + label {
	border-color: #aa0;
	background-color: #ffa;
}
#skip_norm_check:checked + label {
	border-color: #f00;
	background-color: #f00;
	color: #fff;
}
#force_ltr_check:checked + label {	
	border-color: #555;
	background-color: #555;
	color: #fff;
}
#chain_select:empty {
	display: none;
}
#chain_select {
	font-size: 100%;
}
#resolve_btn {
	font-weight: bold;
}
#output {
	display: flex;
	flex-direction: column;
	gap: 8px;
	font-size: 14pt;
}
.row button {
	font-size: 11pt;
}
.row-label {
	order: -10;
	text-align: right;
	font-weight: bold;
	white-space: pre;
}
.row-label a {	
	color: #000;
	text-decoration: none;
}
.row-label:after {
	content: ':';
}
.row-label a:hover {
	text-decoration: underline;
}
.row.locked .row-label {
	opacity: 65%;
}
.row.locked .row-label:before {
	content: 'üîíÔ∏è';
}
.row {
	padding: 8px;
	background: #fff;
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 8px;
}
.row.display {
	background: #eff;
}
.row.normalized {
	background: #efe;
	outline: 1px solid #cdc;
}
.row.addr {
	background: #fffff0;
}
.row.dns {
	background:#f5faff; 
}
.available {
	opacity: 65%;
}
.row.dns .main {
	border-bottom-style: dotted;
}
.row.dns.invalid {
	background: #fff0f0;	
	outline: 3px dashed #fcc;
}
.row.pretty {
	background: linear-gradient(90deg, #fff, #fff0fc);
}
.row.category {
	background: #ffe;
}
.row.category .row-label {
	color: #654;
}
.row.category + .row.category {
	margin-top: -6px;
}
.formula {
	display: flex;
	flex-wrap: wrap;
	gap: 4px;
}
.formula a {
	padding: 4px;
	cursor: pointer;
	color: #000;
	text-decoration: none;
}
.formula a:hover {
	background: #cff;
}
.formula a sup {
	font-family: monospace;
}
.row .main {
	display: inline;
	font-size: 16pt;
	border-bottom: 2px solid #000;
	line-height: 130%;
}
ul.row {
	margin: 0;
	margin-top: 4px;
	padding: 16px 16px 16px 36px;
	flex-direction: column;
	align-items: start;
	gap: 4px;
}
ul .tokens {
	display: inline-flex;
}
.row.readme {
	background: #ffc;
}
.row.readme code {
	background: #cff;
	padding: 1px;
}
a.internal {
	font-weight: bold;
}
.row.legend {
	background: #fff;
	list-style: disclosure-closed;
}
.row.legend .tokens {
	min-height: 32px;
}
.row.links {
	display: grid;	
	gap: 8px;
	grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
	background: #eff;
	order: 100;
}
a.addr {
	line-break: anywhere;
	font: 85% monospace;
}
span.key {
	padding: 2px 4px;
	border-radius: 4px;
	background-color: #999;
	color: #fff;
	font: 11px sans-serif;
}
span.tags {
	background: #ddd;
	color: #555;
	padding: 4px 8px;
	font-size: 12pt;
	border-radius: 4px;
	/* border: 1px solid #ccc; */
	white-space: pre;
}
button.copy {
	flex: 0 0 auto;
	align-self: center;
	padding: 0;
	border: none;
	width: 28px;
	height: 28px;
	border-radius: 4px;
	background-color: inherit;
	background-position: center;
	background-repeat: no-repeat;
	background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='24' shape-rendering='geometricPrecision' stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' viewBox='0 0 24 24' width='24' style='color:var(--geist-foreground)'%3E%3Cpath d='M6 17C4.89543 17 4 16.1046 4 15V5C4 3.89543 4.89543 3 6 3H13C13.7403 3 14.3866 3.4022 14.7324 4M11 21H18C19.1046 21 20 20.1046 20 19V9C20 7.89543 19.1046 7 18 7H11C9.89543 7 9 7.89543 9 9V19C9 20.1046 9.89543 21 11 21Z'/%3E%3C/svg%3E");
	background-size: 85%;	
}
button.copy.small {
	width: 20px;
	height: 20px;
	opacity: 35%;
}
button.copy:hover {
	opacity: 1;
	background-color: var(--copied-color);
}
button.copy.copied {
	opacity: 1;
	background-color: var(--copied-color);
	background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='24' shape-rendering='geometricPrecision' stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' viewBox='0 0 24 24' width='24' style='color:var(--geist-foreground)'%3E%3Cpath d='M20 6L9 17l-5-5'/%3E%3C/svg%3E");
}
.tags.long { order: 30; }
.tags.ensip1 {
	background-color: #df8;
	order: 8;
}
.tags.index {
	font: 9pt monospace;
	background-color: unset;
	opacity: 50%;
	user-select: none;
}
.tags.ens { order: 9; }
.ens button {
	border-color: #04f;
	background-color: #58f;
	color: #fff;
}
.tags.metadata { order: 10; }
.tags.external { order: 11; font-size: 80%; }
.tags.invalid { color: #f00; }
.tags.elapsed {
	background: #f0f0f0;
	font: 9pt sans-serif;
	order: 50;
}
.tags.confusing {
	color: #fff;
	background-color: var(--confusing-color);
	text-align: center;
}
.normalized .confusing {
	margin: -8px 0;
	font-size: 75%;
}
.tags.normalized { background: #8f8; }
.tags.normalized.ascii {
	background: #7ce;
	color: #fff;
	font: 11pt monospace;
}
.tags.length {
	background: #f8eedd;
}
.tags.length:after {
	content: 'ch';
	padding-left: 2px;
	font-size: 70%;
}
.tags.bytes {
	background-color: #eee;
}
.bytes:after {
	content: 'bytes';
	padding-left: 2px;
	font-size: 70%;
}
.tags.iface {
	display: flex;
	align-items: center;
	gap: 4px;
	text-decoration: none;
	background-color: #ddf;
	padding: 4px 8px;
	border-radius: 4px;
	white-space: pre;
	color: #000;
}
.tags.iface:hover {
	outline: 2px solid #00f;
}
.tags.iface code {
	font-size: 13px;
	color: #666;
}
.tags.iface code.prefix {
	color: #00f;
}
.tags.good {
	color: #060;
	background: #cfc;
}
.tags.fire {
	color: #000;
	background: #fdb;
}
.tags.note {
	background: #ffc;
}
.tags.reg {
	background-color: #def;
}
.tags.attn {
	background: #fff0dd;
}
.tags.fail {
	background: #fcc;
	color: #600;
}
.tags.type {
	background: #cff;
}
.tags.emoji {
	background-color: #fe0;
}
.tags.special {
	background: #f84;
	border: none;
	color: #fff;
}
.tags.clean {
	background: none;
	border: none;
	padding: 0;
	font-size: 110%;
	order: 7;
}
.tags.white {
	color: #000;
	background: #fff;
}
.jazz {
	order: -9;
	width: 1.2rem;
	height: 1.2rem;
	border-radius: 4px;
	display: flex;
	align-items: center;
	justify-content: center;
	color: #fff;
	font: bold 12px monospace;
}
.jazz.addr1 { background-color: #66f; }
.jazz.addr2 { background-color: #c4c; }
.jazz.addr3 { background-color: #0a8; }
.jazz.addr4 { background-color: #a80; }
.avatar {
	order: -1;
} 
.avatar img {
	position: relative;
	z-index: 1;
	display: block;
	border-radius: 4px;
	width: 32px;
	height: 32px;
	transition: transform 0.2s;
}
.avatar img:hover {
	transform: scale(3);
}
button.glow {
	border: 2px solid #2c2;
}
.breakdown {
	font-size: 12pt;
}
.breakdown .tags {
	padding: 2px 4px;
	border-radius: 4px;
	border: 1px solid #ddd;
}
.breakdown .hash {
	padding: 1px 8px;
	display: flex;
	gap: 4px;
	align-items: center;
	justify-content: center;
}
.breakdown .hash :first-child {
	white-space: pre;
}
.breakdown .hash code {
	font-size: 90%;
}
.breakdown .hash a {
	font-weight: bold;
	color: #000;
	text-decoration: none;
}
.breakdown .hash a:hover {
	text-decoration: underline;
}
.breakdown .hash.minor {
	font-size: 90%;
	color: #666;
}
.breakdown .hash.minor.first {
	border-top: 1px dotted #ccc;
}
.breakdown .label {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	justify-content: center;
	gap: 4px 6px;
	margin-top: 4px;
	border-top: 2px solid #fff;
	padding: 3px 6px;
}
.breakdown .label.valid {
	background: linear-gradient(90deg, #efea, #0000);
}
.breakdown .label.error {
	background: linear-gradient(90deg, #fcca, #0000);
}
.breakdown .label.mapped {
	background: linear-gradient(90deg, #ccf6, #0000);
}
.breakdown .name {
	margin: 0 4px;
	border: 1px solid #aaa;
	border-radius: 4px;
	padding: 1px 4px;
	font: 13pt monospace;	
  	color: #000;
}
.breakdown .restricted {
	text-decoration: none;
	background-color: #fcf;
	color: #000;
}
.breakdown .restricted:hover {
	outline: 2px solid #00f;
}
.breakdown .confusing {
	border: none;
}
.breakdown .error {
	order: 1;
}
.tokens {
	font-size: 16pt;
}
.tokens .emoji[data-components] {
	border-style: dashed;
}
.tokens [data-tld="eth"].valid {
	color: #fff;
	background: #58f;
	border-color: #04f;
}
.tokens [data-tld="art"].valid {
	color: #fff;
	background: #555;
	border-color: #111;
}
/* .tokens [data-tld="box"].valid {
	color: #fff;
	background: #666;
	border-color: #666;
} */
.maxh {
	max-height: 10rem;
	overflow-y: auto;
	padding-bottom: 1px;
}
.exploded > .error {
	background-color: #f97;
	padding: 3px;
	border-radius: 5px;
}
.exploded > .error.first {
	background: #f77;
}
.row.records {
	background-color: #ffc;
}
.record {
	display: flex;
	color: #000;
	font-size: 90%;
	text-decoration: none;
	align-items: center;
	background: #fff;
	padding: 4px 8px;
	border-radius: 4px;
	border: 1px solid #ccc;
	gap: 4px;
}
.record.notice {
	font-weight: bold;
}
.record button.copy {
	width: 24px;
	height: 24px;
}
.record.copied {
	background-color: var(--copied-color);
}
.record b {
	font: 11px sans-serif;
	color: #666;
	user-select: none;
	pointer-events: none;
}
.record:not([href]):hover {
	border: 2px solid #0a0;
	margin: -1px;
}
.record[href]:hover {
	border: 2px solid #00f;
	margin: -1px;
}
.record img,
.record svg {
	width: 18px;
	height: auto;
	user-select: none;
}
.record span.addr {
	font: 80% monospace;
}
.record .minor {
	pointer-events: none;
	font: 12px sans-serif;
}
.record .changed {
	font: 11px sans-serif;
	background-color: #fdb;
	order: 10;
}
.row.error {
	background: #fcc;
	outline: 3px dashed #d00;
	border-radius: 0;
}
.row.contract:not(.error) {
	background-color: #fffcf6;
	outline: 2px dashed #cc0;
}
.row.contract {
	position: relative;
}
.row.contract::before {
	position: absolute;
	top: 3px;
	right: 6px;
	content: 'Contract';
	font: 11px monospace;
	color: #999;
}
.transform {
	background: #fffaf0;
}
#recent_select {
	outline: none;
	width: 37px;
	padding: 0;
	margin: 0;
	border: 1px solid var(--btn-border-color);
	border-radius: 4px;
	font-size: 100%;
	appearance: none;
	background: no-repeat center url("data:image/svg+xml,%3Csvg height='21' width='20' version='1.1' viewBox='0 0 20 21' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10.5,0 C7,0 3.9,1.9 2.3,4.8 L0,2.5 L0,9 L6.5,9 L3.7,6.2 C5,3.7 7.5,2 10.5,2 C14.6,2 18,5.4 18,9.5 C18,13.6 14.6,17 10.5,17 C7.2,17 4.5,14.9 3.4,12 L1.3,12 C2.4,16 6.1,19 10.5,19 C15.8,19 20,14.7 20,9.5 C20,4.3 15.7,0 10.5,0 L10.5,0 Z M9,5 L9,10.1 L13.7,12.9 L14.5,11.6 L10.5,9.2 L10.5,5 L9,5 L9,5 Z'/%3E%3C/svg%3E"), no-repeat bottom 3px right 2px url("data:image/svg+xml,%3Csvg style='fill: currentColor' width='8' height='4' viewBox='0 0 8 4' version='1.1' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h8l-4 4Z' /%3E%3C/svg%3E") var(--btn-fill-color);
}
#recent_select:hover,
#recent_select:active {
	background-color: var(--btn-hover-fill-color);
}
footer {
	margin: 16px 0;
	display: flex;
	gap: 10px;
	align-items: baseline;
	justify-content: center;
	color: #666;
}
#clock {
	font: 9pt sans-serif;
	background-color: #e0e0e0;
	border-radius: 4px;
	padding: 3px 6px;
}
#clock:empty {
	display: none;
}
#version {
	font-family: monospace;
	cursor: help;
}
#version:hover {	
	color: #000;
	text-decoration: underline;
}
#enable_debug_btn {
	border-radius: 4px;
	user-select: none;
	padding: 3px;
	cursor: pointer;
}
#enable_debug_btn:hover {
	background-color: #fff;
}
#debug_header {
	display: flex;
	align-items: center;
	justify-content: center;
	gap: 8px;
	margin: 8px 0;
}
#debug textarea {
	box-sizing: border-box;
	width: 100%;
	resize: vertical;
	font-family: monospace;
}
@media only screen and (max-width: 800px) { 
	body {
		margin: 0;
	}
	button {
		font-size: 100%;
	}
	header {
		margin: 16px;
		margin-bottom: 0;
	}
	#provider {
		order: 3;
		flex-direction: row;
		align-items: center;
		gap: 4px;
		width: 100%;
	}
	#input input {
		font-size: 20pt;
	}
	#input, #actions, #options, #examples {
		margin: 0 16px;
	}
	#content {
		font-size: 12pt;
	}
	a.wide {
		font-size: 95%;
	}
	.row {
		justify-content: center;
	}
	#examples_btn {
		display: block;
		width: 100%;
		margin-bottom: 4px;
		font-size: 14pt;
		padding: 4px;
	}
	#output {
		font-size: 13pt;
	}
	#debug_header {
		margin: 8px;
	}
}
@media only screen and (max-width: 400px) { 
	h1 a {
		display: none;
	}
}
</style>
</head>
<body>
<header>
	<h1><a href="https://ens.domains/">ENS</a> Resolver</h1>
	<div id="provider"></div>
	<div id="github">
		<a href="https://github.com/adraffy/ens-normalize.js">adraffy/ens-normalize.js</a>
		<a href="https://docs.ens.domains/ens-improvement-proposals/ensip-15-normalization-standard"><b>ENSIP-15</b></a>
	</div>
</header>
<div id="examples" class="hide">
<button>vitalik.eth</button>
<button>nIcK.eTh</button>
<button>brantly.cash</button>
<button>üè¥‚Äç‚ò†.art</button>
<button>..a..eth</button>
<button>√∂bb</button>
<button>√ñbb</button>
<button data-name="‚óåÃàbb">‚óåÃàbb</button>

<a href="https://adraffy.github.io/punycode.js/test/demo.html"><b>Punycode:</b></a>
<button>xn--ls8h</button>
<button>xn--üí©</button>
<button>üí∑pound</button>

<a href="https://github.com/ensdomains/ens-contracts/tree/master/contracts/wrapper#namewrapper-docs"><b>Wrapper:</b></a>
<button data-name="firstwrappedname">Emanicpated 2LD</button>
<button data-name="please.pumpdeezbags.eth">Emanicpated 3LD</button>
<button data-name="dessert3.menu.bestsushi7.eth">Wrapped</button>
<button data-name="david">Locked</button>

<b>Subdomain:</b>
<button data-name="nowzad.loopring.eth">loopring</button>
<button data-name="239.chonksociety.eth">Chonk #239</button>
<button>raffy.antistupid.com</button>

<a href="https://docs.ens.domains/ens-improvement-proposals/ensip-10-wildcard-resolution"><b>Wildcard:</b></a>
<button>moo331.nft-owner.eth</button>
<button>üíé.gmcafe.eth</button>
<button>1.offchainexample.eth</button>
<button>barmstrong.cb.id</button>

<!--
<a href="./display.html"><b>Display:</b></a>
<button>ADRaffy</button>
-->

<b>Address:</b>
<button data-name="0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045">d8dA..6045</button>

<b>Contract:</b>
<button data-name="eth-usd.data.eth">Chainlink ETH-USD</button>

<b>Preimage:</b>
<button data-delay="1000" data-name="token:91842011529764390124322931916134555051359118325819011691525342013207339157209">Token#</button>
<button data-delay="1000" data-name="https://opensea.io/assets/ethereum/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209">OpenSea</button>
<button data-delay="1000" data-name="https://www.gem.xyz/asset/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209">Gem</button>

<a href="./chars.html"><b>Mapped:</b></a>
<button data-name="hyph{2D}{2010}{2011}{2012}{2013}{2014}{2015}{2043}{2212}{23AF}{23E4}{FE58}e{2E3A}n{2E3B}s">Hyphens</button>
<button>A.‚Ñ¢Ô∏è.–Æ</button>
<button>‚Öß</button>
<button>‚®å</button>

<b>Ignored:</b> 
<button data-name="{FE0E}{FE0F}">Emoji Style</button>

<b>Disallowed:</b>
<button data-name="{26}{3000}{E0061}{FFFFFF}{200D}">Types</button>
<button data-name="test .te st. test">Whitespace</button>
<button data-name="{3002}.{FF0E}.{FF61}">Alt Stops</button>
<button data-name="y{303}.{1EF9}">Invalid NFC</button>
<button data-name="{DF00}">Surrogate</button>
<button data-name="[ba967c160905ade030f84952644a963994eeaed3881a6b8a4e9c8cbe452ad7a2].eth" data-skip="1">"üí©.eth"</button>

<b>Deviation:</b> 
<button>√ü</button>
<button>·∫û</button>
<button>œÇ</button>

<b>Complex:</b>
<button data-name="_1{FE0F}E{FE0E}{303}{AD}{1F4A9}{24C2}{FE0E}{2E3B}a{301}"></button>

<b>Combining Marks:</b>
<button data-name="{300}">Leading</button>
<button data-name="üí©{300}">Emoji</button>
<button data-name="x{300}{300}">Whitelisted</button>
<button data-name="{622}{64D}{64E}.{929}{901}{902}">NFD w/CM</button>

<b>NSM:</b>
<button data-name="{625}{610}{610}">Repeated</button>
<button data-name="{625}{610}{611}{612}{613}{614}">Too Many</button>

<a href="https://unicode.org/reports/tr46/#Validity_Criteria"><b>CheckHyphen:</b></a>
<button>-test.test-.t-e--s---t</button>
<button>te--st</button>

<b>Underscore:</b>
<button>__ab</button>
<button>a_b</button>

<a href="./emoji.html"><b>Emoji:</b></a>
<button>¬©</button>
<button>üïµ</button>
<button>üßô‚Äç‚ôÇ</button>
<button>üèãüèø‚Äç‚ôÇ</button>
<button data-name="üí©üí©üí©">üí©<sup>3</sup></button>
<button data-name="üçûüçûüçûüçûüçûüçûüçûüçûüçûüçûüçûüçûüçû">üçû<sup>13</sup></button>
<button data-name="üëÅüó®üëÅÔ∏è‚Äçüó®Ô∏è">üëÅÔ∏è‚Äçüó®Ô∏è</button>
<button data-name="üßüüßü‚ôÇüßü‚Äç‚ôÇ">üßü</button>
<button>üòµ‚Äçüí´üòµ‚Äçüí´üòµ‚Äçüí´</button>
<button>üòµüí´üòµüí´üòµüí´</button>
<button>üë©‚Äç‚öïüë©üèΩ‚Äç‚öïÔ∏è</button>
<button>üë™üë®‚Äçüë©‚Äçüë¶</button>
<button data-name="üö¥Ô∏èüöµÔ∏èüö¥üèªüö¥üèºüö¥üèΩüö¥üèæüö¥üèøüöµüèªüöµüèºüöµüèΩüöµüèæüöµüèøüö¥‚Äç‚ôÄÔ∏èüö¥‚Äç‚ôÇÔ∏èüöµ‚Äç‚ôÄÔ∏èüöµ‚Äç‚ôÇÔ∏èüö¥üèª‚Äç‚ôÄÔ∏èüö¥üèª‚Äç‚ôÇÔ∏èüö¥üèº‚Äç‚ôÄÔ∏èüö¥üèº‚Äç‚ôÇÔ∏èüö¥üèΩ‚Äç‚ôÄÔ∏èüö¥üèΩ‚Äç‚ôÇÔ∏èüö¥üèæ‚Äç‚ôÄÔ∏èüö¥üèæ‚Äç‚ôÇÔ∏èüö¥üèø‚Äç‚ôÄÔ∏èüö¥üèø‚Äç‚ôÇÔ∏èüöµüèª‚Äç‚ôÄÔ∏èüöµüèª‚Äç‚ôÇÔ∏èüöµüèº‚Äç‚ôÄÔ∏èüöµüèº‚Äç‚ôÇÔ∏èüöµüèΩ‚Äç‚ôÄÔ∏èüöµüèΩ‚Äç‚ôÇÔ∏èüöµüèæ‚Äç‚ôÄÔ∏èüöµüèæ‚Äç‚ôÇÔ∏èüöµüèø‚Äç‚ôÄÔ∏èüöµüèø‚Äç‚ôÇÔ∏è">üö¥Ô∏è Bikes (36)</button>
<button data-name="ü¶∞ü¶±ü¶≤ü¶≥">ü¶∞</button>
<button>üë®‚Äçüë©‚Äçüë¶üèø</button>
<button data-name="{1F3FB}{1F3FC}{1F3FD}{1F3FE}{1F3FF}">üèª</button>
<button data-name="üí©{200D}üí©">üí©+üí©</button>
<button data-name="{261D}{FE0F}{1F3FB}"></button>
<button>‚ÄºÔ∏è</button>
<button>‚ÅâÔ∏è</button>
<button data-name="‚Ñ¢‚Ñπ‚ìÇ„äó„äôüàÅüàÇüàöüàØüà≤üà≥üà¥üàµüà∂üà∑üà∏üàπüà∫üâêüâë">‚òπÔ∏è Demoted</button>

<b>Non-RGI:</b>
<button>üê±‚Äçüêâ</button>
<button>üë™üèª</button>
<button>ü§ºüèª‚Äç‚ôÄÔ∏è</button>
<button data-name="{1F469}{1F3FE}{200D}{1F91D}{200D}{1F469}{1F3FE}">Mod+Mod</button>

<b>Regional:</b>
<button>üá¶</button>
<button>üá¶üá¶</button>
<button>üá∫üá∏üá∫üá≤</button>

<b>Flag:</b>
<button>üè¥</button>
<button>üèÅÔ∏è</button>
<button>üè≥Ô∏è‚Äçüåà</button>

<a href="https://www.unicode.org/reports/tr51/#DisplayValidEmojiTagSeqs"><b>Tag:</b></a>
<button>{1F3F4}{E0067}{E0062}{E0065}{E006E}{E0067}{E007F}</button>
<button>{1F3F4}{E0067}{E0062}{E0073}{E0063}{E0074}{E007F}</button>
<button>{1F3F4}{E0067}{E0062}{E0077}{E006C}{E0073}{E007F}</button>
<button data-name="{1F3F4}{E0075}{E0073}{E0063}{E0061}{E007F}">usca</button>

<b>Circled/Squared:</b>
<button>i{2139}{2139}{FE0F}üõà</button>
<button data-name="‚í∂‚í∑‚í∏‚íπ‚í∫‚íª‚íº‚íΩ‚íæ‚íø‚ìÄ‚ìÅ‚ìÇ‚ìÉ‚ìÑ‚ìÖ‚ìÜ‚ìá‚ìà‚ìâ‚ìä‚ìã‚ìå‚ìç‚ìé‚ìè">‚í∂-‚ìè</button>
<button data-name="‚ìê‚ìë‚ìí‚ìì‚ìî‚ìï‚ìñ‚ìó‚ìò‚ìô‚ìö‚ìõ‚ìú‚ìù‚ìû‚ìü‚ì†‚ì°‚ì¢‚ì£‚ì§‚ì•‚ì¶‚ìß‚ì®‚ì©">‚ìê-‚ì©</button>
<button data-name="‚ì™‚ë†‚ë°‚ë¢‚ë£‚ë§‚ë•‚ë¶‚ëß‚ë®‚ë©‚ë™‚ë´‚ë¨‚ë≠‚ëÆ‚ëØ‚ë∞‚ë±‚ë≤‚ë≥„âë„âí„âì„âî„âï„âñ„âó„âò„âô„âö„âõ„âú„âù„âû„âü">‚ì™-„âü</button>
<button data-name="üÖ∞üÖ±üÖ≤üÖ≥üÖ¥üÖµüÖ∂üÖ∑üÖ∏üÖπüÖ∫üÖªüÖºüÖΩüÖæüÖøüÜÄüÜÅüÜÇüÜÉüÜÑüÜÖüÜÜüÜáüÜàüÜâ">üÖ∞-üÜâ</button>
<button data-name="üÖêüÖëüÖíüÖìüÖîüÖïüÖñüÖóüÖòüÖôüÖöüÖõüÖúüÖùüÖûüÖüüÖ†üÖ°üÖ¢üÖ£üÖ§üÖ•üÖ¶üÖßüÖ®üÖ©">üÖê-üÖ©</button>
<button data-name="‚ìø‚ù∂‚ù∑‚ù∏‚ùπ‚ù∫‚ùª‚ùº‚ùΩ‚ùæ‚ùø‚ì´‚ì¨‚ì≠‚ìÆ‚ìØ‚ì∞‚ì±‚ì≤‚ì≥‚ì¥">‚ìø-‚ùø</button>
<button data-name="üÑå‚ûä‚ûã‚ûå‚ûç‚ûé‚ûè‚ûê‚ûë‚ûí‚ûì">üÑå-‚ûì</button>
<button data-name="„âà„ââ„âä„âã„âå„âç„âé„âè">„âà-„âè</button>

<a href="https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.1"><b>ContextJ:</b></a>
ZWNJ:
<button data-name="‡¥®‡µç{200C}‡¥Æ"></button>
<button data-name="ŸÜ€åŸÖ‚ÄåŸÅÿßÿµŸÑŸá"></button>
<button data-name="a{200C}b"></button>

ZWJ:
<button data-name="‡¥£‡µç‚Äç"></button>
<button data-name="a{200D}b"></button>

<a href="https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.3"><b>ContextO:</b></a>
Middle Dot: 
<button data-name="{6C}{B7}{6C}"></button>

Katakana Dot:
<button data-name="Êúà„ÉªÊ∞¥"></button>
<button data-name="a„Éªa{300}"></button>

Greek Keraia: 
<button data-name="{375}Œ±"></button>

Hebrew Geresh:
<button data-name="{5D1}{5F3}"></button>

<a href="https://www.rfc-editor.org/rfc/rfc5893.html#section-2"><b>CheckBidi:</b></a>
<button>◊§◊¢◊ô◊ú◊ï◊™◊î◊ë◊ô◊†◊ê◊ï◊ù</button>
<button data-name="{0786}{07AE}{0782}{07B0}{0795}{07A9}{0793}{07A6}{0783}{07AA}">Dhivehi</button>
<button data-name="{05D9}{05B4}{05D5}{05D0}{05B8}">Yiddish</button>
<button data-name="{1F1F8}{1F1E6}{633}{644}{645}{627}{646}">Emoji+RTL</button>
<button data-name="{633}{644}{645}{627}{646}{1F1F8}{1F1E6}">RTL+Emoji</button>
<button data-name="bahrain.ŸÖÿµÿ±">LTR.RTL</button>
<button data-name="bahrainŸÖÿµÿ±">LTR+RTL in Label</button>
<button data-name="{202e}elgoog{202d}.eth">.ethgoogle</button>
<button data-name="{202e}hte.elgoog">google.eth</button>

<b>Keycaps:</b>
<button>1‚É£2Ô∏è‚É£üîü.eth</button>
<button data-name="0Ô∏è‚É£1Ô∏è‚É£2Ô∏è‚É£3Ô∏è‚É£4Ô∏è‚É£5Ô∏è‚É£6Ô∏è‚É£7Ô∏è‚É£8Ô∏è‚É£9Ô∏è‚É£üîü*Ô∏è‚É£#Ô∏è‚É£">*Ô∏è‚É£-üîü</button>

<a href="https://unicode-org.github.io/cldr-staging/charts/latest/by_type/core_data.alphabetic_information.main.html">Exemplars</a> /
<a href="https://util.unicode.org/UnicodeJsps/confusables.jsp"><b>Confusables:</b></a>
<button>aŒ±.…ë</button>
<button>‡Æ∂‡Øç‡Æ∞‡ØÄ.‡Æ∏‡Øç‡Æ∞‡ØÄ</button>
<button data-name="i.i{307}.{131}{307}">iÃá</button>
<button data-name="{E8}.e{300}.{450}.{435}{300}">√®</button>

<b>Mixed-Script:</b>
<button data-name="0a„Äá.Èªëa8">Digit+Latin+Han</button>
<button data-name="„ÅÇ„Ç¢„ÅÑ„Ç§„ÅÜ„Ç¶„Åà„Ç®„Åä„Ç™">Kana+Hira</button>
<button data-name="bitcoin.bitcŒøin.biÃátcoin.bit—Åoin">"bitcoin"</button>
<button>„Ç°Ìû£</button>

<b>Whole-Script:</b>
<button data-name="0x.0œá.0—Ö">"0x"</button>
<button data-name="apple.–¥—Ä—Ä”è–µ.–∞—Ä—Ä”è–µ.a—Ä—Ä”è–µ">"apple"</button>
<button data-name="ŒπŒøœÉœÅŒ≤œÖŒΩŒ≥">Greek</button>
<button data-name="o.Ÿ•.‡•¶.‡±¶.‡©¶.‡µ¶.Œø.÷Ö">"o"</button>
<button data-name="„ÅÇ„Éº.„Äá‰∏Ä.‰∏Ä„Éº.‰∏Ä.„Éº.·Ö≥">CJK Dash</button>

<a href="https://unicode.org/emoji/charts/emoji-released.html"><b>Unicode 15.0:</b></a>
<button data-name="{1F6DC}{1FA75}{1FA76}{1FA77}{1FA87}{1FA88}{1FAAD}{1FAAE}{1FAAF}{1FABB}{1FABC}{1FABD}{1FABF}{1FACE}{1FACF}{1FADA}{1FADB}{1FAE8}{1FAF7}{1FAF8}">Single Emoji (20)</button>
<button data-name="{1FAF7}{1F3FB}{1FAF7}{1F3FC}{1FAF7}{1F3FD}{1FAF7}{1F3FE}{1FAF7}{1F3FF}{1FAF8}{1F3FB}{1FAF8}{1F3FC}{1FAF8}{1F3FD}{1FAF8}{1F3FE}{1FAF8}{1F3FF}">Sequences (10)</button>
<button data-name="{1F426}{200D}{2B1B}">Black Bird</button>

<a href="https://unicode.org/reports/tr51/proposed.html"><b>Unicode 15.1:</b></a>
<button>‚â†.‚âÆ.‚âØ</button>
<button data-name="{26D3}{200D}{1F4A5}.{1F344}{200D}{1F7EB}.{1F34B}{200D}{1F7E9}.{1F426}{200D}{1F525}.{1F642}{200D}{2194}.{1F642}{200D}{2195}.{1F9D1}{200D}{1F9D2}.{1F9D1}{200D}{1F9D1}{200D}{1F9D2}.{1F9D1}{200D}{1F9D2}{200D}{1F9D2}.{1F9D1}{200D}{1F9D1}{200D}{1F9D2}{200D}{1F9D2}">ZWJ Sequences (10)</button>
<button data-name="{1F3C3}{1F3FB}{200D}{27A1}.{1F3C3}{1F3FB}{200D}{27A1}.{1F3C3}{1F3FC}{200D}{27A1}.{1F3C3}{1F3FD}{200D}{27A1}.{1F3C3}{1F3FE}{200D}{27A1}.{1F3C3}{1F3FF}{200D}{27A1}">Directional (108)</button>

<b>Fenced:</b>
<button>O'Brian</button>
<button data-name="¬º¬Ω¬æ‚Öê‚Öë‚Öí‚Öì‚Öî‚Öï‚Öñ‚Öó‚Öò‚Öô‚Öö‚Öõ‚Öú‚Öù‚Öû‚Öü‚Üâ">"¬Ω"</button>
<button>123‚ÅÑ456‚Äôs</button>
<button data-name="a'.‚Äôz.a'‚Äôb.a‚ÅÑ'.‚ÅÑa">Invalid</button>

<b>Misc:</b>
<button data-name="$¬¢¬£¬§¬•‚Ç°‚Ç¶‚Ç©‚Ç™‚Ç´‚Ç¨‚Ç≠‚ÇÆ‚Ç±‚Ç≤‚Ç¥‚Çµ‚Ç∏‚Çπ‚Ç∫‚Çº‚ÇΩ‚Çæ‚ÉÄ‚ÇøŒû.ÿã">Currency</button>
<button data-name="‚Ä¢-‚Ä¢¬¨.‚åê‚ó®-‚ó®.‚åê„Äá-„Äá¬¨">Glasses</button>
<button>360¬∞</button>
<button data-name="2œÄr.4œÄŒ∏.8–ø">"œÄ"</button>
<button>Œû.‚â°.‚ò∞</button>
<button>‚ô¢‚ü†‚ß´</button>
<button data-name="_‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà">‚ñÉ‚ñÖ‚ñá</button>
<button data-name="‚úì.‚úîÔ∏é.‚úîÔ∏è.‚úÖÔ∏è.‚òëÔ∏è">Checks</button>
<button data-name="·¥Ä ô·¥Ñ·¥Ö·¥áÍú∞…¢ ú…™·¥ä·¥ã ü·¥ç…¥·¥è·¥òÍûØ ÄÍú±·¥õ·¥ú·¥†·¥°x è·¥¢">Íú±·¥ç·¥Ä ü ü ·¥Ñ·¥Ä·¥òÍú±</button>
<button data-name="z éx ç ån ás…πbdou…ØÍûÅ û≈øÃ£·¥â…•·µ∑…ü«ùp‚ÜÑq…ê">p«ùu…πn á</button>
<button data-name="üí©ƒÖ√ßƒô≈ü√¨√≠√Æ√Ø«ê≈Ç">Rare Latin</button>

<b>Pure:</b>
Arabic:
<button>ÿ•ŸÜÿ™ÿ±ŸÜÿ™</button>
<button data-name="{660}{661}{662}{663}{664}{665}{666}{667}{668}{669}.{6F0}{6F1}{6F2}{6F3}{6F4}{6F5}{6F6}{6F7}{6F8}{6F9}.{6F0}{780}">Digits</button>
Hebrew:
<button>◊©◊ô◊®◊ï◊™÷æ◊©◊û◊ï◊™</button>

<a href="https://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers"><b>Restricted:</b></a>
<button data-name="ìÄÄìÄÅìÄÇ">Egyptian Hieroglyphs</button>
<button data-name="êå±êåªêçâêåºêå∞">Gothic</button>
<button>ìÜè‚û°üê∏Ô∏è</button>
<button data-name="aìÄÇ">Mixed</button>
<button>·èé·èÆ·èÇ·é•.eth</button>

<a href="https://adraffy.github.io/ens-norm-tests/test-compare/output/ens_normalize.git_1.9.0_vs_eth-ens-namehash_2.0.15.html#diff-norm"><b>Different Norm:</b></a>
<button data-name="‚Äë888">Remapped Hyphen</button>
<button data-name="€∞€±€≤€≥€∑€∏€π">Mapped Arabic</button>

</div>
<div id="options">
	<button id="examples_btn">üëÄ Examples</button>
	<input type="checkbox" id="auto_resolve_check" checked>
	<label for="auto_resolve_check"><svg width="20" fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24"><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/></svg>on Input</label>
	<input type="checkbox" id="show_details_check">
	<label for="show_details_check">Details</label>
	<input type="checkbox" id="show_components_check" checked>
	<label class="hide" for="show_components_check" title="Reveal internal emoji codepoints">Emoji üß¨Ô∏è</label>
	<input type="checkbox" id="show_records_check" checked>
	<label for="show_records_check" title="Include common text and address records">Records</label>
	<input type="checkbox" id="skip_norm_check">
	<label for="skip_norm_check"  title="When active, normalization is not applied"><svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="var(--geist-fill)"></circle><path d="M15 9L9 15" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path><path d="M9 9L15 15" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path></svg>Norm</label>
	<input type="checkbox" id="force_ltr_check">
	<label for="force_ltr_check" title="Override Bidi Handling with Left-to-Right Direction&#10;(Applies only to Input)">LTR!</label>
	<select id="chain_select"></select>
	<button id="mainnet_btn" class="hide">‚Ü™ Mainnet</button>
	<button id="browser_btn" class="hide">Browser ‚Ü©</button>
</div>
<div id="input">
	<input id="input_field" size="20" placeholder="Name or Address">
	<button id="parent_btn" class="hide" title="Resolve parent domain&#10;[ESC] Clear input"><svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 16 24" width="16"><path d="M8 22V2"/><path d="M1 9l7-7 7 7"/></svg></button>
	<select id="recent_select" title="Recent Names" class="hide">
		<option value="reset">üóëÔ∏è Clear History</option>
		<optgroup label="Recent Names"></optgroup>
	</select>
</div>
<div id="actions">
	<div class="spinner"></div>
	<div class="balloon"></div>
	<div class="segmented">
		<button id="random_emoji_btn" title="Random Emoji&#10;[ALT] Only Use Singles">üé≤</button>
		<button id="find_emoji_btn" title="Lookup Selected/First Emoji">Emoji</button>
	</div>
	<div class="segmented">
		<button id="chars_btn" title="Lookup Selected/First Character">Chars</button>
		<button id="confused_btn" title="Explain Confusable Characters">Confused</button>
	</div>
	<div class="segmented">
		<button id="nf_btn">NFD‚ÜîNFC</button>
		<button id="escape_btn" title="[ALT] Unicode Escaped">Escape</button>
	</div>
	<button id="copy_link_btn">Copy Link</button>
	<button id="resolve_btn">Resolve</button>
</div>
<div id="output">
<ul class="row readme">
<li>Click an <button data-name="üëÅÔ∏è‚Äçüó®Ô∏èA{303}.Eth">Example</button> to see how it works.</li>
<li><code>token:__</code> lookup the <a href="../../keccak.js/test/demo.html#algo=keccak-256&s=raffy&escape=1&encoding=utf8">labelhash</a> (if known) <button data-name="token:91842011529764390124322931916134555051359118325819011691525342013207339157209" data-delay="1000">raffy.eth</button> or <a href="../../ens-labels/demo.html">search for it</a>.</li>
<li><code>wrapped:__</code> lookup the <a href="../../keccak.js/test/demo.html#algo=namehash&s=firstwrappedname.eth&escape=1&encoding=utf8">namehash</a> (if wrapped) <button data-name="wrapped:0xc44eec7fb870ae46d4ef4392d33fbbbdc164e7817a86289a1fe30e5f4d98ae85" data-delay="1000">firstwrappedname.eth</button></li>
<li>Use <code>{FF}</code> or <code>[255]</code> to include codepoints <button data-raw data-name="a{61}[97].eth">aaa</button></li>
<li><code>\uFFFF</code>, <code>\u{HEX}</code>, <code>&amp;#xFF;</code>, <code>&amp;#255;</code>, or <code>&amp;entity;</code> are shorthand for <code>{HEX}</code>.</li>
<li><code>HEX<sub>1</sub> HEX<sub>2</sub></code> is shorthand for <code>{HEX<sub>1</sub>}{HEX<sub>2</sub>}</code> <button data-name="65 74 68" data-meta data-delay="1000">eth</button></li>
<li><code>range:HEX<sub>1</sub>..HEX<sub>n</sub></code> expands to a range of characters <button data-name="range:61..7A" data-delay="1000">ASCII a-z</button></li>
<li><button id="copy_example_btn">Copy Link</button></a> to get a URL that resolves on page-load.</li>
<li>Many elements have tooltips with additional information.</li>
<li>Follows <a class="internal" href="https://docs.ens.domains/ens-improvement-proposals/ensip-15-normalization-standard">ENSIP-15</a> and <a href="https://docs.ens.domains/terminology">ENS Terminology</a>.</li>
<li>Clear input to return to this page.</li>
</ul>
<ul class="row legend">
<li>This is a <b>valid</b> sequence of characters: <span data-tokenize="abc"></span> and domain name: <span data-tokenize="abc.eth"></span></li>
<li>This is an <b>emoji</b>: <span data-tokenize="üë©üèΩ‚Äç‚öïÔ∏è"></span> and its corresponding <b>components</b>: <span data-tokenize="üë©üèΩ‚Äç‚öïÔ∏è" data-parts="1"></span></li>
<li>This is a <b>mapped</b> token: <span data-tokenize="‚Ñ¢"></span> which transforms into a <b>valid</b> sequence: <span data-tokenize="tm"></span></li>
<li>Characters not in canonical form require <b>NFC</b>: <span data-tokenize="a{303}"></span></li>
<li>These are <b>ignored</b> characters: <span data-tokenize="{AD}{FE0F}{E0100}"></span></li>
<li>These are <b>disallowed</b> characters: <span data-tokenize="#{00}{1FFFFF}{E0061}{200D}"></span></li>
</ul>
<ul class="row links">
<li><a class="internal" href="./emoji.html">Supported Emoji</a></li>
<li><a class="internal" href="./chars.html">Characters Viewer</a></li>
<li><a class="internal" href="./confused.html">Confused Explainer</a></li>
<li><a class="internal" href="./validate.html">Validation Test</a></li>
<li><a class="internal" href="./report-nf.html">Unicode NormalizationTest</a></li>
<li><a href="../../ens-norm-tests/test-breakdown/output-20230226/">ENSIP-1‚Üí15 Breakdown</a></li>
<li><a href="https://github.com/ensdomains/ens-contracts/tree/staging/deployments/">ENS Deployments</a></li>
<li><a href="../../ens-labels/demo.html">Labelhash‚Åª¬π</a></li>
<li><a href="https://github.com/adraffy/ens-labels/">Label Database</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-regs.html">Recent Registrations</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-renews.html">Recent Renews</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-exp.html">Expirations</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-emoji-freq.html">Emoji Frequency Browser</a></li>
<li><a href="../../emoji.js/test/demo.html">Emoji Parser</a></li>
<li><a href="../../keccak.js/test/demo.html">Keccak Hasher</a></li>
<li><a href="../../punycode.js/test/demo.html">Punycode Coder</a></li>
<li><a href="../../cid.js/test/demo.html">CID Tool</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-batch-resolver.html">Batch Resolver</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-nft-matcher.html">ENS+NFT Matcher</a></li>
<li><a href="https://raffy.antistupid.com/eth/emoji-pixels.html">Emoji Pixel Maker</a></li>
</ul>
</div>
<div id="debug" class="hide">
<div id="debug_header">
	<b>üõ†Ô∏è Debug Settings:</b>
	<span class="balloon"></span>
	<button id="apply_debug_btn">üîÑÔ∏è <span class="key">shift+enter</span></button>
	<button id="disable_debug_btn">üõëÔ∏è</button>
</div>
<textarea rows="20"></textarea>
</div>
<footer>
	<span>Created by <a href="https://x.com/adraffy">raffy.eth</a></span>
	<span id="clock"></span>
	<span id="version"></span>
	<span id="enable_debug_btn" title="Enable Debugging">üõ†Ô∏è</span>
</footer>
<script type="module">
import {ethers} from 'https://cdnjs.cloudflare.com/ajax/libs/ethers/6.10.0/ethers.min.js';
import {
	ens_normalize, ens_split, ens_beautify, ens_tokenize, ens_emoji,
	nfc, nfd, hex_cp, quote_cp, explode_cp, str_from_cps, safe_str_from_cps,
	versions, compare_arrays, is_combining_mark, should_escape,
	dom_from_tokens, use_default_style,
} from '../dist/all.min.js';
import {puny_encoded, is_surrogate} from '../../punycode.js/dist/index.min.js'; 
import {CID, uvarint, convert, Bech32, Base32, Base58BTC, Base64URL} from '../../cid.js/dist/index.min.js';
import eth_ens_namehash from './eth-ens-namehash@2.0.15.min.js';
use_default_style();

const $ = x => document.querySelector(x);
const EMOJI = ens_emoji();

const input_field = $('#input_field');
const resolve_btn = $('#resolve_btn');
const auto_resolve_check = $('#auto_resolve_check');
const show_components_check = $('#show_components_check');
const show_components_label = $('label[for="show_components_check"]');
const show_records_check = $('#show_records_check');
const skip_norm_check = $('#skip_norm_check');
const show_details_check = $('#show_details_check');
const force_ltr_check = $('#force_ltr_check');
const chain_select = $('#chain_select');
const mainnet_btn = $('#mainnet_btn');
const browser_btn = $('#browser_btn');
const recent_select = $('#recent_select');
const recent_optgroup = $('#recent_select optgroup');
const options_div = $('#options');
const actions_div = $('#actions');
const primary_loader = $('#actions .spinner');
const output_div = $('#output');
const examples_div = $('#examples');
const examples_btn = $('#examples_btn');
const provider_div = $('#provider');
const nf_btn = $('#nf_btn');
const escape_btn = $('#escape_btn');
const parent_btn = $('#parent_btn');
const version_span = $('#version');
const clock_span = $('#clock');
const enable_debug_btn = $('#enable_debug_btn');
const debug_div = $('#debug');
const debug_ta = $('#debug textarea');

const readme_dom = [...output_div.childNodes]; // save initial ux
const entity_span = document.createElement('span');

const DEBUG_INDENT = '    ';

const RESOLVE_MODE_IDLE = 'idle';
const RESOLVE_MODE_EMPTY = 'empty';
const STORAGE_RECENT = 'ens-norm.recent';
const STORAGE_SETTINGS = 'ens-norm.settings';

const INPUT_NAME = 'Input';
const OPENSEA_NAME = 'OpenSea';
const VISION_NAME = 'Vision';
const VISION_HOST = 'vision.io';
const PRETTY_NAME = 'üíñÔ∏è';
const MANAGER_NAME = 'Manager';
const NFT_OWNER_NAME = 'NFT Owner';
const CLICK_TO_COPY = '(Click to Copy)';
const SAME_AS_INPUT = 'Same as Input';
const SAME_AS_NORM = 'Same as Norm';

const CHAIN_ID_MAINNET = 1;
const CHAIN_ID_GOERLI = 5;
const CHAIN_ID_SEPOLIA = 11155111;
const CHAIN_ID_HOLESKY = 17000;
const CHAINS = [
	{
		// https://github.com/ethereum-lists/chains/blob/master/_data/chains/eip155-1.json
		id: CHAIN_ID_MAINNET,
		name: 'Mainnet',
		explorer: 'https://etherscan.io',
		metadata: 'https://metadata.ens.domains/mainnet',
		opensea: 'https://opensea.io/assets/ethereum/',
		is_mainnet: true,
	},
	{
		// https://github.com/ethereum-lists/chains/blob/master/_data/chains/eip155-5.json
		id: CHAIN_ID_GOERLI,
		name: 'Goerli',
		explorer: 'https://goerli.etherscan.io',
		metadata: 'https://metadata.ens.domains/goerli',
		opensea: 'https://testnets.opensea.io/assets/goerli/'
	},
	{
		// https://github.com/ethereum-lists/chains/blob/master/_data/chains/eip155-11155111.json
		id: CHAIN_ID_SEPOLIA,
		name: 'Sepolia',
		explorer: 'https://sepolia.etherscan.io',
		metadata: 'https://metadata.ens.domains/sepolia',
		opensea: 'https://testnets.opensea.io/assets/sepolia/',
	},
	{
		// https://github.com/ethereum-lists/chains/blob/master/_data/chains/eip155-17000.json
		id: CHAIN_ID_HOLESKY,
		name: 'Holesky',
		explorer: 'https://holesky.etherscan.io',
		metadata: 'https://metadata.ens.domains/holesky',
		//opensea: 'https://testnets.opensea.io/assets/holesky/',
		rpc: 'https://rpc.holesky.ethpandaops.io'
	}
];
CHAINS.forEach(chain => {
	if (!chain.slug) chain.slug = chain.name.toLowerCase();
});

const MIN_ETH_LENGTH = 3;
const NFT_DOMAINS = new Set(['eth', 'art']); //, 'box']);
const REVERSE_DOMAIN = 'addr.reverse';
const RESOLVER_NAMES = {
	'0x1da022710dF5002339274AaDEe8D58218e9D6AB5': 'Old Public (v0)',  // 3648359: just addr()
	'0xDaaF96c344f63131acadD0Ea35170E7892d3dfBA': 'Old Public (v1)',  // 9380387: addr(coinType)
	'0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41': 'Old Public (v2)',  // 9412610: same as v1?
	'0x231b0Ee14048e9dCcD1d247744d114a4EB5E8E63': '‚ú®Ô∏è Public (v3)',  // 16925619: wrapper support, versioned, name()
	'0x5fBb459C49BB06083C33109fA4f14810eC2Cf358': 'Old Reverse (v1)',
	'0xA2C122BE93b0074270ebeE7f6b7292C7deB45047': 'Old Reverse (v2)',
	'0xF142B308cF687d4358410a4cB885513b30A42025': 'Offchain DNS'
};
const IS_CONTRACT = new Map();
const IS_WILD = new Map();
const NOT_IFACE_RESOLVER = new Set();
const IFACE_ETH_CONTROLLER = '0x612e8c09';
const ADDRESS_MAP = new Map();

const ERROR_ABI = new ethers.Interface([
	'error InvalidLabelCount(bytes dns, uint256 count)',
]);

// TODO: https://github.com/ensdomains/docs/blob/profile-text-records/ens-improvement-proposals/ensip-xx-profile-text-records.md
const TYPE_ADDR = 'addr(bytes32,uint256)';
const TYPE_TEXT = 'text';
const TYPE_PUBKEY = 'pubkey';
const TYPE_CONTENTHASH = 'contenthash';
const TYPE_NAME = 'name';
const RECORDS = [
	{
		key: 'name',
	},
	{
		key: 'language',
		bonus: true,
	},
	{
		key: 'timezone',
		icon: '<b>tz</b>',
		bonus: true,
	},
	{
		key: 'notice',
		class: 'notice'
	},
	{
		key: 'url',
		icon: 'üåêÔ∏è',
		format(x) {
			let match = x.match(/^https?:\/\/(.*?)\/?$/i);
			return match ? match[1] : x;
		},
		url(x) { return x; }
	},
	{
		key: 'location'
	},	
	{
		key: 'phone',
		icon: '‚òéÔ∏è',
		url(x) { return `tel:${x}`; }
	},
	{
		key: 'email',
		icon: 'üìßÔ∏è',
		url(x) { return `mailto:${x}`; }
	},
	{
		key: 'com.twitter', 
		icon: `<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 22 20"><path fill="var(--geist-fill, currentColor)" stroke="none" d="M16.99 0H20.298L13.071 8.26L21.573 19.5H14.916L9.702 12.683L3.736 19.5H0.426L8.156 10.665L0 0H6.826L11.539 6.231L16.99 0ZM15.829 17.52H17.662L5.83 1.876H3.863L15.829 17.52Z"/></svg>`,
		url(x) { return `https://twitter.com/${x}`; },
		fix: repair_social,
	},
	{
		key: 'farcaster', 
		icon: '<img src="https://warpcast.com/favicon.png">',
		url(x) { return `https://warpcast.com/${x}`; },
		fix: repair_social
	},
	{
		key: 'lens', 
		url(x) { return `https://hey.xyz/u/${x}`; },
	},
	{
		key: 'com.github', 
		icon: '<img src="https://github.githubassets.com/favicons/favicon.png">',
		url(x) { return `https://github.com/${x}`; }
	},
	{
		key: 'com.discord',
		icon: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="#5A57DD"><path d="M20.7273 5.45455C20.7273 5.45455 18.2264 3.49746 15.2727 3.27273L15.0065 3.80509C17.6771 4.45855 18.9022 5.39509 20.1818 6.54546C17.9755 5.41909 15.7969 4.36364 12 4.36364C8.20309 4.36364 6.02455 5.41909 3.81818 6.54546C5.09782 5.39509 6.55527 4.35546 8.99345 3.80509L8.72727 3.27273C5.62855 3.56564 3.27273 5.45455 3.27273 5.45455C3.27273 5.45455 0.479455 9.50455 0 17.4545C2.81564 20.7016 7.09091 20.7273 7.09091 20.7273L7.98491 19.5355C6.46745 19.008 4.75364 18.066 3.27273 16.3636C5.03891 17.7 7.70455 19.0909 12 19.0909C16.2955 19.0909 18.9611 17.7 20.7273 16.3636C19.2464 18.066 17.5325 19.008 16.0151 19.5355L16.9091 20.7273C16.9091 20.7273 21.1844 20.7016 24 17.4545C23.5205 9.50455 20.7273 5.45455 20.7273 5.45455ZM8.45455 15.2727C7.40018 15.2727 6.54545 14.2958 6.54545 13.0909C6.54545 11.886 7.40018 10.9091 8.45455 10.9091C9.50891 10.9091 10.3636 11.886 10.3636 13.0909C10.3636 14.2958 9.50891 15.2727 8.45455 15.2727ZM15.5455 15.2727C14.4911 15.2727 13.6364 14.2958 13.6364 13.0909C13.6364 11.886 14.4911 10.9091 15.5455 10.9091C16.5998 10.9091 17.4545 11.886 17.4545 13.0909C17.4545 14.2958 16.5998 15.2727 15.5455 15.2727Z"></path></svg>`,
	},
	{
		key: 'com.reddit', 
		icon: '<img src="https://www.redditstatic.com/desktop2x/img/favicon/apple-icon-60x60.png">',
		url(x) { return `https://reddit.com/u/${x}`; },
	},
	{
		key: 'io.keybase',
		icon: '<img src="https://keybase.io/images/icons/icon-keybase-logo-48.png">',
		url(x) { return `https://keybase.io/${x}`; },
		fix: repair_social
	},
	{
		key: 'org.telegram',
		icon: '<img src="https://telegram.org/img/favicon-32x32.png">',
		url(x) { return `https://t.me/${x}`; },
		fix: repair_social
	},
	{
		key: 'com.linkedin',
		icon: '<img src="https://static.licdn.com/scds/common/u/images/logos/favicons/v1/favicon.ico">',
		url(x) { return `https://www.linkedin.com/in/${x}`; }
	},
	{
		type: TYPE_CONTENTHASH,
	},
	{
		type: TYPE_PUBKEY,
		bonus: true,
	},
	{
		coin: 0, // BTC
		icon: `<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 500 500" role="img" class="sc-56a68b4b-0 nEsDk"><path fill="#F39321" d="M43.43 125.143c7.71-10.766 14.875-21.901 23.562-31.986 15.8-18.343 33.692-34.063 54.18-47.075 18.379-11.672 37.761-20.872 58.501-27.305 32.294-10.018 65.26-12.997 98.838-9.165 24.544 2.801 48.191 9.067 70.713 19.215 13.633 6.142 26.456 13.731 39.025 21.927 25.328 16.515 45.618 38.014 62.58 62.577 18.116 26.236 29.889 55.421 36.346 86.725 4.535 21.983 6.449 44.171 4.503 66.504-2.399 27.536-8.514 54.086-19.938 79.604-9.662 21.583-21.589 41.401-36.861 59.301-14.94 17.511-31.788 32.831-51.149 45.461-13.184 8.6-26.926 16.276-41.434 21.975-24.274 9.537-49.447 15.986-75.787 17.115-18.545.795-36.985.483-55.279-2.763-15.713-2.788-31.049-6.858-46.063-12.496-14.566-5.47-28.693-11.95-41.709-20.143-18.766-11.812-35.683-26.147-50.737-42.663-16.773-18.403-30.373-38.808-40.779-61.344-14.7-31.835-21.929-65.401-22.359-100.425-.162-13.173 1.349-26.244 3.105-39.283.126-.933-.002-1.899-.012-2.851 1.536-.952 1.4-2.618 1.677-4.071 3.906-20.483 10.494-40.059 19.418-58.906 3.162-6.674 7.525-12.764 9.659-19.928zm281.727 129.37c6.537-3.474 12.749-5.465 17.658-9.85 18.918-16.899 23.96-56.673-6.747-75.833-9.566-5.969-19.77-10.393-30.77-14.907 1.819-14.731 7.709-28.516 9.622-43.603-9.076-2.249-17.578-5.234-26.425-6.193l-10.674 41.837c-6.78-2.076-13.761-1.879-20.142-5.473 2.302-14.39 7.773-27.872 9.268-42.314-9.322-1.464-17.216-5.094-26.265-5.485l-10.586 42.215c-17.944-2.75-34.419-8.921-52.52-12.239-3.977 8.91-5.738 18.311-7.334 28.313 5.896 1.392 11.022 2.623 16.158 3.811 12.965 2.998 16.517 10.086 13.439 21.424-2.19 8.065-4.166 16.189-6.182 24.301-7.245 29.16-14.432 58.333-21.72 87.482-1.642 6.567-5.734 8.706-12.398 7.731-6.563-.96-12.757-3.907-19.99-3.693-3.136 10.032-9.378 18.871-11.588 29.946l51.344 13.08c-1.312 15.208-7.614 29.125-9.476 44.441l25.544 6.123c5.653-14.044 6.957-28.803 12.226-43.33 6.351 3.265 13.397 2.317 19.612 6.427l-10.178 42.077c8.986 3.216 17.753 4.528 26.758 6.77l10.578-42.386c2.123-1.091 3.676-.888 5.143-.574a132.886 132.886 0 0 0 42.676 2.14c12.368-1.373 23.343-6.088 32.148-15.372 9.791-10.323 14.71-22.952 17.078-36.535 1.93-11.065 1.436-22.277-5.06-32.071-5.091-7.674-12.084-13.53-21.197-18.26zM223.128 312.17c17.411 4.325 34.803 8.95 53.02 5.624 9.715-1.774 17.037-6.73 19.985-16.503 2.78-9.218 1.164-17.593-5.673-24.879-7.11-7.576-16.254-11.514-25.682-14.807-11.264-3.934-22.683-7.508-34.99-8.48l-13.972 56.788c2.981.929 5.117 1.712 7.312 2.257zm61.5-80.324c9.628-1.368 17.612-7.738 19.958-16.393 2.869-10.583-.337-19.865-8.902-26.178-9.718-7.163-20.908-10.807-32.47-13.337-4.307-.943-8.544-3.454-13.756-1.759l-12.599 51.209c16.457 4.155 31.611 8.753 47.769 6.458z"></path></svg>`,
		btc: {p2pkh: 0, p2sh: 5, hrp: 'bc', p2wpkh: 0, p2tr: 1},
		url(x) { return `https://blockstream.info/address/${x}`; },
	},
	{
		coin: 2, // LTC
		icon: `<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 500 500" role="img" class="sc-56a68b4b-0 nEsDk"><circle cx="249.8" cy="250.2" r="248.4" style="fill: rgb(51, 94, 159);"></circle><path d="m139.4 402.6 37-120.2-40.3 12.3 10.7-29.6 37-11.5 51.7-170.1c1.1-3.6 4.5-6.1 8.3-6.1h52.8c5.8 0 9.9 5.6 8.3 11.1l-42 140.4 37.9-10.7-6.9 28.6-39.1 11.8-27.3 87.2h139c4.2 0 7.2 4 6.1 8L360.5 398c-.8 2.7-3.2 4.6-6.1 4.6h-215z" style="fill: rgb(255, 255, 255);"></path></svg>`,
		btc: {p2pkh: 0x30, p2sh: 0x32, hrp: 'ltc', p2wpkh: 0},
		url(x) { return `https://litecoinspace.org/address/${x}`; }
	},
	{
		coin: 3, // DOGE
		icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2000 2000" role="img" class="sc-56a68b4b-0 nEsDk"><g fill="#c2a633"><path d="M1024 659H881.12v281.69h224.79v117.94H881.12v281.67H1031c38.51 0 316.16 4.35 315.73-327.72S1077.44 659 1024 659z"></path><path d="M1000 0C447.71 0 0 447.71 0 1000s447.71 1000 1000 1000 1000-447.71 1000-1000S1552.29 0 1000 0zm39.29 1540.1H677.14v-481.46H549.48V940.7h127.65V459.21h310.82c73.53 0 560.56-15.27 560.56 549.48 0 574.09-509.21 531.41-509.21 531.41z"></path></g></svg>`,
		btc: {p2pkh: 0x1E, p2sh: 0x16},
		url(x) { return `https://dogechain.info/address/${x}`; }
	},
	{
		coin:  8444, // CHIA
		icon: 'üå±Ô∏è',
		bech32: {hrp: 'xch', type: Bech32.M},
		url(x) { return `https://xchscan.com/address/${x}`; },
		bonus: true
	},
	{
		evm: 137,
		name: 'polygon',
		icon: '<img src="https://assets-global.website-files.com/637359c81e22b715cec245ad/63f775c741010796d62770fd_polygon-favicon.png">',
		url(x) { return `https://polygonscan.com/address/${x}`; },
		bonus: true,
	},
	{	
		evm: 10,
		name: 'op',
		icon: '<img src="https://assets-global.website-files.com/611dbb3c82ba72fbc285d4e2/612d2f8f988b5f801bd0cf1e_favicon.png">',
		url(x) { return `https://optimistic.ethereum.io/address/${x}`; },
		bonus: true,
	},
	{
		evm: 42161,
		name: 'arb',
		icon: '<img src="https://arbitrum.foundation/favicon.ico">',
		url(x) { return `https://arbiscan.io/address/${x}`; },
		bonus: true,
	},
	{
		evm: 43114,
		name: 'avax',
		icon: '<img src="https://assets-global.website-files.com/632993e1d1acbfa5635afd0b/63515267b3214c6dda03ea97_Favicon.png">',
		url(x) { return `https://snowtrace.dev/address/${x}`; },
		bonus: true,
	},
	{
		evm: 84532,
		name: 'base',
		icon: '<img src="https://base.org/document/favicon-32x32.png">',
		url(x) { return `https://basescan.org/address/${x}`; },
		bonus: true,
	},
	{
		evm: 100,
		legacy: 700,
		name: 'gnosis', // xdai
		url(x) { return `https://gnosisscan.io/address/${x}`; },
		bonus: true,
	},
	{
		evm: 534352,
		name: 'scroll',
		url(x) { return `https://scrollscan.com/address/${x}`; },
		bonus: true,
	},
	{
		evm: 7777777,
		name: 'zora',
		url(x) { return `https://explorer.zora.energy/address/${x}`; },
		bonus: true,
	},
	{
		coin: 714,
		name: 'bnb',
		icon: '<img src="https://explorer.bnbchain.org/static/images/favicon.ico">',
		bech32: {hrp: 'bnb', type: 1},
		url(x) { return `https://explorer.bnbchain.org/address/${x}`; },
		bonus: true,
	},
	{
		coin: 118,
		name: 'atom',
		icon: '<img src="https://atomscan.com/img/icons/chains/atom.svg">',
		bech32: {hrp: 'cosmos', type: 1},
		url(x) { return `https://atomscan.com/account/`; },
		bonus: true
	},
	{
		coin: 501,
		name: 'sol',
		base58: true,
		url(x) { return `https://explorer.solana.com/address/${x}`; },
		bonus: true,
	},
	{
		evm: 56,
		name: 'bsc',
		url(x) { return `https://bscscan.com/address/${x}`; },
		bonus: true,
	},
	{
		evm: 250,
		legacy: 1007,
		name: 'ftm',
		url(x) { return `https://explorer.fantom.network/address/${x}`; },
		bonus: true,
	},
	{
		evm: 42220,
		legacy: 52752,
		name: 'celo',
		url(x) { return `https://explorer.celo.org/mainnet/address/${x}`; },
		bonus: true,
	},
	// {
	// 	type: TYPE_ADDR,
	// 	evm: 5,
	// 	name: 'goerli',
	// 	url(x) { return `https://goerli.etherscan.io/address/${x}`; },
	// 	bonus: true,
	// 	testnet: true,
	// },
	// {
	// 	type: TYPE_ADDR,
	// 	evm: 11155111 ,
	// 	name: 'sepolia',
	// 	url(x) { return `https://sepolia.etherscan.io/address/${x}`; },
	// 	bonus: true,
	// 	testnet: true,
	// },
	{
		key: 'description',
		icon: '<b>desc</b>',
	},
	{
		key: 'avatar',
		format() { return ''; },
	},
	{
		key: 'banner',
		format() { return ''; },
		url(x) { return x; },
	},
].map(prepare_record);
function prepare_record(rec) {
	if (typeof rec.key === 'string') {
		rec.type = TYPE_TEXT;
	} else if (Number.isInteger(rec.coin)) {
		rec.type = TYPE_ADDR;
	} else if (Number.isInteger(rec.evm)) {
		// https://docs.ens.domains/ens-improvement-proposals/ensip-11-evmchain-address-resolution
		rec.type = TYPE_ADDR;
		rec.coin = rec.evm + 0x80000000;
	} else if (!rec.type) {
		throw new Error(`invalid record: ${JSON.stringify(rec)}`);
	}
	return rec;
}

const location0 = new URL(window.location.href);

let debug_enabled;
let debug_settings;
let window_provider;
let active_provider;
let active_chain;
let registry_contract;
let eth_resolver_contract;
let eth_nft_contract;
let eth_controller_contract;
let wrapper_contract;
let multicall_contract;
let price_oracle_contract;
let reverse_registrar;
let resolve_timer = RESOLVE_MODE_IDLE;
let resolve_last;
let resolve_debug;
let available;

console.log(versions);
version_span.innerHTML = `v${versions.version}`;
version_span.addEventListener('click', () => {
	window.alert(Object.entries(versions).map(([k, v]) => `[${k}]\n${v}`).join('\n\n'));
});

function keycap(i) {
	return String.fromCodePoint(0x30+i, 0xFE0F, 0x20E3);
}
const KEYCAP_MINUS = '‚ûñÔ∏è';
const KEYCAP_NAME = 'Keycap';
const DIGIT_MAP = new Map(Array.from({length: 10}, (_, i) => [keycap(i), i]));
const DIGITS_MAP = new Map();
function add_digits(name, digits, extra = {}) {
	explode_cp(digits).forEach((cp, i) => DIGIT_MAP.set(cp, {name, i, ...extra}));
	DIGITS_MAP.set(name, digits);
}
add_digits('ASCII', '0123456789');
add_digits('Arabic', 'Ÿ†Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©', {mixed: 1});
[[0x6F4, 4], [0x6F5, 5], [0x6F6, 6]].forEach(([cp, i]) => {
	DIGIT_MAP.set(cp, {name: 'Extended Arabic', i, mixed: 1});
});
add_digits('CJK', '„Äá‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πù');
add_digits('Devangari', '‡•¶‡•ß‡•®‡•©‡•™‡•´‡•¨‡•≠‡•Æ‡•Ø');
add_digits('Thai', '‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô');
//add_digits('Bengali', '‡ß¶‡ßß‡ß®‡ß©‡ß™‡ß´‡ß¨‡ß≠‡ßÆ‡ßØ');
//add_digits('Tamil', '‡Ø¶‡Øß‡Ø®‡Ø©‡Ø™‡Ø´‡Ø¨‡Ø≠‡ØÆ‡ØØ'); 

for (let btn of document.querySelectorAll('#examples button:not([id]), button[data-name]')) {
	let name = btn.innerText;
	if (btn.dataset.name) name = btn.dataset.name;
	if (typeof btn.dataset.raw !== 'string') name = replace_escapes(name);
	if (!btn.innerText || btn.innerText.includes('{')) btn.innerText = name;
	let meta = typeof btn.dataset.meta === 'string' || name.includes(':') || is_checksum_address(name);
	try {
		if (meta || name !== ens_normalize(name)) {
			btn.classList.add('mapped');
		}
	} catch (err) {
		btn.classList.add('error');
	}	
	if (!meta) name = add_dot_eth(name);
	if (typeof btn.dataset.escape === 'string') name = apply_escapes_where(name);
	if (!btn.title) btn.title = meta ? name : `${name}\n${explode_cp(name).map(hex_cp).join(' ')}`;
	btn.addEventListener('click', () => {
		input_field.value = name;
		if (btn.dataset.skip) skip_norm_check.checked = true;
		if (options_div.getBoundingClientRect().top > window.innerHeight * .9) {
			options_div.scrollIntoView(); // scuffed
		}
		let delay = parseInt(btn.dataset.delay)|0;
		if (delay > 0) {
			schedule_resolve(delay);
		} else {
			resolve();
		}
	});
}
for (let x of document.querySelectorAll('[data-tokenize]')) {
	x.replaceWith(dom_from_tokens(ens_tokenize(replace_escapes(x.dataset.tokenize)), {
		components: x.dataset.parts,
		emoji(a, {emoji}) {
			a.href = `#${encodeURIComponent(String.fromCodePoint(...emoji))}`;
		},
		tld: true
	}));
}
resolve_btn.addEventListener('click', resolve);
input_field.addEventListener('keydown', e => {
	if (e.key === 'Enter') {
		e.stopPropagation();
		if (e.shiftKey) input_field.value = add_dot_eth(input_field.value.trim(), true);
		resolve();
	} else if (e.key === 'Escape') {
		e.preventDefault();
		input_field.value = '';
		resolve();
	}
});
input_field.addEventListener('input', () => {
	if (parse() && auto_resolve_check.checked) schedule_resolve();
});

window.addEventListener('storage', e => {
	if (e.type === 'storage' && e.key === STORAGE_RECENT) {
		sync_recent(e.newValue);
	}
});
function sync_recent(saved) {
	recent_optgroup.innerHTML = '';
	try {
		JSON.parse(saved).reverse().forEach(x => add_recent(x, false));
	} catch (err) {	
	}
}
recent_select.addEventListener('change', () => {
	let option = recent_select.selectedOptions[0];
	recent_select.selectedIndex = -1;
	if (!option) return;
	if (recent_optgroup.contains(option)) {
		input_field.value = option.value;
		resolve();
	} else if (option.value === 'reset') {
		recent_select.classList.add('hide');
		recent_optgroup.innerHTML = '';
		localStorage[STORAGE_RECENT] = '[]';
	}
});
function add_recent(name, save = true) {
	if (!name) return;
	let found;
	for (let x of recent_optgroup.children) {
		if (x.value === name) {
			recent_optgroup.prepend(x); // move to top
			found = true;
			break;
		}
	}
	if (!found) {
		while (recent_optgroup.childElementCount >= 25) { // max
			recent_optgroup.lastChild.remove();
		}
		let option = new Option();
		option.value = name;
		if (is_checksum_address(name)) {
			option.innerHTML = `üè†Ô∏è ${name}`; 
		} else {
			try {
				let norm = ens_normalize(name);
				option.innerHTML = `${norm === name ? '‚úÖÔ∏è' : '‚òëÔ∏è'} ${name}`;
			} catch (err) {
				option.innerHTML = `‚ùåÔ∏è ${apply_escapes_where(name, cp => should_escape(cp) || cp == 0x20)}`;
			}
		}
		recent_optgroup.prepend(option);
	}
	recent_select.selectedIndex = -1;
	recent_select.classList.remove('hide');
	if (save) {
		localStorage[STORAGE_RECENT] = JSON.stringify([...recent_optgroup.children].map(x => x.value));
	} 
}

$('#random_emoji_btn').addEventListener('click', e => {
	let name = '';
	let pool = e.altKey ? EMOJI.filter(cps => cps.length == 1 || (cps.length == 2 && cps[1] === 0xFE0F)) : EMOJI;
	while (Array.from(name).length < MIN_ETH_LENGTH) {
		name += ens_normalize(str_from_cps(pool[Math.random() * pool.length|0]));
	}
	input_field.value = add_dot_eth(name);
	skip_norm_check.checked = false;
	resolve();
});
function get_selected_input() {
	let {value, selectionStart, selectionEnd} = input_field;
	if (selectionEnd > selectionStart) {
		value = value.slice(selectionStart);
	}
	return replace_escapes(value);
}
$('#find_emoji_btn').addEventListener('click', e => {
	let url = './emoji.html';
	let value = get_selected_input();
	let token = ens_tokenize(value).find(x => x.emoji);
	if (token) url += `#q=${encodeURIComponent(String.fromCodePoint(...token.cps))}`;
	create_link(url).click();	
});
$('#chars_btn').addEventListener('click', e => {
	let url = './chars.html';
	let value = get_selected_input();
	if (value) url += `#${value.codePointAt(0).toString(16)}`;
	create_link(url).click();
});
$('#confused_btn').addEventListener('click', e => {
	create_link(`./confused.html#${encode_uri_component_surrogate_escaped(input_field.value.replaceAll('.', ''))}`).click();
});
nf_btn.addEventListener('click', () => {
	let s0 = input_field.value;
	let s1 = replace_escapes(s0);
	let s2 = apply_escapes_where(str_from_cps(nfd(explode_cp(s1))));
	let s3 = apply_escapes_where(str_from_cps(nfc(explode_cp(s1))));
	if (s2 === s3 && s2 === apply_escapes_where(s1)) return; // do nothing
	input_field.value = s0 == s2 ? s3 : s2;
	resolve();
});
parent_btn.addEventListener('click', e => {
	let name = input_field.value;
	let pos = name.indexOf('.');
	input_field.value = pos >= 0 ? name.slice(pos+1) : '';
	resolve();
});
escape_btn.addEventListener('click', e => {
	let s0 = input_field.value;
	let s1 = replace_escapes(s0);
	let s2 = apply_escapes_where(s1, undefined, e.altKey);
	let s3 = apply_escapes_where(s1, () => true, e.altKey);
	let set = [...new Set([s1, s2, s3])];
	let pos = set.indexOf(s0);	
	input_field.value = set[(pos + 1) % set.length];
	update_location();
});
$('#copy_link_btn').addEventListener('click', () => {
	navigator.clipboard.writeText(get_page_url());
});
$('#copy_example_btn').addEventListener('click', () => {
	let url = get_page_url();
	url.hash = '#vitalik.eth';
	navigator.clipboard.writeText(url);
});

auto_resolve_check.addEventListener('input', () => {
	save_settings();
	if (auto_resolve_check.checked && input_field.value) {
		resolve();
	}
});
show_details_check.addEventListener('input', () => {	
	save_settings();
	for (let el of document.querySelectorAll('.detailed')) {
		make_detailed(el);
	}
});
show_records_check.addEventListener('input', () => {
	save_settings();
	let row = $('.row.records');
	if (row) {
		row.classList.toggle('hide', !show_records_check.checked);
		let avatar = $('.avatar');
		if (avatar) avatar.classList.toggle('hide', !show_records_check.checked);
	} else if (show_records_check.checked) {
		resolve();
	}
});
show_components_check.addEventListener('input', () => {
	save_settings();
	update_exploded();
});
skip_norm_check.addEventListener('input', resolve);

function sync_force_ltr() {
	input_field.classList.toggle('force-ltr', force_ltr_check.checked);
}
force_ltr_check.addEventListener('input', () => {
	save_settings();
	sync_force_ltr();
});

function sync_examples() {
	if (examples_div.classList.contains('hide')) {
		examples_btn.innerText = 'üëÄ Examples';
		options_div.prepend(examples_btn);
	} else {
		examples_btn.innerText = 'üôà Hide Examples';
		examples_div.prepend(examples_btn);
	}
}
examples_btn.addEventListener('click', () => {
	examples_div.classList.toggle('hide');
	save_settings();
	sync_examples();
});

chain_select.replaceChildren(...CHAINS.map(x => create('option', {value: x.id}, x.name)));
chain_select.addEventListener('change', () => update_network());
mainnet_btn.addEventListener('click', () => {
	chain_select.value = 1;
	update_network();
});
browser_btn.addEventListener('click', () => {
	chain_select.value = window_provider.__chain.id;
	update_network();
});

function sync_debug() {
	debug_div.classList.toggle('hide', !debug_enabled);
	enable_debug_btn.classList.toggle('hide', !!debug_enabled);
	if (debug_enabled) {
		debug_ta.value = Object.keys(debug_settings).length ? JSON.stringify(debug_settings, null, DEBUG_INDENT) : '';
	}
}
enable_debug_btn.addEventListener('click', () => {
	debug_enabled = true;
	save_settings();
	sync_debug();
	debug_ta.scrollIntoView();
});
$('#disable_debug_btn').addEventListener('click', () => {
	debug_enabled = false;
	save_settings();
	sync_debug();
	if (resolve_debug) resolve();
});
$('#apply_debug_btn').addEventListener('click', apply_debug);
function apply_debug() {
	try {
		let settings = JSON.parse(debug_ta.value.trim() || '{}');
		if (!is_object(settings)) throw new Error('expected object');
		let {ccip, records, resolver} = settings;
		if (ccip) {
			if (!is_object(ccip)) throw new Error('expected "ccip" {address: endpoint}');
			settings.ccip = Object.fromEntries(Object.entries(ccip).map(([k, v]) => [ethers.getAddress(k), new URL(v).toString()])); // validate and format
		}
		if (resolver) {
			if (!is_object(resolver)) throw new Error('expected "resolver" {name: address}');
			settings.resolver = Object.fromEntries(Object.entries(resolver).map(([k, v]) => [ens_normalize(k), ethers.getAddress(v)])); // validate and format
		}
		if (records) {
			if (!Array.isArray(records)) throw new Error('expected "records" array');
			records.forEach(x => prepare_record({...x})); // only validate
		}
		let dirty = JSON.stringify(debug_settings) !== JSON.stringify(settings);
		if (dirty) {
			debug_settings = settings;
			save_settings();
		}
		sync_debug(); // pretty
		if (debug_settings !== resolve_debug) resolve();
	} catch (err) {
		window.alert(err.message);
	}
}
debug_ta.addEventListener('keydown', e => {
	if (e.key === 'Enter' && e.shiftKey) {
		e.preventDefault();
		apply_debug();
	} else if (e.key === 'Tab') {
		e.preventDefault();	
		document.execCommand('insertText', false, DEBUG_INDENT);
	}
});
debug_ta.placeholder = `{
	// resolver overrides: name -> contract
	"resolvers": {
		"domain.fake": "0x32aC8A721A0d9Ce85F88599228297BBa8E183044"
	},
	// endpoint overrides: contract -> endpoint
	"ccip": {
		"0x32aC8A721A0d9Ce85F88599228297BBa8E183044": "https://localhost:80/"
	},
	// additional records
	"records": [
		{"key": "primary-contact"}, // text()
		{"coin": 1234},             // coin()
		{"evm": 5}                  // coin() via ENSIP-11
	],
	// misc interface stuff
	"jazz": false,    // debug jazz icons
	"fuzes": false,   // debug wrapper fuses interface
	"primary": false, // debug primary normalization	
}`.replaceAll('\t', DEBUG_INDENT);

function set_page_url(url) {
	apply_page_url(url);
	if (!update_network()) {
		resolve();
	}
}
window.addEventListener('popstate', e => set_page_url(new URL(e.state || '', location0)));
window.addEventListener('hashchange', e => set_page_url(new URL(e.newURL)));
window.addEventListener('unload', () => {}); // prevent weird restore behavior 

// cleanup non-namespaced keys
// TODO: remove me
for (let k of Object.keys(localStorage)) {
	if (!k.includes('.')) {
		localStorage.removeItem(k);
	}
}

function save_settings() {
	localStorage[STORAGE_SETTINGS] = JSON.stringify({
		hide_examples: examples_div.classList.contains('hide'),
		auto_resolve: auto_resolve_check.checked,
		show_details: show_details_check.checked,
		show_components: show_components_check.checked,
		show_records: show_records_check.checked,
		force_ltr: force_ltr_check.checked,
		debug_enabled,
		debug_settings
	});
}
try {
	let settings = JSON.parse(localStorage[STORAGE_SETTINGS]);
	examples_div.classList.toggle('hide', !!settings.hide_examples);
	auto_resolve_check.checked = settings.auto_resolve;
	show_details_check.checked = settings.show_details;
	show_components_check.checked = settings.show_components;
	show_records_check.checked = settings.show_records;
	force_ltr_check.checked = settings.force_ltr;
	({debug_enabled, debug_settings} = settings);
} catch (err) {
}
if (!debug_settings) debug_settings = {};
sync_recent(localStorage[STORAGE_RECENT]);
sync_force_ltr();
sync_examples();
sync_debug();
apply_page_url(location0);
input_field.focus();

const ccipReadFetchOld = ethers.AbstractProvider.prototype.ccipReadFetch;
ethers.AbstractProvider.prototype.ccipReadFetch = function(tx, calldata, urls) {
	if (resolve_debug) {
		try {
			let url = resolve_debug.ccip[tx.to];
			if (url) urls = [url];
		} catch (err) {
		}
	}
	return ccipReadFetchOld.call(this, tx, calldata, urls);
}

if (window.ethereum) {
	let p = ethereum;
	if (Array.isArray(p.providers)) p = p.providers[0]; // fix scuffed multi-provider
	window_provider = new ethers.BrowserProvider(p, 'any');
	window_provider.__provider = p;
	let timer = setTimeout(set_window_network, 100);
	window_provider._detectNetwork().catch(() => {}).then(network => {
		clearTimeout(timer);
		set_window_network(network);
	});
	p.on('connect', ({chainId}) => set_window_network(ethers.Network.from(parseInt(chainId))));
	p.on('chainChanged', chainId => set_window_network(ethers.Network.from(parseInt(chainId))));
	p.on('disconnect', () => set_window_network());
} else {
	update_network();
}

async function change_window_to_chain(chain) {	
	let chainId = `0x${chain.id.toString(16)}`;	
	try {
		await window_provider.send('wallet_switchEthereumChain', [{chainId}]); 
		// throws on cancel request
		// throws on unknown provider
	} catch (err) {
		if (is_user_rejection(err)) return;
		if (err.error && err.error.code === 4902) { // unrecognized chain
			let {rpc} = chain;
			if (!rpc) throw new Error(`Unknown RPC for ${chain.name}\nNetwork: ${format_dec_hex(chain.id)}`);
			try {
				// https://eips.ethereum.org/EIPS/eip-3085
				await window_provider.send('wallet_addEthereumChain', [{
					chainId, 
					chainName: chain.name,
					blockExplorerUrls: [chain.explorer],
					nativeCurrency: {
						name: `${chain.name} ETH`,
						symbol: 'ETH',
						decimals: 18
					},
					rpcUrls: [rpc]
				}]);
				set_window_network(await window_provider._detectNetwork());
				return;
			} catch (err2) {
				if (is_user_rejection(err2)) return;
				err = err2;
			}
		}
		throw err;
	}
}
function is_user_rejection(err) {
	console.log(err, {...err});
	return err.shortMessage === 'user rejected action';
}
function set_window_network(network) {
	window_provider.__network = network;
	window_provider.__chain = null;
	if (network) {
		let chain_id = Number(network.chainId); // BigInt
		let chain = CHAINS.find(x => x.id === chain_id);
		if (chain) {
			window_provider.__chain = chain;
		}
	}
	update_network();
}
function update_network() {
	let changed;
	let chain_id = parseInt(chain_select.value);
	let chain = CHAINS.find(x => x.id === chain_id) || CHAINS[0];
	if (window_provider && window_provider.__chain === chain) {
		active_provider = window_provider;
	} else {
		let old = active_provider;
		if (old === window_provider || active_chain !== chain) {
			if (chain.rpc) {
				active_provider = new ethers.JsonRpcProvider(chain.rpc, chain.id, {staticNetwork: true});
			} else {
				active_provider = new ethers.InfuraProvider(chain.id, 'f36f6a8638134ac09f9400d3a7008dfe');
			}
		}
		if (old && old !== window_provider && old !== active_provider) {
			setTimeout(() => old.destroy(), 0);
		}
	}
	if (active_chain !== chain) {
		changed = true;
		active_chain = chain;
		let init = !registry_contract;
		// registry contract address is static on all supported chains
		registry_contract = new ethers.Contract('0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e', [
			'function resolver(bytes32 node) external view returns (address)',
			'function owner(bytes32 node) external view returns (address)',
		], active_provider);
		// multicall3 contract address is static on all supported chains
		// https://www.multicall3.com/deployments
		multicall_contract = new ethers.Contract('0xcA11bde05977b3631167028862bE2a173976CA11', [
			`function tryAggregate(bool requireSuccess, tuple(address target, bytes data)[] memory calls) public view returns (tuple(bool success, bytes data)[] memory returnData)`
		], active_provider);
		eth_resolver_contract = null;
		eth_nft_contract = null;
		eth_controller_contract = null;
		wrapper_contract = null;
		reverse_registrar = null;
		NOT_IFACE_RESOLVER.clear();
		IS_CONTRACT.clear();
		IS_WILD.clear();		
		if (input_field.value) {
			schedule_resolve(0);
		} else if (init) {
			parse();
		}
	}
	let using_window = active_provider === window_provider;
	update_location();
	document.body.classList.toggle('testnet', !active_chain.is_mainnet);
	chain_select.title = `Network: ${format_dec_hex(active_chain.id)}`;
	mainnet_btn.classList.toggle('hide', !!active_chain.is_mainnet);
	browser_btn.classList.toggle('hide', !(!using_window && window_provider && window_provider.__chain && !window_provider.__chain.is_mainnet));
	provider_div.replaceChildren(create('div', {className: 'network'}, 'using ', create_etherscan_address_link(registry_contract.target, {
		innerHTML: using_window ? 'Browser' : active_chain.rpc ? 'Public RPC' : 'Infura', 
		title: 'ENS Registry Contract',
		contract: true
	})));
	if (!using_window && window_provider && window_provider.__network) {
		provider_div.append(create('button', {
			innerHTML: 'Switch Browser', //`Browser‚Üí${active_chain.name}`,
			title: 'Change Browser to match selected network',
			click() {
				change_window_to_chain(active_chain);
			}
		}));
		if (!window_provider.__chain) {
			let {name} = window_provider.__network;
			if (name === 'unknown') {
				name = format_dec_hex(window_provider.__network.chainId);
			}
			provider_div.append(create('div', {className: 'notice', innerHTML: `üö´Ô∏è Browser: ${name}`}));
		}
	}
	return changed;
}

function should_stop_resolving() {
	return resolve_timer !== RESOLVE_MODE_IDLE;
}

function schedule_resolve(delay = 1000) {
	clearTimeout(resolve_timer);
	if (is_working()) {
		resolve_timer = [Date.now() + delay]; // encode as future time
	} else {
		primary_loader.classList.remove('hide'); // pre-start
		resolve_timer = setTimeout(resolve, delay);
	}
} 

function stop_resolving() {
	clearTimeout(resolve_timer);
	resolve_timer = RESOLVE_MODE_EMPTY;
	primary_loader.classList.add('hide');
}

function apply_page_url(url) {
	chain_select.value = (CHAINS.find(x => url.searchParams.has(x.slug)) || CHAINS[0]).id;
	skip_norm_check.checked = url.searchParams.has('skip');
	input_field.value = decodeURIComponent(url.hash.slice(1));
	if (input_field.value.endsWith('_!')) { // backwards compat
		input_field.value = input_field.value.slice(0, -2);
		skip_norm_check.checked = true;
	}
}
function get_page_url() {
	let input = input_field.value;
	let url = new URL(location0);
	let args = [];
	if (!active_chain.is_mainnet) args.push(active_chain.slug);
	if (skip_norm_check.checked) args.push('skip');
	url.search = args.join('&');
	url.hash = input ? '#' + encode_uri_component_surrogate_escaped(input) : '';
	return url;
}
function get_page_title() {
	let title = 'ENS Resolver';
	let input = input_field.value;
	if (input) {
		title += `: ‚Äú${input}‚Äù`;
		if (skip_norm_check.checked) {
			title += ' (!)';
		}
	}
	if (!active_chain.is_mainnet) {
		title += ` @ ${active_chain.name}`;
	}
	return title;
}
function update_location() {	
	let url = get_page_url();
	if (window.history.state) {
		if (window.history.state != url) {
			window.history.pushState(null, null, url);
		}
	} else {
		window.history.replaceState(null, null, url);
	}
	document.title = get_page_title();
}
function parse() {
	if (!active_chain) return; // wait for init
	update_location();	
	let input = input_field.value;
	let width = ens_tokenize(input, {nf: false}).reduce((a, x) => {
		if (x.type === 'valid') return x.cps.reduce((b, y) => b + (is_combining_mark(y, true) ? 0.5 : 1), a);
		return a + (x.emoji ? 2 : 1);
	}, 0);
	input_field.classList.toggle('small',   width >= 21);
	input_field.classList.toggle('smaller', width >= 36);
	let skip = skip_norm_check.checked;
	nf_btn.disabled = !input;
	escape_btn.disabled = !input;
	parent_btn.classList.toggle('hide', !input);
	show_components_label.classList.add('hide');
	output_div.innerHTML = '';
	clock_span.innerHTML = '';
	available = undefined;
	if (!input) {
		stop_resolving();
		show_components_check
		output_div.append(...readme_dom);
		return;
	}
	// TODO: conslidate this code with resolve()
	let name = replace_escapes(input);
	if (resolve_timer === RESOLVE_MODE_EMPTY) {
		resolve_timer = RESOLVE_MODE_IDLE;
	}
	if (is_checksum_address(name)) {
		let row = create_row('Address');
		row.append(create_etherscan_address_link(name));		
		add_row_tag(row, create_reverse_resolve_btn(name));
		output_div.append(row);
		return true;
	}
	let row = create_row(INPUT_NAME);
	let tokens = ens_tokenize(name); 
	if (tokens.some(x => x.emoji)) show_components_label.classList.remove('hide');
	make_exploded(row, name, false); //, true);
	add_row_tag(row, create_dot_eth_button(name));
	output_div.append(row, create_breakdown_row(name, true));
	try {
		let norm = ens_normalize(name);
		if (norm === name) {
			make_normalized(row, norm);
			//make_exploded(row, name, false);
		} else {
			add_row_tag(row, create_tag('fail', 'Normalized'));
			if (!skip) {
				add_transformed_row(name);
				let norm_row = create_row('Normalized');
				make_exploded(norm_row, norm, true);
				make_normalized(norm_row, norm);
				add_ensip1_tag(norm_row, name, true);
				output_div.append(norm_row, create_breakdown_row(norm));
			}
		}		
		add_ensip1_tag(row, name);
		//output_div.append(create_dns_row(norm));
		return true;
	} catch (err) {
		row.classList.add('error');
		add_row_tag(row, create_tag('norm', err));
		if (skip) return true;
		add_ensip1_tag(row, name);
		stop_resolving();

		// if there is a fully ignorable label
		let collapsed = ens_split(name).filter(x => !x.tokens || x.tokens.length).map(x => str_from_cps(x.input)).join('.');
		if (collapsed !== name) {
			add_row_tag(row, create('button', {
				innerText: 'üí•Ô∏è Collapse Empty Labels',
				click() {
					input_field.value = collapsed;
					resolve();
				}
			}));
		}

		// if there is whitespace
		let stripped = name.replace(/\s+/g, '');
		if (stripped !== name) {
			add_row_tag(row, create('button', {
				innerText: '‚úÇÔ∏è Strip Whitespace',
				click() {
					input_field.value = stripped;
					resolve();
				}
			}));
		}

		// if there are likely unmapped mistakes
		const SLOPPY_MAP = new Map([
			[0x2F, 0x2044], 
			[0x3002, 0x2E],
			[0xFF0E, 0x2E],
			[0xFF61, 0x2E],
		]);
		let sloppy = str_from_cps(explode_cp(name).map(x => SLOPPY_MAP.get(x) || x))
		if (sloppy !== name) {
			add_row_tag(row, create('button', {
				innerHTML: 'üí£Ô∏è Unsafe Replace',
				title: `Replace the following characters:` + [...SLOPPY_MAP.entries()].map(([a, b]) => {
					return `\n"${safe_str_from_cps([a])}" ${hex_cp(a)} ‚Üí "${safe_str_from_cps([b])}" ${hex_cp(b)}`
				}).join(''),
				click() {
					input_field.value = sloppy;
					resolve();
				}
			}));
		}

		// if there are disallowed characters
		if (tokens.some(x => x.type === 'disallowed')) {
			try {
				ens_normalize(stripped);
			} catch (err) {
				// and they aren't just whitespace
				add_row_tag(row, create('button', {
					innerHTML: '‚ùå Remove Disallowed',
					click() {
						input_field.value = str_from_cps(tokens.flatMap(t => t.type === 'nfc' ? t.tokens0 : t).flatMap(t => {
							switch (t.type) {
								case 'disallowed': return [];
								case 'valid': return t.cps;
								case 'emoji': return t.input;
								default: return t.cp;
							}
						}));
						resolve();
					}
				}));	
			}
		}

		// if there are normalizable parts
		if (tokens.some(x => x.type === 'nfc' || x.type === 'ignored' || x.type === 'mapped' || (x.type === 'emoji' && x.input.includes(0xFE0F)))) {
			add_row_tag(row, create('button', {
				innerHTML: 'üí™Ô∏è Force Normalize',
				click() {
					input_field.value = str_from_cps(tokens.flatMap(token => {
						switch (token.type) { 
							case 'ignored': return []; // removes ignored (dangerous)
							case 'mapped': // applies known mappings 
							case 'emoji': // removes FE0F from known emoji
							case 'nfc':
							case 'valid': return token.cps;
							default: return token.cp;
						}
					}));
					resolve();
				}
			}));
		}
	}
}

function add_transformed_row(input) {
	if (ens_tokenize(input).some(x => x.type === 'nfc' || x.type === 'mapped')) {
		let row = create_row('Transform');
		row.classList.add('transform');
		make_detailed(row);
		make_exploded(row, input, true);
		output_div.append(row);
	}
}

function create_dns_row(name, {replaced, contenthash} = {}) {
	let row = create_row(replaced ? 'Alternative DNS' : 'DNS');
	row.classList.add('dns');
	try {
		const MAX_LABEL = 63;
		const MAX_NAME = 253; 
		const VALID_REGEX = /^[-0-9a-z]*$/i;
		let encoded = name.split('.').map(label => {
			let cps = explode_cp(label);
			try {
				let encoded = puny_encoded(cps);//.toLowerCase();
				if (!VALID_REGEX.test(encoded)) {
					let first = [...encoded].find(ch => !VALID_REGEX.test(ch));
					throw new Error(`unsupported ASCII: "${safe_str_from_cps(explode_cp(first))}"`);
				}
				if (encoded === label) {
					if (label.startsWith('xn--')) throw new Error('punycode literal');
					if (label.slice(2, 4) === '--') throw new Error('invalid label extension');
					// 20230123: WHATWG URL uses "CheckHyphens" false
					//if (label.startsWith('-')) throw new Error('leading hyphen');
					//if (label.endsWith('-')) throw new Error('trailing hyphen');
				}
				if (encoded.length > MAX_LABEL) throw new Error(`too long: ${encoded.length} > ${MAX_LABEL}`);
				return encoded;
			} catch (err) {
				throw new Error(`Invalid label "${safe_str_from_cps(cps, 63)}": ${err.message}`);
			}
		}).join('.');
		if (encoded.length > MAX_NAME) {
			throw new Error(`Name too long: ${encoded.length} > ${MAX_NAME}`);
		}
		let browser;
		try {
			browser = new URL(`https://${name}`).host;
		} catch (ignored) {
		}
		row.append(create_main_span(encoded));
		add_row_tag(row, create_copy_btn(encoded));
		if (browser) {
			if (encoded === browser) {
				if (encoded === name) {
					add_row_tag(row, create_tag('good', 'Verbatim'));
				} else {
					add_row_tag(row, create_tag('star', 'Punycoded'));
				}
			} else if (encoded.toLowerCase() === browser) {
				add_row_tag(row, create_tag('warn', 'Uppercase'));
			} else {
				add_row_tag(row, create_tag('stop', 'Mangled'));
				add_row_tag(row, create_copy_btn(browser));
			}
		} else {
			add_row_tag(row, create_tag('stop', 'Incompatible'));
		}
		if (!replaced) {
			add_alternative_btn(row, name);
		}
		if (name.includes('\u200D')) {
			add_row_tag(row, create_tag('warn', 'ZWJ'));
		}
		if (active_chain.is_mainnet) {
			if (encoded.endsWith('.eth')) {
				if (contenthash) {
					add_row_tag(row, create_link(`https://${encoded}.limo`, {button: '‚ÜóÔ∏è Website', buttonClass: 'glow', className: 'external'}));
				} else {
					add_row_tag(row, create_link(`https://${encoded}.limo`, {innerHTML: '.limo', className: 'external'}));
				}
				add_row_tag(row, create_link(`https://${encoded}.link`, {innerHTML: '.link', className: 'external'}));
				add_row_tag(row, create_link(`https://${encoded}.li`,   {innerHTML: '.li',   className: 'external'}));
				add_row_tag(row, create_link(`https://${encoded}.xyz`,  {innerHTML: '.xyz',  className: 'external'}));
				add_row_tag(row, create_link(`https://${encoded}.co`,   {innerHTML: '.co',   className: 'external'}));
			} else {
				add_row_tag(row, create_link(`https://${encoded}`, {button: '‚ÜóÔ∏è Website', className: 'external'}));
			}
		}
		add_row_tag(row, create_link(`../../punycode.js/test/demo.html#u=${encode_uri_component_surrogate_escaped(name)}`, {button: '‚úÖÔ∏è Check'}));
	} catch (err) {
		row.classList.add('invalid');
		add_row_tag(row, create_tag('fail', err));
		if (!replaced) {
			add_alternative_btn(row, name);
		}
	}	
	return row;
	
}

// try some transformations
function add_alternative_btn(row, name) {
	let alt = name;
	try {
		alt = ens_beautify(alt);
	} catch (err) {
	}
	alt = str_from_cps(explode_cp(name).map(cp => {
		if (cp >= 0x660 && cp <= 0x669) {
			return cp + 0x90; // try other arabic digits
		} else {
			return cp;
		}
	}));
	if (alt !== name) {
		add_row_tag(row, create('button', {
			innerText: 'ü•àÔ∏è Try Alternative',
			click() {
				row.replaceWith(create_dns_row(alt, {replaced: true}));
			}
		}));
	}
}

function is_safe_ascii(cp) {
	// same as:
	//return !should_escape(cp) && cp != 0x20;
	return cp >= 0x21 && cp <= 0x7E;
}
function unicode_escape_cp(cp) {
	let hex = hex_cp(cp);
	return hex.length > 4 ? `\\u{${hex}}` : `\\u${hex.padStart(4, '0')}`; // be nice
}
function unicode_escape(s) {
	return explode_cp(s).map(unicode_escape_cp).join('');
}
function entity_escape(s) {
	return explode_cp(s).map(cp => is_safe_ascii(cp) ? String.fromCodePoint(cp) : `&#x${hex_cp(cp)};`).join('');
}
// escape where escape_fn is true (default: non-ascii)
// unicode: use \u-format
function apply_escapes_where(s, escape_fn, unicode) {
	if (!escape_fn) escape_fn = cp => !is_safe_ascii(cp);
	return explode_cp(s).map(cp => {
		return escape_fn(cp) ? unicode ? unicode_escape_cp(cp) : quote_cp(cp) : String.fromCodePoint(cp);
	}).join('');
}
function replace_escapes(s) {
	// match: \u{HEX}, {HEX}, \uXXXX, [0xHEX], [DEC]
	return s.replace(/(?:(?:(?:\\u)?\{([0-9a-f]+)\}|\\u([0-9a-f]{4}))|(?:\[((?:0x[0-9a-f]+)|[0-9]+)\]))/uig, (_, hex1, hex2, num) => {
		try {
			return String.fromCodePoint(num ? parseInt(num) : parseInt(hex1 || hex2, 16)); 
		} catch (err) {
			return 'ÔøΩ';
		}
	});
}
function encode_uri_component_ens_escaped(s) {
	return s.split('.').map(x => {
		try {
			if (ens_normalize(x) === x) {
				return encodeURIComponent(x);
			}
		} catch (err) {
		}
		return `[${labelhash(x).slice(2)}]`; // support unlinkable/unnormalized stuff
	}).join('.');
}
function encode_uri_component_surrogate_escaped(s) {
	return encodeURIComponent(apply_escapes_where(s, is_surrogate));
}
function create_link(url, {button, buttonClass, ...args} = {}) {
	let a = create('a', {
		href: url,
		target: '_blank',
		innerText: url,
		...args
	});
	if (button) {
		a.classList.add('button');
		a.replaceChildren(create('button', {
			innerHTML: button,
			className: buttonClass,
			click(e) {
				e.stopPropagation(); // prevent copy
			}
		}));
	}
	try {
		new URL(url, location0);
	} catch (err) {
		a.classList.add('invalid');
	}
	return a;
}
function create_ens_link(name, innerHTML = '<button>üõ†Ô∏è ENS</button>') {
	try {
		if (ens_normalize(name) === name) {
			return create_link(`https://app.ens.domains/${encode_uri_component_ens_escaped(name)}`, {innerHTML, className: 'ens'});
		}
	} catch (err) {
	}
}
function create_etherscan_address_link(addr, {innerHTML, anchor = '', contract, className, ...a} = {}) {
	if (!innerHTML) {
		innerHTML = addr;
		className = 'addr';
	}
	if (contract && !anchor) anchor = '#readContract';
	return create_link(`${active_chain.explorer}/address/${addr}${anchor}`, {innerHTML, className, ...a});
}
function create_jazz_icon(address) {
	let i = ADDRESS_MAP.get(address);
	if (!i || (resolve_debug && resolve_debug.jazz)) ADDRESS_MAP.set(address, i = ADDRESS_MAP.size + 1);
	return create('span', {innerHTML: i, className: ['jazz', `addr${i}`]});
}

function make_click_copy(el, raw, {hint} = {}) {
	if (el.title) el.title += `\n${CLICK_TO_COPY}`;
	el.dataset.copy = raw;
	el.addEventListener('click', function(e) {
		e.preventDefault();
		e.stopPropagation();
		let {copy, alt, shift} = this.dataset;
		if (e.altKey) {
			copy = alt || explode_cp(copy).map(hex_cp).join(' ');
		} else if (e.shiftKey) {
			copy = shift || '0x' + Array.from(bytes_from_utf8(copy), hex_cp).join('');
		} 
		const cls = 'copied';
		document.querySelectorAll(`.${cls}`).forEach(x => x.classList.remove(cls));
		navigator.clipboard.writeText(copy);
		this.classList.add(cls);
		setTimeout(() => this.classList.remove(cls), 2000);
	});
	return el;
}

function create_copy_btn(raw, {small, value} = {}) {
	let btn = create('button', {className: 'copy'});
	if (small) btn.classList.add('small');
	make_click_copy(btn, raw);
	if (value) {
		btn.title = raw;
	} else {
		let cps = explode_cp(raw);
		btn.title = [
			raw,
			cps.map(hex_cp).join(' '),
			`[ALT] Codepoints (${cps.length})`,
			`[SHIFT] UTF-8 Bytes (${bytes_from_utf8(raw).length})`,
		].join('\n');
	}
	return btn;
}
function reverse_name(addr) {
	return `${addr.slice(2).toLowerCase()}.${REVERSE_DOMAIN}`;
}
function create_reverse_resolve_btn(addr) {
	return create_resolve_btn(reverse_name(addr), '‚Ü©Ô∏è Reverse Name');
}
function create_resolve_btn(name, innerHTML = '‚Ü©Ô∏è Resolve') {
	return create('button', {
		innerHTML,
		title: `Resolve: ${name}`,
		click() {
			input_field.value = name;
			resolve();
		}
	});
}
function create_main_span(text) {
	return create('span', {className: 'maxh'}, create('span', {innerText: text, className: ['main', 'long']}));
}
function upgrade_split_type(info) {
	if (info.type === 'Latin') {
		let cps = info.tokens.flatMap(x => x.is_emoji ? [] : x); // ascii+emoji
		if (cps.every(cp => cp < 0x80)) {
			info.type = 'ASCII';
		}
	} 
	let flat = flatten_tokens(info.tokens);
	info.confusing = determine_confusion(str_from_cps(info.input), flat);
	info.style = determine_style(flat);
}

function flatten_tokens(tokens) {
	return tokens.flatMap(t => t.is_emoji ? String.fromCodePoint(...t) : t);
}

// from https://raffy.antistupid.com/eth/ens-regs.html
function determine_confusion(label, flat) {
	let match;
	if (/[ƒÖ√ßƒô≈ü√¨√≠√Æ√Ø«ê≈Ç]/u.test(label)) {
		return 'Rare';
	} else if (/l\d{2,}/i.test(label) || /\d{2,}l/i.test(label)) {
		return 'Digits+L';
	} else if (has_repeated_run(flat, 10)) {
		return 'Many';
	} else if (match = get_similar_emoji(flat)) {
		return match;
	} else if (/^0x[0-9a-f]{18,}/i.test(label)) {
		return is_address(label) ? 'Address' : 'Address-like';
	}
}
function determine_style(flat) {
	if (flat.length < 2) return;
	let palindrome = true;
	for (let a = 0, b = flat.length - 1; palindrome && a < b; a++, b--) {
		palindrome = flat[a] === flat[b];
	}
	if (palindrome) {
		if (flat.every(x => flat[0] === x)) {
			return `Repeated (${flat.length})`;
		} else {
			return 'Palindrome';
		}
	}
}

function has_repeated_run(flat, thres) {
	let prev, count;
	for (let x of flat) {
		if (prev !== x) {
			prev = x;
			count = 1;
		} else if(++count >= thres) {
			return true;
		}
	}
}

function get_similar_emoji(flat) {
	let set = new Set(flat.filter(x => typeof x === 'string'));
	if (!set.size) return;
	let conflicts = [
		['üá∫üá∏', 'üá∫üá≤'],
		['‚ù§', '‚ô•'],
	];
	for (let [primary, ...similar] of conflicts) {
		let p = set.has(primary);
		let n = similar.reduce((a, x) => a + +set.has(x), 0);
		if (p && n) {
			return `Mixed ${ens_beautify(primary)}`;
		} else if (!p && n) {
			return `Similar ${ens_beautify(primary)}`;
		}
	}
}

function make_normalized(row, name) {
	row.classList.add('normalized');
	let span = create('span', {
		title: 'Normalized Form',
		innerHTML: `‚úÖÔ∏è`,
		className: 'normalized',
	});
	let split = ens_split(name);
	if (split.length > 1 && split[split.length-1].type === 'ASCII') {
		split.pop(); // remove ASCII TLD
	}
	let pure_ascii = split.every(x => x.type === 'ASCII');
	split.forEach(upgrade_split_type);
	if (pure_ascii) {
		span.classList.add('ascii');
		span.innerHTML = 'ASCII'; 
	} else {
		let types = new Set(split.map(x => x.type));
		if (types.has('Latin') && types.has('ASCII')) {
			types.delete('ASCII');
		}
		if (split.some(x => x.emoji)) {
			types.add('Emoji');
		} else {
			types.delete('Emoji');
		}
		span.innerHTML += ` ${[...types].sort().join('+')}`;
	}
	if (split.some(x => x.confusing)) {
		add_row_tag(row, create_tag('confusing', 'Possibly<br>Confusing'));
	}
	add_row_tag(row, span);
	try {
		if (name === ens_beautify(name)) {
			add_row_tag(row, create_pretty_tag());
		}
	} catch (err) {
	}
}

function make_detailed(el) {
	el.classList.add('detailed');
	let hide = !show_details_check.checked;
	if (el.dataset.reversed) hide = !hide;
	el.classList.toggle('hide', hide);
}
function make_locked(row) {
	row.classList.add('locked');
}
function make_contract(row) {
	row.classList.add('contract');
}
function make_exploded(row, name, is_norm, components) {	
	let before = !is_norm;
	let tokens_div = create_exploded(name, before, components);
	let old = row.querySelector('.exploded');
	if (old) {
		old.replaceWith(tokens_div);
	} else {
		row.append(tokens_div);
	}
}

function create_ethmoji_row(tokens, suffix) {
	let row = create_row('Ethmoji');
	row.classList.add('category', 'ethmoji');
	make_detailed(row);
	let tally = new Map();
	let last;
	for (let token of tokens) {
		let form = str_from_cps(token.emoji);
		let rec = tally.get(form);
		if (!rec) {
			rec = {form, count: 0, ...token};
			tally.set(form, rec);
		}
		++rec.count;
	}
	tally = [...tally.values()];
	let formula = create('div', {className: 'formula'});
	for (let rec of tally.values()) {
		formula.append(create_link(`./emoji.html#q=${str_from_cps(rec.cps)}`, {innerHTML: `${rec.form}<sup>${rec.count}</sup>`}));
	}
	row.append(formula);
	let span_grade = create('span');
	let min_repeated;
	if (tally.length == 1) {
		let ncp = tally[0].cps.length;
		let repeat = 1 + Math.max(0, MIN_ETH_LENGTH - ncp);
		if (tally[0].count === repeat) {
			add_row_tag(row, create_tag('fire', repeat == 1 ? 'Single' : 'Shortest'));
		} else {
			min_repeated = str_from_cps(tally[0].cps).repeat(repeat);
		}
	} else {
		add_row_tag(row, `Unique (${tally.length})`);
	}
	if (min_repeated) {
		add_row_tag(row, create_resolve_btn(min_repeated + suffix, '‚Ü©Ô∏è Shortest'));
	}
	return row;
}

function create_digits_row(norm, group, values, negative, suffix) {
	let row = create_row('Integer'); // `${name0} Digits`
	row.classList.add('category', 'integer');
	make_detailed(row);
	let sign = negative ? '-' : '';
	let form = sign + values.join('');
	row.append(create('code', {innerText: form, className: ['main', 'long']}));
	if (values.length == (negative ? 2 : 3)) {
		add_row_tag(row, create_tag('fire', 'Shortest'));
	}
	// let pad = 0;
	// while (values[pad] === 0) pad++;
	// if (pad) {
	// 	add_row_tag(row, `Zero Pad (${pad})`);
	// }
	let btn = create_resolve_btn((negative ? KEYCAP_MINUS : '') + values.map(keycap).join('') + suffix, KEYCAP_NAME);
	btn.disabled = group === KEYCAP_NAME;
	add_row_tag(row, btn);
	for (let [name, digits] of DIGITS_MAP) {
		//if (name0 === name) continue;
		let btn = create_resolve_btn(sign + values.map(x => digits.charAt(x)).join('') + suffix, name);
		btn.disabled = group === name;
		add_row_tag(row, btn);
	}
	return row;
}

async function add_contract_name(row, address, check) {
	let name = RESOLVER_NAMES[address];
	if (active_chain.is_mainnet && name) {
		add_row_tag(row, create_tag('good', name));
	} else if (check && !await is_contract(address)) {
		add_row_tag(row, create_tag('fail', 'Not a Contract'));
	}
}

function add_ensip1_tag(row, input, is_norm) {
	const OLD_NAME = 'ENSIP-1';
	let span = create('span', {className: ['tags', 'ensip1']});
	try {
		let norm0 = eth_ens_namehash.normalize(input);
		let norm;
		try {
			norm = ens_normalize(input);
		} catch (err) {
		}
		let html = OLD_NAME;
		if (norm !== input && norm0 !== norm) { // change + disagree
			html += `: ‚ö†Ô∏è<b>Diff Norm</b>`;
		}
		if (norm0 === input) {
			span.innerHTML = html; // `‚úì ${html}`; //`‚úÖÔ∏è ${html}`;
		} else {
			// norm0 isn't the input:
			// if we agree, we are "not normalized" in ensip-1
			if (norm0 === norm) throw new Error('not normalized');
			// we disagree, there's another possibility
			add_row_tag(row, create_resolve_btn(norm0, `‚ùåÔ∏è ${html}`));
			return;
		}
	} catch (err) {
		span.innerHTML = `‚ùåÔ∏è ${OLD_NAME}`;
		span.title = err.message;
	}
	add_row_tag(row, span);
}

function add_nft_links(row, name, contract, token) {
	add_row_tag(row, create_link(`${active_chain.metadata}/${contract}/${token}`, {button: 'üè∑Ô∏è Metadata', className: 'metadata'}));
	add_row_tag(row, create_link(`${active_chain.explorer}/nft/${contract}/${BigInt(token)}`, {innerHTML: 'Etherscan', className: 'external'}));
	if (active_chain.opensea) {
		add_row_tag(row, create_link(`${active_chain.opensea}${contract}/${BigInt(token)}`, {innerHTML: OPENSEA_NAME, className: 'external'}));
	}
	if (!active_chain.is_mainnet) return;
	try {
		let encoded = encodeURIComponent(name);
		if (encoded.endsWith('.eth')) {
			add_row_tag(row, create_link(`https://${VISION_HOST}/name/${encoded.slice(0, -4)}`, {innerHTML: VISION_NAME, className: 'external'}));
		}
		add_row_tag(row, create_link(`http://predomain.eth.limo/#/domain/${encoded}`, {innerHTML: 'Predomain', className: 'external'}));
	} catch (err) {
	}
}

// https://github.com/adraffy/keccak.js/blob/main/src/utils.js#L96
function bytes_from_utf8(s) {
	let v = [];
	for (let pos = 0, len = s.length; pos < len; ) {
		let cp = s.codePointAt(pos++);
		if (cp < 0x800) {
			if (cp < 0x80) {
				v.push(cp);
			} else {
				v.push(0xC0 | (cp >> 6), 0x80 | (cp & 0x3F));
			}
		} else {
			if (cp < 0x10000) {
				v.push(0xE0 | (cp >> 12), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
			} else {
				v.push(0xF0 | (cp >> 18), 0x80 | ((cp >> 12) & 0x3F), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
				pos++;
			}
		}
	}
	return Uint8Array.from(v);
}
function utf8_from_bytes(v) {
	let cps = [];
	for (let i = 0, n = v.length; i < n; ) {
		let x = v[i++];
		if (x < 0x80) {
			cps.push(x);
		} else if (x < 0xE0) {
			cps.push(((x & 0x1F) << 6) | req_utf8_cont(v, i++));
		} else if (x < 0xF0) {
			cps.push(((x & 0x0F) << 12) | (req_utf8_cont(v, i++) << 6) | req_utf8_cont(v, i++));
		} else {
			cps.push(((x & 0x07) << 18) | (req_utf8_cont(v, i++) << 12) | (req_utf8_cont(v, i++) << 6) | req_utf8_cont(v, i++));
		}
	}
	return str_from_cps(cps);
}
function req_utf8_cont(v, i) {
	let x = v[i];
	if ((x & 0xC0) != 0x80) throw new Error(`malformed utf8 at ${i}: expected continuation`);
	return x & 0x3F;
}
function create_exploded(name, before, components) {
	// tokenize each label separately so we can show major/minor errors
	// flatten non-errors tokens into wrapper
	let split = ens_split(name);
	let wrapper = create('div', {className: ['tokens', 'exploded', 'maxh']});
	let first = true;
	for (let i = 0; i < split.length; i++) {
		if (i > 0) {
			wrapper.append(...dom_from_tokens(ens_tokenize('.')).children); 
		}
		let {input, error} = split[i];
		let label = str_from_cps(input);
		let tokens = dom_from_tokens(ens_tokenize(label), {
			before, 
			tld: i === split.length-1,
			components: components || show_components_check.checked,
			emoji(a, {emoji}) {
				a.href = `./emoji.html#q=${encodeURIComponent(String.fromCodePoint(...emoji))}`;
				a.target = '_blank';
			},
		});
		if (error) {
			tokens.classList.add('error');
			if (first) {
				tokens.classList.add('first');
				first = false;
			}
			wrapper.append(tokens);
		} else {
			wrapper.append(...tokens.children);
		}
	}
	wrapper.dataset.name = name;
	if (before) wrapper.dataset.before = 1;
	if (components) wrapper.dataset.components = 1;
	return wrapper;
}
function update_exploded() {
	for (let x of output_div.querySelectorAll('.exploded')) {
		let tokens_div = create_exploded(x.dataset.name, x.dataset.before, x.dataset.components);
		if (x.dataset.downgraded) {
			apply_downgrade(tokens_div);
		}
		x.replaceWith(tokens_div);
	}
}

function apply_downgrade(tokens_div) {
	tokens_div.dataset.downgraded = '1';
	for (let x of tokens_div.querySelectorAll('.disallowed')) {
		x.classList.add('ignored');
		x.classList.remove('disallowed');
	}
}

function add_reg_exp_tags(row, exp, now) {
	let span = create_tag('reg', `‚úçÔ∏è Registered until ${new Date(exp).toLocaleDateString()}`);
	add_row_tag(row, span);
	if (exp - now < 45 * 86400) {
		add_row_tag(row, create_tag('warn', `Expires in ${format_dur(exp - now)}`));
	} else {
		span.innerHTML += ` (${format_dur(exp - now)})`;
	}
}

function create_dot_eth_button(name) {
	let added = add_dot_eth(name);
	if (added !== name) {
		let btn = create_resolve_btn(added, '<b>.eth</b> <span class="key">shift+enter</span>');
		btn.classList.add('rtrim');
		return btn;
	}
}
function create_elapsed() {
	let now = Date.now();
	let delta = now - resolve_last;
	if (!delta) return; // 0ms is stupid
	resolve_last = now;
	return create_tag('elapsed', format_dur(delta));
}
function create_pretty_tag() {
	return create_tag('clean', PRETTY_NAME, 'Beautified Form');
}
function create_tag(type, value, title) {
	if (!value) return;
	let span = create('span', {className: 'tags', title});
	if (value instanceof Error) {
		value = value.message;
		span.classList.add('long');
	}
	switch (type) {
		case 'star': 
			type = 'attn';
			value = `‚≠êÔ∏è ${value}`;
			break;
		case 'norm':
			span.dataset.reversed = '1';
			make_detailed(span);
			// fallthru
		case 'warn':
			type = 'note';
			value = `‚ö†Ô∏è ${value}`;
			break;
		case 'fire':
			value = `üî•Ô∏è ${value}`;
			break;
		case 'fail': 
			value = `‚ùåÔ∏è ${value}`;
			break;
		case 'stop':
			type = 'fail';
			value = `üõëÔ∏è ${value}`;
			break;
	}
	span.innerHTML = value;
	span.classList.add(type);
	return span;
}
function add_row_tag(row, tag) {
	if (!tag) return;
	if (typeof tag === 'string') {
		tag = create('span', {innerHTML: tag});
	}
	tag.classList.add('tags');
	row.append(tag);
	return tag;
}


function create_namehash_button(name) {
	let node = namehash(name);
	let btn = create('button', {innerHTML: 'üÜîÔ∏è'});
	btn.dataset.reversed = true;
	make_detailed(btn);
	make_click_copy(btn, node);
	let lines = [`Namehash: ${node}`];
	try {
		let hex = ethers.hexlify(dns_encoded_from(name));
		btn.dataset.alt = hex;
		lines.push(`[ALT] DNS-encoded: ${hex}`);
	} catch (err) {
	}
	lines.push('(Click to Copy)');
	btn.title = lines.join('\n');
	return btn;
}
function create_namehash_breakdown(name) {
	let node = namehash(name);
	let div = create('div', {className: 'hash'});
	div.append(create_link(`../../keccak.js/test/demo.html#algo=namehash&s=${encode_uri_component_surrogate_escaped(name)}&escape=1`, {innerText: 'Namehash:'}));
	div.append(create('code', {innerText: node, className: 'long'}));
	div.append(create_copy_btn(node, {small: true, value: true}));
	return div;
}
function create_dns_breakdown(name) {
	let div = create('div', {className: 'hash'});
	div.append(create('b', {innerText: 'DNS-encoded:'}));
	try {
		let v = dns_encoded_from(name);
		let hex = ethers.hexlify(v);
		div.append(create('span', {className: 'bytes', innerText: v.length}), create_copy_btn(hex, {small: true, value: true}));
	} catch (err) {
		div.append(create('span', {innerText: 'üö´Ô∏è', title: err.message}));
	}
	return div;
}
function create_breakdown_row(name, before) {
	let outer = create('div', {className: 'breakdown'});
	if (available) outer.classList.add('available');
	make_detailed(outer);
	outer.append(create_namehash_breakdown(name));
	outer.append(create_dns_breakdown(name));
	let split = ens_split(name);
	for (let i = 0; i < split.length; i++) {
		let info = split[i];
		info.index = i;
		info.cps = before || !info.output ? info.input : info.output;
		info.label = str_from_cps(info.cps);
	}
	for (let info of split) {
		let row = create('div', {className: 'label'});

		//row.append(create_tag('index', info.index+1));

		let span_name = create('span', {className: ['name', 'long']});
		if (info.label) {
			span_name.innerText = info.label;
			row.append(span_name);
			row.append(create_copy_btn(info.label, {small: true}));
		}
		if (info.label) {
			row.append(create_tag('length', info.cps.length));
			if (info.emoji || info.type !== 'ASCII') {
				let v = bytes_from_utf8(info.label);
				row.append(create_tag('bytes', v.length));
			}
		}
		if (info.error) {
			row.classList.add('error');
			row.append(create('span', {innerText: `‚ùåÔ∏è ${info.error.message}`, className: 'error'}));
		} else if (compare_arrays(info.input, info.output)) { // mapped or nfc
			row.classList.add('mapped');
			row.append(create_tag('note', 'Normalizable'));
		} else {
			row.classList.add('valid');
			upgrade_split_type(info);
			if (info.confusing) {
				row.append(create_tag('confusing', info.confusing));
			}
			if (info.type.startsWith('Restricted[')) {
				let script = info.type.slice(11, -1);
				row.append(create_link(`https://www.compart.com/en/unicode/scripts/${script}`, {innerHTML: `‚ö†Ô∏è ${script} (Restricted)`, className: ['tags', 'restricted']}));
			} else if (info.type !== 'Emoji') {
				row.append(create_tag('type', info.type));
			}
			if (info.emoji) {
				row.append(create_tag('emoji', 'Emoji'));
			}
			if (info.style) {
				row.append(create_tag('good', info.style));
			}
		}
		outer.append(row);

		if (info.label) {
			let hash = labelhash(info.label);
			let hash_div = create('div', {className: ['hash', 'minor', 'first']});
			hash_div.append(create_link(`../../keccak.js/test/demo.html#algo=keccak-256&s=${encode_uri_component_surrogate_escaped(info.label)}&escape=1`, {innerHTML: 'Labelhash:'}));
			hash_div.append(create('code', {innerText: hash, className: 'long'}));
			hash_div.append(create_copy_btn(hash, {small: true, value: true}));
			outer.append(hash_div);
			
			let parent = split.slice(info.index + 1).map(x => x.label).join('.');
			if (NFT_DOMAINS.has(parent)) {
				let token = BigInt(hash).toString();
				let token_div = create('div', {className: ['hash', 'minor']});
				token_div.append(create('b', {innerText: 'Token:'}));
				token_div.append(create('code', {innerText: token, className: 'long'}));
				token_div.append(create_copy_btn(token, {small: true, value: true}));
				outer.append(token_div);
			}
		}
	}
	return outer;
}

function create_row(label, waiting) {
	let row = create('div', {className: 'row'});
	if (available) row.classList.add('available');
	if (label) {
		let span = create('span', {className: 'row-label'});
		if (typeof label === 'string') {
			span.innerHTML = label;
		} else {
			span.append(label);
		}
		row.append(span);
	}
	if (waiting) {
		row.append(create('div', {innerHTML: '<div class="spinner"></div>', className: 'temporary'}));
	}
	return row;
}

function remove_temporary(row) {
	for (let x of row.querySelectorAll('.temporary')) {
		x.remove();
	}
}

function trim_trailing_decimal_zeros(s) {
	return s.includes('.') ? s.replace(/\.?0*$/, '') : s;
}
function format_dur(t, n = 1) {
	if (t < 1000) return `${Math.ceil(t)}ms`;
	t /= 1000;
	let unit;
	if (t < 60) {
		unit = 's';
	} else {
		t /= 60;
		if (t < 60) {
			unit = 'm';
		} else {
			t /= 60;
			if (t < 24) {
				unit = 'h';
			} else {
				t /= 24;
				if (t < 365) {
					unit = 'd';
				} else {
					t /= 365;
					unit = 'y';
				}
			}
		}
	}
	return trim_trailing_decimal_zeros(t.toFixed(n)) + unit;
}

function is_working() {
	return resolve_btn.disabled || !registry_contract;
}
function resolve() {
	if (!registry_contract) return;
	if (is_working()) {
		resolve_timer = [0]; // ASAP
		return;
	}
	clearTimeout(resolve_timer);
	resolve_timer = RESOLVE_MODE_IDLE;
	resolve_debug = debug_enabled ? debug_settings : null;
	available = undefined;
	ADDRESS_MAP.clear();
	let input = input_field.value;
	let skip = skip_norm_check.checked;
	// replace marketplace URL with token:XXX
	if (input.includes('://')) {
		try {	
			let url = new URL(input);
			if ([VISION_HOST, 'ens.vision', 'www.ens.vision'].some(x => x === url.host)) {
				// /name/%F0%9F%91%A9%F0%9F%8F%BC%E2%80%8D%F0%9F%A6%BC%E2%80%8D%E2%AC%85
				let v = url.pathname.toLowerCase().split('/').filter(x => x);
				if (v.length >= 2 && v[0] === 'name') {
					input_field.value = input = add_dot_eth(decodeURIComponent(v[1]));
				}
			} else { 
				// generalized handler
				// https://opensea.io/assets/ethereum/0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401/65925476150180752387929572463320899353544457962160224303512375154243473029563
				// https://opensea.io/assets/ethereum/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				// https://www.gem.xyz/asset/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				// https://element.market/assets/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				let v = url.pathname.toLowerCase().split('/').filter(x => x);
				if (v.length >= 2 && /^[a-f0-9]+$/i.test(v[v.length-1])) {
					// TODO: fix this, use ensure_nft() and ensure_wrapper() 
					if (v[v.length-2] === '0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85') {
						input_field.value = input = `token:${v[v.length-1]}`;
					} else if (v[v.length-2] === '0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401') {
						input_field.value = input = `wrapped:${v[v.length-1]}`;
					}
				}
			}
		} catch (err) {
		}
	}
	let match;
	// replace token:XXX with ens subgraph label (or fail)
	if (match = input.match(/^(?:labelhash|token):(0x[a-f0-9]+|[0-9]+)$/i)) {
		let hash = bytes32_from(match[1]);
		resolve_btn.disabled = true;
		return (async() => {
			try {
				//if (!active_chain.is_mainnet) throw new Error(`token: only works on mainnet`);
				let res = await fetch('https://api.thegraph.com/subgraphs/name/ensdomains/ens', {
					method: 'POST',
					body: JSON.stringify({
						query: `{domains(where:{labelhash:"${hash}"}){labelName}}`
					})
				});
				if (!res.ok) throw new Error(`HTTP Error ${r.status}`);
				let {data: {domains}} = await res.json();
				if (!domains.length) throw new Error(`Unknown labelhash preimage: ${hash}`);
				let label = domains[0].labelName;
				if (!label) throw new Error(`Unknown labelhash preimage: ${hash}`);
				let hash0 = labelhash(label);
				if (hash0 !== hash) throw new Error(`Incorrect labelhash preimage: "${label}")\n\nExpected: ${hash}\nComputed: ${hash}`);
				input_field.value = add_dot_eth(label);
				setTimeout(resolve, 0);
			} catch (err) {
				window.alert(err.message);
				stop_resolving();
			}
			resolve_btn.disabled = false;
		})();
	} else if (match = input.match(/^(?:namehash|wrapped):(0x[a-f0-9]+|[0-9]+)$/i)) {
		let hash = bytes32_from(match[1]);
		resolve_btn.disabled = true;
		return (async () => {
			try {
				await ensure_wrapper();
				let v = ethers.getBytes(await wrapper_contract.names(hash));
				if (!v.length) throw new Error(`Unknown namehash preimage: ${hash}`);
				input_field.value = labels_from_dns_encoded(v).join('.');
				setTimeout(resolve, 0);
			} catch (err) {
				window.alert(err.message);
				stop_resolving();
			}
			resolve_btn.disabled = false;
		})();
	}
	// input convenience: expand range
	if (match = input.match(/^range:([0-9a-f]+)\.\.([0-9a-f]+)$/i)) {
		let lo = parseInt(match[1], 16);
		let hi = parseInt(match[2], 16);
		if (hi >= lo) {
			input = str_from_cps(Array(1 + hi - lo).fill().map((_, i) => lo + i));
		}
	}
	// input convenience: HEX HEX HEX => {HEX}{HEX}
	if (/^\s*[0-9a-f]{2,}(\s+[0-9a-f]{2,})+\s*$/i.test(input)) { 
		input = input.trim().split(/\s+/).map(x => `{${x}}`).join('');	
	}
	// input convenience: entities
	input = input.replace(/&#?[0-9a-z]+;/gui, x => {
		entity_span.innerHTML = x;
		return apply_escapes_where(entity_span.innerText);
	});
	input_field.value = input;	
	let name = replace_escapes(input);
	add_recent(name);
	if (!parse() && (!input || !skip)) {
		primary_loader.classList.add('hide');
		return;
	}
	resolve_btn.disabled = true;
	primary_loader.classList.remove('hide');
	const url = get_page_url();
	const t0 = resolve_last = Date.now();
	resolve1(name, skip).then(() => {
		clock_span.innerHTML = format_dur(Date.now() - t0, 2);
		resolve_btn.disabled = false;
		if (Array.isArray(resolve_timer)) {
			setTimeout(resolve, Math.max(0, resolve_timer[0] - Date.now()));
		} else {
			primary_loader.classList.add('hide');
			window.history.replaceState(url.toString(), null, url);
			// TODO: change this to idle() for 2sec or something
			// so it works on errors, but not partial input
		}
	});
}

async function resolve1(input, skip_norm) {
	output_div.innerHTML = '';

	let input_is_address = is_checksum_address(input);
	let input_row;
	let normed_row;
	let reverse_row;
	let name_norm;
	let norm_err;

	if (input_is_address) {
		input_row = create_row('Address');
		input_row.append(create_jazz_icon(input));
		input_row.append(create_etherscan_address_link(input));
		add_row_tag(input_row, create_copy_btn(input, {value: true}));
		add_row_tag(input_row, create_reverse_resolve_btn(input));
		add_owner_links(input_row, input);

		let rev_name = reverse_name(input);

		let rev_details = create('div', {className: ['breakdown']});
		make_detailed(rev_details);
		let rev_div = create('div', {innerHTML: `<b>Reverse Name:</b> <code class="long">${rev_name}</code>`, className: 'hash'});
		rev_div.append(create_copy_btn(rev_name, {small: true, value: true}));
		rev_details.append(rev_div, create_namehash_breakdown(rev_name), create_dns_breakdown(rev_name));
		output_div.append(input_row, rev_details);

		let resolver_row = create_row('Reverse Resolver', true);
		output_div.append(resolver_row);

		if (await is_contract(input)) make_contract(input_row);
		if (should_stop_resolving()) return;

		let resolver, last_err;
		try {
			resolver = await get_resolver(rev_name);
		} catch (err) {	
			last_err = err;
		} 
		if (should_stop_resolving()) return;
		remove_temporary(resolver_row);	
		add_row_tag(resolver_row, create_elapsed());

		if (reverse_registrar === null) {
			try {
				reverse_registrar = await registry_contract.owner(namehash(REVERSE_DOMAIN));
			} catch (err) {
			}
			if (should_stop_resolving()) return;
			if (!reverse_registrar) reverse_registrar = false;
		}
		if (reverse_registrar) {
			add_row_tag(input_row, create_etherscan_address_link(reverse_registrar, {
				contract: true, 
				anchor: '#writeContract#F7',
				innerHTML: '<button class="glow">‚úçÔ∏è Set Name</button>'
			}));
		}

		if (last_err) {
			resolver_row.classList.add('error');
			add_row_tag(resolver_row, create_tag('warn', last_err));
			return;
		} else if (!resolver) {
			add_row_tag(resolver_row, create_tag('stop', 'Primary Not Set'));
			return;
		}
		
		resolver_row.append(create_etherscan_address_link(resolver.target, {contract: true}));
		add_row_tag(resolver_row, create_copy_btn(resolver.target, {value: true}));
		await add_contract_name(resolver_row, resolver.target, !resolver.__wild);
		if (should_stop_resolving()) return;

		reverse_row = normed_row = create_row('Reverse', true);
		output_div.append(reverse_row);
		let primary;
		[{data: primary, error: last_err}] = await fetch_records(resolver, [{type: TYPE_NAME}]);
		if (should_stop_resolving()) return;
		remove_temporary(reverse_row);
		add_row_tag(reverse_row, create_elapsed());
		if (last_err) {
			reverse_row.classList.add('error');
			add_row_tag(reverse_row, create_tag('warn', last_err));
			return;
		} else if (!primary) {
			add_row_tag(reverse_row, create_tag('stop', 'Primary is Null'));
			return;
		}

		make_exploded(reverse_row, primary, false);
		add_row_tag(reverse_row, create_copy_btn(primary));
		add_row_tag(reverse_row, create_ens_link(primary));		
		add_row_tag(reverse_row, create_namehash_button(primary));
		output_div.append(create_breakdown_row(primary, true));
			
		try {
			name_norm = ens_normalize(primary);
		} catch (err) {
			reverse_row.classList.add('error');
			add_row_tag(reverse_row, create_tag('norm', err));
			if (!skip_norm) return;
			name_norm = primary;
			norm_err = err;
		}
		if (!norm_err) {
			if (name_norm === primary) {
				add_row_tag(reverse_row, create_resolve_btn(primary));
				make_normalized(reverse_row, name_norm);
			} else {
				add_row_tag(reverse_row, create_tag('fail', 'Normalized'));
				let row = normed_row = create_row('Normalized Reverse');
				make_exploded(row, name_norm, true);
				add_row_tag(row, create_copy_btn(name_norm));
				add_row_tag(row, create_resolve_btn(name_norm));
				add_row_tag(row, create_namehash_button(name_norm));
				make_normalized(row, name_norm);
				output_div.append(row);
				output_div.append(create_breakdown_row(name_norm));
			}	
		}
	} else {
		
		// the input is a name
		input_row = normed_row = create_row(INPUT_NAME);
		input_row.classList.add('input');
		make_exploded(input_row, input, false);
		add_row_tag(input_row, create_ens_link(input));
		output_div.append(input_row);
		output_div.append(create_breakdown_row(input, true));
		add_row_tag(input_row, create_copy_btn(input));

		if (/^0x[0-9a-f]{40}$/i.test(input)) {
			add_row_tag(input_row, create_resolve_btn(ethers.getAddress(input.toLowerCase()), 'üõ†Ô∏è Fix Checksum'));
		}
		add_row_tag(input_row, create_dot_eth_button(input));
		add_row_tag(input_row, create_namehash_button(input));

		try {
			name_norm = ens_normalize(input);
		} catch (err) {
			input_row.classList.add('error');
			add_row_tag(input_row, create_tag('norm', err));
			if (!skip_norm) return; // i think this is always true
			name_norm = input;
			norm_err = err;
		}	

		if (!norm_err) {
			if (name_norm === input) {
				make_normalized(input_row, name_norm);
				//make_exploded(input_row, input, false); 
			} else  { 
				add_row_tag(input_row, create_tag('fail', 'Normalized'));
				if (skip_norm) {
					name_norm = input;
				} else {
					add_transformed_row(input);
					let row = normed_row = create_row('Normalized');
					make_exploded(row, name_norm, true);
					make_normalized(row, name_norm);
					add_row_tag(row, create_copy_btn(name_norm));
					add_row_tag(row, create_resolve_btn(name_norm));
					add_row_tag(row, create_ens_link(name_norm));
					add_row_tag(row, create_namehash_button(name_norm));
					add_ensip1_tag(row, name_norm, true);
					output_div.append(row, create_breakdown_row(name_norm));
				}
			}
		}
		add_ensip1_tag(input_row, input);
	}

	let sep_pos = name_norm.indexOf('.');
	if (sep_pos == -1) sep_pos = name_norm.length;
	if (sep_pos > 0) {
		let prefix = name_norm.slice(0, sep_pos);
		let suffix = name_norm.slice(sep_pos); 
		let tokens = ens_tokenize(prefix);
		if (tokens.every(t => t.type === 'emoji')) {
			input_row.after(create_ethmoji_row(tokens, suffix));
			let negative = str_from_cps(tokens[0].emoji) == KEYCAP_MINUS;
			if (negative) tokens = tokens.slice(1);
			let values = tokens.map(x => x.emoji[0] - 0x30);
			if (values.every(x => x >= 0 && x < 10)) {
				input_row.after(create_digits_row(name_norm, KEYCAP_NAME, values, negative, suffix));
			}
		} else {
			let negative = prefix.startsWith('-');
			if (negative) prefix = prefix.slice(1);
			if (prefix) {
				let cps = explode_cp(prefix);
				let digits = cps.map(cp => DIGIT_MAP.get(cp));
				if (digits.every(x => x)) {
					let values = digits.map(x => x.i);
					let name0 = digits[0].name;
					if (digits.every(x => x.name === name0)) {
						input_row.after(create_digits_row(name_norm, name0, values, negative, suffix));
					} else {
						let first = digits[0].mixed;
						if (first && digits.every(x => x.mixed == first)) {
							let row = create_digits_row(name_norm, 'Arabic', values, negative, suffix);
							add_row_tag(row, create_tag('warn', 'Mixed Digits'));
							input_row.after(row);
						} else {
							let row = create_digits_row(name_norm, 'Numeric', values, negative, suffix);
							add_row_tag(row, create_tag('warn', 'Multiple Scripts'));
							input_row.after(row);
						}
					}
				}
			}
		}
	}

	if (name_norm) {
		let form, pretty;
		try {
			form = ens_beautify(name_norm);	
			pretty = true;
		} catch (err) {
		}
		if (skip_norm && form !== name_norm) {
			form = name_norm;
			pretty = false;
		}
		let row = create_row(pretty ? 'Beautified' : 'Unnormalized');
		if (pretty) row.classList.add('pretty');
		row.append(create_main_span(form));
		add_row_tag(row, create_copy_btn(form));
		if (input === form) { 
			add_row_tag(row, skip_norm ? SAME_AS_INPUT : create_tag('good', SAME_AS_INPUT));
		} else if (name_norm === form) {
			add_row_tag(row, create_tag('good', SAME_AS_NORM));
		} else if (pretty) {
			add_row_tag(row, create_resolve_btn(form));
			add_row_tag(row, create_pretty_tag());
		}
		add_ensip1_tag(row, form);
		output_div.append(row);
	}

	output_div.append(create_dns_row(name_norm));

	// at this point, we have a name
	// lookup the name
	let resolver, resolver_err;
	let resolver_row = create_row('Resolver', true);
	output_div.append(resolver_row);
	try {
		resolver = await get_resolver(name_norm);
	} catch (err) {
		resolver_err = err;
	}
	if (should_stop_resolving()) return;
	remove_temporary(resolver_row);	
	add_row_tag(resolver_row, create_elapsed());
	
	if (resolver_err) {
		resolver_row.classList.add('error');
		add_row_tag(resolver_row, create_tag('warn', resolver_err));
	} else if (resolver) { 
		//add_avatar(normed_row, resolver); 
		resolver_row.append(create_etherscan_address_link(resolver.target, {contract: true}));
		add_row_tag(resolver_row, create_copy_btn(resolver.target, {value: true}));
		await add_contract_name(resolver_row, resolver.target, !resolver.__wild);
		if (should_stop_resolving()) return;
		if (resolver.__wild) {
			add_row_tag(resolver_row, create_tag('special', 'Wildcard'));
			if (resolver.__dropped) {
				add_row_tag(resolver_row, create_resolve_btn(resolver.__basename, `‚Ü©Ô∏è ${resolver.__basename}`));
			} else {
				add_row_tag(resolver_row, 'Basename');
			}
		}
	} else {
		add_row_tag(resolver_row, create_tag('warn', `Not Set`));	
	}

	let parent_domain = name_norm.slice(sep_pos+1);
	let nft_backed = NFT_DOMAINS.has(name_norm.slice(sep_pos+1));
	let nft_contract;
	let nft_token;

	let avail_row = create_row('Availability', true);
	if (parent_domain === 'eth') {
		let label = name_norm.slice(0, sep_pos);
		nft_token = labelhash(label);
		let avail_err;
		let expiry;
		let len = Array.from(label).length;
		let premium;
		output_div.append(avail_row);
		try {
			await ensure_eth_nft();
			if (should_stop_resolving()) return;
			nft_contract = eth_nft_contract;
			if (len >= MIN_ETH_LENGTH) {
				available = await eth_nft_contract.available(nft_token);
				if (should_stop_resolving()) return;
				expiry = Number(await eth_nft_contract.nameExpires(nft_token));
				if (available) {
					if (should_stop_resolving()) return;
					premium = await price_oracle_contract.premium(label, expiry, 0);
				}
			}
		} catch (err) {
			avail_err = err;
		}
		remove_temporary(avail_row);
		if (should_stop_resolving()) return;
		add_row_tag(avail_row, create_elapsed()); 
		add_row_tag(avail_row, create_tag('length', len));

		if (avail_err) {
			avail_row.classList.add('error');
			add_row_tag(avail_row, create_tag('warn', avail_err));
		} else if (available === undefined) {
			add_row_tag(avail_row, create_tag('fail', `Too Short`));
			let padded = Array(1 + Math.max(0, MIN_ETH_LENGTH - len)).fill(label).join('');
			add_row_tag(avail_row, create_resolve_btn(add_dot_eth(padded), '‚Ü©Ô∏è Repeat until 3+'));
		} else if (available) {
			add_row_tag(avail_row, create_ens_link(name_norm, '<button>üëåÔ∏è Available to Register</button>'));
			let ether = parseFloat(ethers.formatEther(premium));
			if (ether) {
				add_row_tag(avail_row, create_tag('warn', `${ether.toFixed(ether < 1 ? 4 : 2)}Œû Premium`));
			}
			//add_row_tag(avail_row, create_typed_tag('fire', 'Available'));
			//add_row_tag(avail_row, create_ens_link(name_norm, {title: 'Register'}));
		} else {
			let exp = expiry * 1000;
			let end = exp + eth_nft_contract.__grace_period;
			let now = Date.now();
			if (now >= exp && now <= end) {
				add_row_tag(avail_row, create_tag('warn', `Grace period (${format_dur(eth_nft_contract.__grace_period)}) ends in ${format_dur(end - now)}`));
			} else {
				add_reg_exp_tags(avail_row, exp, now);
			}
		}
		if (nft_contract) {
			avail_row.querySelector('.row-label').title = `Grace: ${format_dur(nft_contract.__grace_period)}\nPremium: ${format_dur(price_oracle_contract.__premium_period)}`;
		}
	} else if (nft_backed) {
		let label = name_norm.slice(0, sep_pos);
		nft_token = labelhash(label);
		let avail_url;
		let avail_err;
		output_div.append(avail_row);
		try {
			let address = await registry_contract.owner(namehash(parent_domain));
			if (should_stop_resolving()) return;
			if (is_null_hex(address)) throw new Error('Missing backing contract');
			nft_contract = new ethers.Contract(address, [
				'function available(uint256 id) external view returns(bool)',
				'function ownerOf(uint256 id) external view returns (address)',
			], active_provider);
			available = await nft_contract.available(nft_token); //.catch(() => {});
			if (active_chain.is_mainnet && parent_domain === 'art') {
				avail_url = `https://protocol.art/api/art-tokens?exact=${encodeURIComponent(label)}`;
				if (available) {
					try {
						let res = await fetch(avail_url);
						let {Items} = await res.json();
						available = !Items.length;
					} catch (ignored) {
					}
				}
			}
		} catch (err) {
			avail_err = err;
		}
		remove_temporary(avail_row);
		if (should_stop_resolving()) return;
		add_row_tag(avail_row, create_elapsed()); 
		add_row_tag(avail_row, create_tag('length', Array.from(label).length));
		if (nft_contract) {
			let old = avail_row.querySelector('.row-label');
			old.replaceChildren(create_etherscan_address_link(nft_contract.target, {innerHTML: old.innerHTML, contract: true}));
		}
		if (avail_err) {
			avail_row.classList.add('error');
			add_row_tag(avail_row, create_tag('warn', avail_err));
		} else {
			add_row_tag(avail_row, create_tag(available ? 'good' : 'fail', 'Available'));
			if (avail_url) {
				add_row_tag(avail_row, create_link(avail_url, {button: 'üîçÔ∏è Details', className: 'external'}));
			}
		}
	}
	// get the owner
	let is_wrapped, owner, nft_owner;
	if ((!resolver || !resolver.__dropped) && (!nft_backed || available !== undefined)) { 
		let node = namehash(name_norm);
		let wrapped_row = create_row('Wrapper', true);
		let unwrappable;
		try {
			dns_encoded_from(name_norm);
		} catch (err) {
			unwrappable = true;
		}
		if (!available) {
			output_div.append(wrapped_row);
			let wrapped_err;
			try {
				await ensure_wrapper();
				if (should_stop_resolving()) return;
				if (!unwrappable) {
					is_wrapped = await wrapper_contract.isWrapped(node);
				}
			} catch (err) {
				wrapped_err = err;
			}
			if (should_stop_resolving()) return;
			if (wrapped_err) {
				wrapped_row.classList.add('error');
				add_row_tag(wrapped_row, create_tag('warn', wrapped_err));
			} else if (unwrappable) {
				add_row_tag(wrapped_row, create_tag('warn', 'Unwrappable'));
			} else if (!is_wrapped) {
				add_row_tag(wrapped_row, 'Unwrapped');
			}
			if (wrapper_contract) {
				let old = wrapped_row.querySelector('.row-label');
				old.replaceChildren(create_etherscan_address_link(wrapper_contract.target, {innerHTML: old.innerHTML, contract: true}));
			}
			if (is_wrapped) {
				add_nft_links(normed_row, name_norm, wrapper_contract.target, node);
			} else if (nft_contract) {
				add_nft_links(normed_row, name_norm, nft_contract.target, nft_token);
			}
		} else if (unwrappable) {
			output_div.append(wrapped_row);
			add_row_tag(wrapped_row, create_tag('stop', 'Unwrappable'));
		}
		remove_temporary(wrapped_row);
		add_row_tag(wrapped_row, create_elapsed());

		// there doesn't seem to be an "owner"
		//owner = await resolver._fetch('0x02571be3'); // owner(bytes32)
		//owner = await resolver._fetch('0x38a699a4'); // exists(bytes32)
		//owner = await resolver._fetch('0x7dd56411'); // ownerOf(bytes32)
		let owner_row = create_row(available ? 'Previous Owner' : 'Owner', true);
		let owner_err;
		let checked_nft;
		output_div.append(owner_row);
		try {
			if (is_wrapped) {
				let data = await wrapper_contract.getData(node);
				if (should_stop_resolving()) return;
				owner = data.owner;
				let now = Date.now();
				let exp = Number(data.expiry) * 1000;
				let fuses = Number(data.fuses);
				if (resolve_debug && resolve_debug.fuses) fuses = 0x7FFFF;
				if (fuses & 0x10000) { // PARENT_CANNOT_CONTROL 
					if (fuses & 0x00001) { // CANNOT_UNWRAP 
						add_row_tag(wrapped_row, create_tag('good', 'üîíÔ∏è Locked')); 
					} else {
						add_row_tag(wrapped_row, create_tag('good', 'üïäÔ∏è Emancipated'));
					}
					if (!(fuses & 0x20000)) { // !IS_DOT_ETH 
						add_reg_exp_tags(wrapped_row, exp, now); // note: this includes grace for .eth subs
						if (fuses & 0x40000) { // CAN_EXTEND_EXPIRY => no approval needed
							add_row_tag(wrapped_row, create_tag('warn', 'Public Extendable'));
						} else {
							add_row_tag(wrapped_row, create_tag('warn', 'Extension requires approval'));
						}
					}
				} else {
					add_row_tag(wrapped_row, create_tag('good', 'üéÅÔ∏è Wrapped')); // ‚ôæÔ∏è
				}
				if (fuses & 0x00002) add_row_tag(wrapped_row, 'üö´Ô∏è Burn Fuses');
				if (fuses & 0x00004) {
					add_row_tag(wrapped_row, 'üö´Ô∏è Transfer');
					make_locked(owner_row);
				}
				if (fuses & 0x00008) {
					add_row_tag(wrapped_row, 'üö´Ô∏è Set Resolver');
					make_locked(resolver_row);
				}
				if (fuses & 0x00010) add_row_tag(wrapped_row, 'üö´Ô∏è Set TTL');
				if (fuses & 0x00020) add_row_tag(wrapped_row, 'üö´Ô∏è Subdomain');
				if (fuses & 0x00040) add_row_tag(wrapped_row, 'üö´Ô∏è Approve');
			} else {
				owner = await registry_contract.owner(node);
				if (should_stop_resolving()) return;
				if (is_null_hex(owner)) owner = false;
				if (!owner && nft_contract) {
					checked_nft = true;
					owner = await nft_contract.ownerOf(nft_token).catch(() => {});
					if (is_null_hex(owner)) owner = false;
				}
			}
		} catch (err) {
			owner_err = err;
		}
		if (should_stop_resolving()) return;
		if (await is_contract(owner)) make_contract(owner_row);
		remove_temporary(owner_row);
		if (should_stop_resolving()) return;
		add_row_tag(owner_row, create_elapsed());
		if (owner_err) {
			owner_row.classList.add('error');
			owner_row.append(create_tag('warn', owner_err));
		} else if (!owner) {
			if (available) {
				add_row_tag(owner_row, create_tag('reg', 'üåªÔ∏è Not Set'));
			} else {
				add_row_tag(owner_row, create_tag('warn', 'Not Set'));
			}
		} else {
			owner_row.append(create_etherscan_address_link(owner));
			add_row_tag(owner_row, create_copy_btn(owner, {value: true}));
			// if the input was an address, we can validate
			if (input_is_address) {
				add_row_tag(reverse_row, create_tag(owner === input ? 'good' : 'fail', 'Owned'));
				if (owner === input) {
					add_row_tag(owner_row, SAME_AS_INPUT);
				}
			}
			if (owner !== input) {
				add_row_tag(owner_row, create_resolve_btn(owner));
				add_owner_links(owner_row, owner);
			}
			if (active_chain.is_mainnet && parent_domain === 'art') {
				add_row_tag(avail_row, create_link(`https://protocol.art/account/${owner}`, {button: 'üõ†Ô∏è Configure', className: 'external'}));
			}
			if (!is_wrapped && !available && !checked_nft && nft_contract) {
				let nft_row = create_row(create_etherscan_address_link(nft_contract.target, {innerHTML: NFT_OWNER_NAME, contract: true}), true);
				nft_row.classList.add('nft');
				output_div.append(nft_row);
				try {
					await ensure_eth_nft();
					nft_owner = await nft_contract.ownerOf(nft_token);
					if (is_null_hex(nft_owner)) nft_owner = false;
				} catch (err) {
				}
				if (should_stop_resolving()) return;
				if (nft_owner && nft_owner !== owner) {
					owner_row.querySelector('.row-label').innerHTML = MANAGER_NAME;
					owner_row.insertAdjacentElement('beforebegin', nft_row); // move up
					nft_row.append(create_jazz_icon(nft_owner));
					let a = create_etherscan_address_link(nft_owner);
					nft_row.append(a);
					add_row_tag(nft_row, create_copy_btn(nft_owner, {value: true}));
					try {
						let norm = await get_safe_primary(nft_owner, owner);
						if (norm.endsWith('.' + name_norm)) { // proper subdomain
							nft_owner = norm; // swap
							let sub = norm.slice(0, -(name_norm.length + 1));
							a.innerHTML = `<b>${ens_beautify(sub)}</b>.${ens_beautify(name_norm)}`;
							add_row_tag(nft_row, create_tag('good', 'Subdomain'));
						} else {
							a.innerHTML = ens_beautify(norm);
							//add_row_tag(nft_row, create_typed_tag('good', 'Owned'));
						}
					} catch (err) {
					}
					if (nft_owner !== input) {
						add_row_tag(nft_row, create_resolve_btn(nft_owner));
					}
					add_owner_links(nft_row, nft_owner);
					add_row_tag(nft_row, create_elapsed());
					remove_temporary(nft_row);
				} else {
					nft_row.remove();
				}
			}
			owner_row.append(create_jazz_icon(owner));
		}
	}
	if (should_stop_resolving()) return;
	if (resolver && !NOT_IFACE_RESOLVER.has(resolver.target)) {
		let row = create_row(create_link('https://docs.ens.domains/contract-api-reference/.eth-permanent-registrar#discovery', {innerHTML: 'Interfaces'}), true);
		output_div.append(row);	
		// https://docs.ens.domains/contract-api-reference/.eth-permanent-registrar	
		const TITLE_WRAPPER = '<b>Wrapper</b> ERC-1155';
		let interfaces = [
			//{iface: IFACE_ETH_NFT, name: 'NFT'},  
			{iface: '0x019a38fe', title: TITLE_WRAPPER},
			{iface: IFACE_ETH_CONTROLLER, title: '<b>Controller</b>'},
			{iface: '0x018fac06', title: '<b>Old Controller</b>'},
			{iface: '0x6ccb2df4', name: '<b>NFT</b> ERC-721'},
			{iface: '0x7ba18ba1', title: '<b>Migration</b>'},
		];
		let discovered = new Set();
		function add_iface(html, addr) {
			if (is_null_hex(addr)) return;
			if (discovered.has(addr)) return;
			discovered.add(addr);
			html += ` <code class="prefix">${addr.slice(0, 6)}</code>`;
			add_row_tag(row, create_etherscan_address_link(addr, {innerHTML: html, contract: true, className: 'iface'}));
		}
		try {
			// https://github.com/ensdomains/ens-contracts/blob/dev/contracts/resolvers/profiles/IInterfaceResolver.sol
			if (!await resolver.supportsInterface('0x124a319c')) {
				throw new Error('not EIP-165');
			}
			for (let {iface, title} of interfaces) {
				if (should_stop_resolving()) return;
				let addr = await resolver.__get_interface(iface);
				if (is_null_hex(addr)) continue;
				add_iface(`${title} <code>${iface.slice(2)}</code>`, addr);
				if (iface === IFACE_ETH_CONTROLLER) {
					let controller = contract_for_controller(addr);
					let oracle = await controller.prices().catch(() => {});
					if (!is_null_hex(oracle)) {
						add_iface('<b>Price Oracle</b>', oracle);
						add_iface('<b>USD Oracle</b>', await contract_for_price_oracle(oracle).usdOracle().catch(() => {}));
					}
					add_iface(TITLE_WRAPPER, await controller.nameWrapper().catch(() => {}));
					//add_iface('DAO Wallet', await contract.owner().catch(() => ''));
				}
			}
		} catch (err) {
			if (discovered.size) {
				add_row_tag(row, create_tag('warn', err));
			}
		}
		if (discovered.size) {
			remove_temporary(row);
			add_row_tag(row, create_elapsed()); 
		} else {
			row.remove();
			NOT_IFACE_RESOLVER.add(resolver.target);
		}
	}

	// add address
	let address;
	if (resolver) {
		let address_err;
		let address_row = create_row('ETH Address', true);
		address_row.classList.add('addr');
		output_div.append(address_row);	
		try {
			address = await fetch_addr60(resolver);
		} catch (err) {
			address_err = err;
			console.log(err);
		}
		if (should_stop_resolving()) return;
		if (await is_contract(address)) make_contract(address_row);
		if (should_stop_resolving()) return;
		if (address_err) {
			address_row.classList.add('error');
			add_row_tag(address_row, create_tag('warn', address_err));
		} else if (!address) {
			add_row_tag(address_row, create_tag('warn', 'Not Set'));
		} else {
			address_row.append(create_jazz_icon(address));
			address_row.append(create_etherscan_address_link(address));
			address_row.append(create_copy_btn(address, {value: true}));
			if (input_is_address) {
				if (address === input) {
					add_row_tag(input_row, create_tag('fire', 'Primary'));
					add_row_tag(address_row, SAME_AS_INPUT);
				} else if (address) {
					add_row_tag(address_row, create_resolve_btn(address));
					add_row_tag(address_row, create_tag('warn', 'Different from Owner'));	
				}
			// } else if (owner !== address && nft_owner !== address) {
			// 	add_row_tag(address_row, create_resolve_btn(address));
			// 	if (owner) {
			// 		add_row_tag(address_row, create_typed_tag('fail', 'Owner'));	
			// 	}
			// 	add_owner_links(address_row, address); 
			} else if (owner === address) {
				if (nft_owner && nft_owner !== address) {
					add_row_tag(address_row, create_tag('good', `Same as ${MANAGER_NAME}`));	
				} else {
					add_row_tag(address_row, create_tag('good', 'Same as Owner'));
				}
			} else if (nft_owner === address) {
				add_row_tag(address_row, create_tag('good', `Same as ${NFT_OWNER_NAME}`));
			} else {
				add_row_tag(address_row, create_resolve_btn(address));
				if (owner) {
					add_row_tag(address_row, create_tag('fail', 'Owner'));	
				}
				add_owner_links(address_row, address);
			}
		}
		remove_temporary(address_row);
		add_row_tag(address_row, create_elapsed());	

		if (show_records_check.checked) {
			let records_row = create_row(create_link('https://docs.ens.domains/contract-api-reference/publicresolver', {innerHTML: 'Records'}), true);
			records_row.classList.add('records');
			//make_available(records_row);
			output_div.append(records_row);	
			let old = records_row.childElementCount;
			if (resolver.__unreachable) {
				add_row_tag(records_row, create_tag('fail', 'Unreachable'));
			} else {
				let records = RECORDS;
				if (name_norm.endsWith(REVERSE_DOMAIN)) {
					records = [{type: TYPE_NAME}];
				}
				if (resolve_debug && Array.isArray(resolve_debug.records)) {
					records = records.slice();
					for (let rec of resolve_debug.records) {
						try {
							records.push(prepare_record({...rec}));
						} catch (err) {
						}
					}
				}
				for (let {rec, data, error} of await fetch_records(resolver, records)) {
					if (error) continue;
					//if (error) return create_typed_tag('warn', error);
					let a = create('a', {className: 'record', target: '_blank'});
					switch (rec.type) {
						case TYPE_NAME: {
							if (is_null_hex(data)) continue;
							a.innerHTML =`<b>name</b>`;
							make_click_copy(a, data);							
							a.append(dom_from_tokens(ens_tokenize(data), {components: false, before: true, tld: true}));
							try {
								if (ens_beautify(data) === data) {
									a.append(create_pretty_tag());
								}
							} catch (err) {
								a.append(create_tag('fail', err));
							}
							a.append(create_resolve_btn(data));
							a.classList.add('rtrim');
							break;
						}
						// https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/profiles/IAddressResolver.sol
						// https://docs.ens.domains/ens-improvement-proposals/ensip-9-multichain-address-resolution
						case TYPE_ADDR: {
							if (is_null_hex(data)) continue;
							a.classList.add('rtrim');
							a.innerHTML = rec.icon || `<b>${rec.name}</b>`;
							try {
								let v = ethers.getBytes(data);
								let lines = [`CoinType: ${format_dec_hex(rec.coin)}`];
								let address;
								if (rec.evm) {
									address = ethers.getAddress(data);
									lines.push(`Network: ${format_dec_hex(rec.evm)}`);
								} else if (rec.btc) {
									address = format_btc_address(v, rec.btc);
								} else if (rec.bech32) {
									address = new Bech32(rec.bech32.hrp, convert(v, 8, 5, true), rec.bech32.type).toString();
								} else if (rec.base58) {
									address = Base58BTC.encode(v);
								} else {
									throw new Error('nyi');
								}
								lines.unshift(address);
								a.append(create('span', {innerHTML: address, className: ['addr', 'long']}));
								a.href = rec.url(encodeURIComponent(address));
								//if (rec.testnet) a.classList.add('testnet');
								a.append(create_copy_btn(address, {value: true}));
								a.title = lines.join('\n');
							} catch (err) {
								a.append(create_tag('fail', err));
								a.append(create_copy_btn(data));
							}
							break;
						}
						// https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/profiles/ITextResolver.sol
						case TYPE_TEXT: {
							data = data.trim();
							if (!data) continue;
							a.innerHTML = rec.icon || `<b>${rec.key}</b>`;
							let fixed = data;
							if (rec.url) {
								let prefix = rec.url('');
								if (data.startsWith(prefix)) {
									fixed = fixed.slice(prefix.length);
								}
							}
							if (rec.fix) {
								fixed = rec.fix(fixed);
							}
							if (fixed !== data) {
								a.append(create('span', {
									className: ['tags', 'changed'],
									innerHTML: '‚ö†Ô∏è Changed', 
									title: `Original: ${data}\nChange: ${fixed}`}));
								data = fixed;
							}
							let text = rec.format ? rec.format(data) : data;
							if (text) {
								a.append(create('span', {innerText: text, className: text.length > 32 ? 'long' : null}));
							}
							if (rec.url) {
								a.href = rec.url(data);
								a.classList.add('rtrim');
								a.append(create_copy_btn(data));
							} else {
								make_click_copy(a, data);
							}
							a.title = `${data}\nText: ${rec.key}`;
							if (rec.class) {
								a.classList.add(rec.class);
							}
							if (rec.key === 'avatar') {
								let spinner = create('div', {className: ['avatar', 'spinner']});
								if (!show_records_check.checked) spinner.classList.add('hide');
								normed_row.append(spinner);
								fetch_resource_url(data, owner).then(avatar => {
									if (!normed_row.isConnected) return;
									if (avatar.error) {
										a.append(create('span', {
											className: ['tags', 'changed'], 
											innerHTML: '‚ùåÔ∏è Failed', 
											title: avatar.error
										}));
										spinner.replaceWith(create('span', {className: 'avatar', innerText: '‚ùåÔ∏è'}));
									} else {
										a.append(create('span', {className: ['tags', 'minor'], innerText: avatar.type}));
										if (avatar.fixed) {
											a.append(create('span', {
												className: ['tags', 'changed'],
												innerHTML: '‚ö†Ô∏è Changed', 
												title: avatar.fixed
											}));
										}
										let img = new Image();
										img.src = avatar.url;
										spinner.replaceWith(create('a', {className: 'avatar', target: '_blank', href: avatar.url}, img));
									}
									a.classList.add('rtrim');
								});
							}
							break;
						}
						// https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/profiles/IPubkeyResolver.sol
						case TYPE_PUBKEY: {
							let [x, y] = data;
							if (is_null_hex(x)) continue;
							a.innerHTML = `<b>pubkey</b>`;
							a.classList.add('rtrim');
							a.append(make_click_copy(create('button', {innerText: 'x', title: x}), x));
							a.append(make_click_copy(create('button', {innerText: 'y', title: y}), y));
							break;
						}
						// https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/profiles/IContentHashResolver.sol
						// https://docs.ens.domains/ens-improvement-proposals/ensip-7-contenthash-field
						// https://github.com/multiformats/multicodec/blob/master/table.csv
						case TYPE_CONTENTHASH: { 
							if (is_null_hex(data))  continue;
							a.innerHTML = `<b>${rec.type}</b>`;
							a.classList.add('rtrim');
							let buf = ethers.getBytes(data);
							let rep, url;
							try {
								let [proto, pos] = uvarint.read(buf);
								let cid;
								buf = buf.subarray(pos);
								switch (proto) {
									//case 0xE2: // IPLD
									case 0xE3: { // IPFS
										cid = CID.from(buf);
										rep = cid.toString();
										url = `ipfs://${rep}`;
										a.append(create_link(url_from_ipfs_path(rep), {button: 'üÜîÔ∏è IPFS'}));
										break;
									}
									case 0xE5: { // IPNS
										cid = CID.from(buf);
										rep = cid.toString('k'); // base36 for urls
										url = `ipns://${rep}`;
										a.append(create_link(`https://${rep}.ipfs2.eth.limo/`, {button: '‚ÜóÔ∏è IPNS'}));
										break;
									}
									case 0xE4: { // Swarm
										// https://docs.ethswarm.org/docs/develop/access-the-swarm/upload-and-download
										// https://gateway.ethswarm.org/access/
										cid = CID.from(buf);
										rep = cid.toString();
										a.append(create_link(`https://${rep}.bzz.link/`, {button: 'Swarm'}));
										url = `bzz://${rep}`;
										break;
									}
									//case 0xE8: // DNSLink 
									case 0x1BC: { // onion v2
										// https://support.torproject.org/onionservices/v2-deprecation/
										rep = Base32.encode(buf);
										if (rep.length !== 16) throw new Error('bad length');
										url = `http://${rep}.onion`;
										a.append(create_link(`http://${rep}.onion.to/`, {button: 'Onion'}));
										a.append(create_tag('warn', 'Deprecated'));
										break;
									}
									case 0x1BD: { // onion v3
										// https://www.tor2web.org/
										rep = Base32.encode(buf);
										if (rep.length !== 56) throw new Error('bad length');
										url = `http://${rep}.onion`;
										a.append(create_link(`http://${rep}.onion.to/`, {button: 'Onion'}));
										a.append(create('span', {className: ['tags', 'minor'], innerText: 'v3'}));
										break;
									}
									case 0xB19910: { // skylink
										// https://support.skynetlabs.com/key-concepts/skylinks
										rep = Base64URL.encode(buf);
										if (rep.length != 46) throw new Error('bad length');
										url = `sia://${rep}`;
										a.append(create_link(`https://siasky.net/${rep}`, {button: 'Skylink'}));
										break;
									}
									case 0xB29910: { // arweave
										// https://docs.arweave.org/developers/arweave-node-server/http-api
										if (buf.length != 32) throw new Error('not sha256');
										rep = Base64URL.encode(buf);
										url = `ar://${rep}`;
										a.append(create_link(`https://arweave.net/${rep}`, {button: 'Arweave'}));
										a.append(create_link(`https://viewblock.io/arweave/tx/${rep}`, {button: 'üîçÔ∏è Inspect'}));
										break;
									}
									default: throw new Error(`unknown protocol: ${proto}`);
								}
								make_click_copy(a, url);
								let lines = [url, `Protocol: ${format_dec_hex(proto)}`];
								if (cid) {
									lines.push(`CID: Version: ${format_dec_hex(cid.version)} / Codec: ${format_dec_hex(cid.codec)} / Bytes: ${buf.length}`);
									lines.push(`Hash: Codec: ${format_dec_hex(cid.hash.codec)} / Bytes: ${cid.hash.data.length}`);
									a.append(create_link(`https://cid.ipfs.tech/#${cid}`, {button: 'üîçÔ∏è Inspect'}));
								}
								lines.push(`Raw: ${data}`, `[ALT] Copy Raw`);
								a.dataset.alt = data;
								a.title = lines.join('\n');
								// upgrade the decentralized website link
								$('.row.dns').replaceWith(create_dns_row(name_norm, {replaced: false, contenthash: rep}));
							} catch (err) {
								a.append(create_tag('fail', err));
								make_click_copy(a, data, {hint: true});
							}
							a.append(create_link(`../../cid.js/test/demo.html#${data}`, {button: '‚úÖÔ∏è Check'}));
							break;
						}
					}
					records_row.append(a);
				}
				if (records_row.childElementCount === old) {
					add_row_tag(records_row, 'None');
				}
				if (resolver.__multicall) {
					add_row_tag(records_row, create_tag('good', `Multicall (${resolver.__multicall})`));
				}
			}
			if (should_stop_resolving()) return;
			remove_temporary(records_row);
			add_row_tag(records_row, create_elapsed());	
		}
	}

	if (input_is_address || !address) return; // nothing more to do

	// lookup primary from eth address 
	let primary, primary_err;
	let primary_row = create_row('Primary', true);	
	let rev_resolver;
	output_div.append(primary_row);
	//primary_row.append(create_jazz_icon(address)); // only true in the forward direction
	try {
		rev_resolver = await get_resolver(reverse_name(address));
		if (rev_resolver) {
			if (should_stop_resolving()) return;
			let [{data, error}] = await fetch_records(rev_resolver, [{type: TYPE_NAME}]);
			if (error) throw error;
			if (resolve_debug && resolve_debug.primary) data = data.toUpperCase();
			primary = data;
		}
	} catch (err) {
		primary_err = err;
	}
	if (should_stop_resolving()) return;
	remove_temporary(primary_row);
	add_row_tag(primary_row, create_elapsed());
	//make_available(primary_row);
	if (primary_err) {
		primary_row.classList.add('error');
		add_row_tag(primary_row, create_tag('warn', primary_err));
		return;
	}
	if (!primary) {
		add_row_tag(primary_row, create_tag('warn', 'Not Set'));
		return;
	}
	make_exploded(primary_row, primary, false);	

	// ü§ΩüèΩ‚Äç‚ôÄ.eth
	// lets check if it's normalized
	let primary_norm;
	try {
		primary_norm = ens_normalize(primary);
		if (primary_norm === name_norm) {
			if (owner === address) {
				add_row_tag(normed_row, create_tag('fire', 'Primary Owner'));
			} else {
				add_row_tag(normed_row, create_tag('good', 'Primary'));
			}
		}	
	} catch (err) {
		primary_row.classList.add('error');
		add_row_tag(primary_row, create_tag('norm', err));
	}
	
	if (primary === input) {
		add_row_tag(primary_row, SAME_AS_INPUT);
	} else if (primary === name_norm) {
		add_row_tag(primary_row, SAME_AS_NORM);
	} else {
		add_row_tag(primary_row, create_copy_btn(primary));
		add_row_tag(primary_row, create_resolve_btn(primary));
		add_ensip1_tag(primary_row, primary);
	}
	if (primary === name_norm) {
		primary_row.classList.add('normalized');
		return;
	}	
	output_div.append(create_breakdown_row(primary, true));
	if (primary === primary_norm) {
		make_normalized(primary_row, primary_norm);
		return;
	}
	if (!primary_norm) return;
	add_row_tag(primary_row, create_tag('fail', 'Normalized'));
	
	let primary_norm_row = create_row('Normalized Primary');
	make_exploded(primary_norm_row, primary_norm, true);
	output_div.append(primary_norm_row);
	if (primary_norm === input) {
		add_row_tag(primary_norm_row, SAME_AS_INPUT);
		primary_norm_row.classList.add('normalized'); 
		return;
	} 
	if (name_norm === primary_norm) {
		add_row_tag(primary_norm_row, SAME_AS_NORM);
		primary_norm_row.classList.add('normalized'); 
	} else {
		add_row_tag(primary_norm_row, create_copy_btn(primary_norm));
		add_ensip1_tag(primary_norm_row, primary_norm, true);
		add_row_tag(primary_norm_row, create_resolve_btn(primary_norm));
		make_normalized(primary_norm_row, primary_norm);
	}
	output_div.append(create_breakdown_row(primary_norm));
}

function add_owner_links(row, owner) {	
	add_row_tag(row, create_link(`${active_chain.is_mainnet ? 'https://opensea.io/' : 'https://testnets.opensea.io/'}${owner}?tab=collected`, {innerHTML: OPENSEA_NAME, className: 'external'}));
	if (active_chain.is_mainnet) {
		add_row_tag(row, create_link(`https://${VISION_HOST}/0x/${owner}`, {innerHTML: VISION_NAME, className: 'external'}));	
	}	
	add_row_tag(row, create_link(`https://rainbow.me/${owner}`, {innerHTML: 'Rainbow', className: 'external'}));
	add_row_tag(row, create_link(`https://debank.com/profile/${owner}`, {innerHTML: 'Debank', className: 'external'}));
}
function parse_custom_error(err) {
	if (err.code === 'CALL_EXCEPTION' && err.data) {
		let error = ERROR_ABI.parseError(err.data);
		if (error) {
			let temp = new Error(`Contract error: ${error.signature} <a href="https://www.4byte.directory/signatures/?bytes4_signature=${error.selector}" target="_blank"><code>${error.selector}</code></a>`);
			temp.custom = error;
			return temp;
		}
	} else if (err.code === 'OFFCHAIN_FAULT') {
		let {reason, errorMessages = []} = err.info;
		if (reason) {
			return new Error(`CCIP error: ${errorMessages.join(' ')} <code>${reason}</code>`);
		}
	}
}
async function fetch_addr60(resolver) {
	let [{data: address, error}] = await fetch_records(resolver, [{type: TYPE_ADDR, coin: 60}]);
	if (error) throw error;
	if (!is_null_hex(address)) return ethers.getAddress(address);
}
async function fetch_records(resolver, records) {
	if (resolver.__unreachable) {
		return records.map(rec => ({rec, error: new Error('unreachable')})); 
	}
	const options = {enableCcipRead: true};
	if (records.length > 1) {
		let encoded = records.map(rec => {
			let frag = resolver.interface.getFunction(rec.type);
			let params = [resolver.__node];
			switch (rec.type) {
				case TYPE_TEXT: params.push(rec.key); break;
				case TYPE_ADDR: params.push(rec.coin); break;
			}
			return resolver.interface.encodeFunctionData(frag, params);
		});
		try {
			let res;
			if (resolver.__wild) { // optimistic CCIP-multicall
				let frag = resolver.interface.getFunction('multicall');
				res = await resolver.resolve(resolver.__dns_encoded, resolver.interface.encodeFunctionData(frag, [encoded]), options);
				[res] = resolver.interface.decodeFunctionResult(frag, res);
			} else {
				let {target} = resolver;
				res = await multicall_contract.tryAggregate(false, encoded.map(data => ({target, data})));
				res = res.map(({success, data}) => success ? data : null);
			}
			if (res && res.length === records.length) {
				resolver.__multicall = records.length;
				return records.map((rec, i) => {
					try {
						let frag = resolver.interface.getFunction(rec.type);
						let data = resolver.interface.decodeFunctionResult(frag, res[i]);
						if (frag.outputs.length === 1) data = data[0];
						return {rec, data};
					} catch (error) {
						return {rec, error};
					}
				});
			}
		} catch (err) {
		}
		records = records.filter(x => !x.bonus); // remove bonus records
	}
	return Promise.all(records.map(async rec => {
		if (should_stop_resolving()) {
			return {rec, error: new Error('aborted')};
		}
		let params = [resolver.__node];
		if (rec.type === TYPE_ADDR && rec.coin === 60) { // try boomer method first
			const method = 'addr(bytes32)';
			try {
				let data;
				if (resolver.__wild) {
					let frag = resolver.interface.getFunction(method);
					data = await resolver.resolve(resolver.__dns_encoded, resolver.interface.encodeFunctionData(frag, params), options);
					[data] = resolver.interface.decodeFunctionResult(frag, data);
					if (data.length !== 42) throw new Error('expected address');
				} else {
					data = await resolver[method](resolver.__node, options);
				}
				return {rec, data};
			} catch (err) {
				if (err instanceof TypeError) { // fetch() network error? 
					resolver.__unreachable = 'network';
					return {rec, error: err};
				} else {
					let error = parse_custom_error(err);
					if (error) {
						if (error.custom && error.custom.selector === '0xe861b2bd') {
							resolver.__unreachable = 'contract';
						}
						return {rec, error};
					}
				}
			}
		}
		switch (rec.type) {
			case TYPE_TEXT: params.push(rec.key); break;
			case TYPE_ADDR: params.push(rec.coin); break;
		}
		try {
			let data;
			if (resolver.__wild) {
				let frag = resolver.interface.getFunction(rec.type);
				data = await resolver.resolve(resolver.__dns_encoded, resolver.interface.encodeFunctionData(frag, params), options);
				data = resolver.interface.decodeFunctionResult(frag, data);
				if (frag.outputs.length === 1) data = data[0];
			} else {
				data = await resolver[rec.type](...params, options);
			}
			return {rec, data};
		} catch (err) {
			if (err.code === 'BAD_DATA' && err.value === '0x') return {rec};
			let error = parse_custom_error(err) || err;
			return {rec, error};
		}
	}));
}
async function fetch_resource_url(avatar, owner) {
	let pos = avatar.indexOf('://');
	if (pos >= 0) {
		let proto = avatar.slice(0, pos).toLowerCase();
		if (proto === 'ipfs') {
			let path = avatar.slice(pos + 3).replace(/^ipfs\//, '');
			try {
				CID.from(path.split('/', 1)[0]);
			} catch (err) {
				return {error: err.message};
			}
			avatar = url_from_ipfs_path(path);
		}
		let type;
		switch (proto) {
			case 'data': type = 'On-chain'; break;
			case 'ipfs':
			case 'http':
			case 'https': type = 'URL'; break;
		}
		if (type) {
			try {
				return {url: new URL(avatar).toString(), type, proto};
			} catch (err) {
				return {error: 'invalid url'};
			}
		}
	}
	if (owner && avatar.startsWith('eip155:')) {
		let match = avatar.toLowerCase().match(/^eip155:([0-9]+)\/erc(721|1155):(0x[0-9a-f]{40})\/(0x[0-9a-f]+|[0-9]+)$/i);
		if (!match) {
			return {error: 'invalid avatar string'};
		}
		let chain_id = parseInt(match[1]);
		let erc = match[2];
		let address = match[3];
		let token = BigInt(match[4]);
		// TODO: check known chains
		if (chain_id !== active_chain.id) {
			return {error: `wrong chain: ${format_dec_hex(chain_id)}`};
		}
		switch (erc) {
			case '721': {
				let contract = new ethers.Contract(address, [
					`function tokenURI(uint256) view returns (string)`,
					`function ownerOf(uint256) view returns (address)`,
				], active_provider);
				let nft_owner = await contract.ownerOf(token);
				if (nft_owner !== owner) {
					return {error: 'not owner'};
				}
				return {address, token, ...await fetch_nft_image(await contract.tokenURI(token))};
			}
			case '1155': {
				let contract = new ethers.Contract(address, [
					`function uri(uint256) view returns (string)`,
					`function balanceOf(address, uint256) view returns (uint256)`,
				], active_provider);
				let balance = await contract.balanceOf(owner, token);
				if (!balance) {
					return {error: 'not owner'};
				}
				return {address, token, ...await fetch_nft_image(await contract.uri(token).then(url => url.replace('{id}', token.toString(16).padStart(64, '0'))))};
			}
			default: return {error: `unknown ERC-${erc}`};
		}
	}
	return {error: 'unknown format'};
}
async function fetch_nft_image(url0) {
	let {error, url: meta_url} = await fetch_resource_url(url0);
	if (error) {
		return {error: 'expected metadata url'};
	}
	// fix opensea bullshit
	let fixed;
	const opensea_v1 = 'https://api.opensea.io/api/v1/metadata/';
	if (meta_url.startsWith(opensea_v1)) {
		meta_url = `https://api.opensea.io/api/v2/metadata/ethereum/${meta_url.slice(opensea_v1.length)}`;
		fixed = `${OPENSEA_NAME} v1 ‚Üí v2`;
	}
	try {
		let res = await fetch(meta_url);
		if (res.ok) {
			let {image} = await res.json();
			if (typeof image !== 'string') {
				return {error: 'expected metadata "image"'};
			}
			let {url, error} = await fetch_resource_url(image);
			if (error) {
				return {error};
			}
			return {type: 'NFT', url, meta_url, fixed};
		} else {
			return {error: `HTTP ${res.status}: ${meta_url}}`};
		}
	} catch (err) {
		return {error: `fetch failure`};
	}
}

async function ensure_eth_resolver() {
	if (eth_resolver_contract) return;
	if (eth_resolver_contract === false) throw new Error(`No "eth" resolver`);
	eth_resolver_contract = await get_resolver('eth');
	if (!eth_resolver_contract) {
		eth_resolver_contract = false;
		return ensure_eth_resolver();
	}
}
function contract_for_controller(address) {
	return new ethers.Contract(address, [
		'function owner() external view returns (address)',
		'function prices() external view returns (address)',
		'function nameWrapper() external view returns (address)',
	], active_provider);
}
function contract_for_price_oracle(address) {
	let contract = new ethers.Contract(address, [
		'function premium(string calldata name, uint256 expires, uint256 duration) external view returns (uint256)',
		'function price(string calldata name, uint256 expires, uint256 duration) external view returns (uint256)',
		'function usdOracle() external view returns (address)',
	], active_provider);
	contract.__premium_period = 21*86400*1000;
	return contract;
}
async function ensure_wrapper() {
	if (wrapper_contract) return;
	if (wrapper_contract === false) throw new Error(`Not implementated`);
	await ensure_eth_resolver();
	let wrapper_address = await eth_resolver_contract.__get_interface('0x019a38fe');
	if (is_null_hex(wrapper_address)) {
		wrapper_contract = false;
		return ensure_wrapper();
	}
	wrapper_contract = new ethers.Contract(wrapper_address, [
		'function isWrapped(bytes32 node) public view returns (bool)',
		'function getData(uint256 id) external view returns (address owner, uint32 fuses, uint64 expiry)',
		'function names(bytes32 node) public view returns (bytes)',	
	], active_provider);
}
async function ensure_eth_nft() {
	if (eth_nft_contract) return;
	if (eth_nft_contract === false) throw new Error(`Not implemented`);
	await ensure_eth_resolver();
	let nft_address = await registry_contract.owner(eth_resolver_contract.__node);
	if (is_null_hex(nft_address)) {
		eth_nft_contract = false;
		return ensure_eth_nft();
	}
	eth_nft_contract = new ethers.Contract(nft_address, [
		'function available(uint256 id) external view returns(bool)',
		'function nameExpires(uint256 id) external view returns(uint256)',
		'function ownerOf(uint256 id) external view returns (address)',
		'function GRACE_PERIOD() external view returns (uint256)',
	], active_provider);
	// TODO: make this abortable
	eth_nft_contract.__grace_period = 1000 * (await eth_nft_contract.GRACE_PERIOD().then(Number).catch(() => 90*86400));
	eth_controller_contract = contract_for_controller(await eth_resolver_contract.__get_interface(IFACE_ETH_CONTROLLER));
	price_oracle_contract = contract_for_price_oracle(await eth_controller_contract.prices());
}
function labels_from_dns_encoded(v) {
	let labels = [];
	let pos = 0;
	while (true) {
		let n = v[pos++];
		if (!n) { // empty
			if (pos !== v.length) break; // must be last
			return labels;
		}
		if (v.length < pos+n) break; // overflow
		labels.push(utf8_from_bytes(v.subarray(pos, pos += n)));
	}
	throw new Error('invalid DNS-encoded name');
}
function dns_encoded_from(labels) {
	if (typeof labels === 'string') {
		labels = labels ? labels.split('.') : [];
	}
	const MAX_LABEL = 255;
	let v = [];
	for (let label of labels) {
		if (!label) throw new Error('invalid empty label');
		let u = bytes_from_utf8(label);
		if (u.length > MAX_LABEL) throw new Error(`too long: ${u.length} > ${MAX_LABEL}`);
		v.push(u.length, ...u);
	}
	v.push(0);
	return Uint8Array.from(v);
}
async function get_resolver(name) {
	// returns resolver | undefined | throws
	// https://docs.ens.domains/ens-improvement-proposals/ensip-10-wildcard-resolution
	let v = name.split('.');
	for (let i = 0; i < v.length; i++) {
		let basename = v.slice(i).join('.');
		let basenode = namehash(basename);
		let address;
		if (resolve_debug && is_object(resolve_debug.resolver)) address = resolve_debug.resolver[basename];
		if (!address) address = await registry_contract.resolver(basenode);
		if (should_stop_resolving()) throw new Error('aborted');
		if (is_null_hex(address)) continue;
		// https://github.com/ensdomains/ens-contracts/tree/staging/contracts/resolvers/profiles
		let resolver = new ethers.Contract(address, [
			'function supportsInterface(bytes4 interfaceID) external view returns (bool)',
			'function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address)',
			'function resolve(bytes name, bytes data) view returns (bytes)',
			'function addr(bytes32 node, uint coinType) view returns (bytes)',
			'function addr(bytes32 node) view returns (address)',
			'function text(bytes32 node, string key) view returns (string)',
			'function contenthash(bytes32 node) view returns (bytes)',
			'function pubkey(bytes32 node) view returns (bytes32 x, bytes32 y)',
			'function name(bytes32 node) view returns (string)',
			'function recordVersions(bytes32 node) external view returns (uint64)',
			'function multicall(bytes[] calldata data) external returns (bytes[] memory results)',
		], active_provider);
		let wild = IS_WILD.get(address);
		if (wild === undefined) {
			wild = await resolver.supportsInterface('0x9061b923').catch(() => {});
			if (wild !== undefined) {
				IS_WILD.set(address, wild);
			}
		}
		if (i && !wild) break; // ancestor but not wildcard
		resolver.__name = name;
		resolver.__node = namehash(name);
		resolver.__dropped = i; // truthy => virtual
		resolver.__basename = basename;
		resolver.__basenode = basenode;
		resolver.__get_interface = hash => resolver.interfaceImplementer(resolver.__basenode, hash);
		if (wild) {
			resolver.__wild = true;
			try {
				resolver.__dns_encoded = dns_encoded_from(v);
			} catch (err) {
				resolver.__unreachable = 'name too long';
			}
		}
		return resolver;
	}
}
async function get_safe_primary(owner, alt_owner) {
	// return normalized primary if resolve(reverse(owner)) is owner or alt_owner
	let rev_resolver = await get_resolver(reverse_name(owner));
	if (!rev_resolver) {
		throw new Error('Primary not set');
	}
	if (should_stop_resolving()) return;
	let [{data: primary, error}] = await fetch_records(rev_resolver, [{type: TYPE_NAME}]);
	if (error) throw error;
	if (!primary) {
		throw new Error('Primary is Null');
	}
	let name = ens_normalize(primary);
	if (should_stop_resolving()) return;
	let resolver = await get_resolver(name);
	if (!resolver) {
		throw new Error('Resolver not set');
	}
	if (should_stop_resolving()) return;
	let address = await fetch_addr60(resolver);
	if (!address) {
		throw new Error('Address not set');
	}
	if (owner !== address && alt_owner !== address) {
		throw new Error(`Address mismatch`);
	}
	return name;
}
async function is_contract(address) {
	if (!is_address(address)) return;
	address = address.toLowerCase();
	let is = IS_CONTRACT.get(address);
	if (typeof is === 'boolean') return is;
	try {
		is = !is_null_hex(await active_provider.getCode(address));
		IS_CONTRACT.set(address, is);
		return is;
	} catch (err) {
	}	
}
function repair_social(value, {prefix = '@', url = 1} = {}) {
	if (prefix && value.startsWith(prefix)) return value.slice(prefix.length);
	if (url) {
		try {
			if (Number.isInteger(url)) {
				const i = url;
				url = u => u.pathname.split('/')[i];
			}
			let fix = url(new URL(value));
			if (fix) return fix;
		} catch (err) {
		}
	}
	return value;
}
function base58check(v) {
	return Base58BTC.encode([...v, ...ethers.getBytes(ethers.sha256(ethers.sha256(v))).slice(0, 4)]);
}
function format_btc_address(v, {p2pkh, p2sh, hrp, p2wpkh, p2tr}) {
	let n = v.length;
	// P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
	if (Number.isInteger(p2pkh) && n >= 5 && v[0] == 0x76 && v[1] == 0xA9 && v[2] === n-5 && v[n-2] == 0x88 && v[n-1] == 0xAC) {
		v[2] = p2pkh;
		return base58check(v.subarray(2, -2));
	}
	// P2SH: OP_HASH160 <scriptHash> OP_EQUAL
	if (Number.isInteger(p2sh) && n >= 3 && v[0] == 0xA9 && v[1] == n-3 && v[n-1] == 0x87) {
		v[1] = p2sh;
		return base58check(v.subarray(1, -1));
	}
	try {
		let version = v[0];
		if (version) version -= 0x50;
		let v32 = convert(v.subarray(2), 8, 5);
		if (p2wpkh === version) {
			return new Bech32(hrp, [version, ...v32], 1).toString();
		}
		if (p2tr === version) {
			return new Bech32(hrp, [version, ...v32], Bech32.M).toString();
		}
	} catch (err) {
	}
	throw new Error('invalid');
}
function strncmp(a, b) {
	return a ? a.localeCompare(b, undefined, {sensitivity: 'base'}) : a === b;
}
function create(el, args, ...a) {
	if (typeof el === 'string') el = document.createElement(el);
	if (args) {
		for (let [k, v] of Object.entries(args)) {
			if (!v) continue;
			if (v instanceof Function) {
				el.addEventListener(k, v);
			} else if (k === 'dataset') {
				Object.assign(el.dataset, v);
			} else if (k === 'className') {
				for (let x of [v].flat(Infinity)) {
					if (typeof x === 'string') {
						el.classList.add(x);
					} else if (x) {
						Object.entries(x).forEach(([k, v]) => el.classList.toggle(k, !!v));
					}
				}
			} else {
				el[k] = v;
			}
		}
	}
	el.append(...a);
	return el;	
}
function add_dot_eth(name, append) {
	const suffix = '.eth';
	if (name.endsWith('.')) name = name.slice(0, -1);
	if (name && !(append ? name.endsWith(suffix) : name.includes('.'))) name += suffix;
	return name;
}
function url_from_ipfs_path(s) {
	return `https://cloudflare-ipfs.com/ipfs/${s}`;
}
function format_dec_hex(id) {
	return id < 10 ? id : `${id} (0x${id.toString(16).toUpperCase()})`;
}
function is_address(s) {
	return typeof s === 'string' && /^0x[0-9a-f]{40}$/i.test(s);
}
function is_checksum_address(s) {
	try {
		return is_address(s) && s === ethers.getAddress(s);
	} catch (ignored) {
	}
}
function is_null_hex(s) {
	return !s || /^0x0*$/.test(s);
}
function labelhash(s) {
	// TODO: consider [hash] form
	//if (/^\[[0-9a-f]{64}\]$/i.test(s)) {
	return ethers.keccak256(bytes_from_utf8(s));
}
function namehash(s) {
	let hash = ethers.ZeroHash;
	if (s) hash = s.split('.').reduceRight((h, x) => ethers.keccak256(h + labelhash(x).slice(2)), hash);
	return hash;
}
function bytes32_from(x) {
	return '0x' + BigInt(x).toString(16).padStart(64, '0').slice(-64);
}
function is_object(x) {
	return x && x.constructor === Object;
}
</script>
</body>
</html>
