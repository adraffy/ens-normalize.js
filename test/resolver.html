<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ENS Resolver</title>
<style>
:root {
	--length-color: #f8eedd;
	--btn-fill-color: #eee;
	--btn-hover-fill-color: #ccc;
	--btn-border-color: #888;
}
.hide {
	display: none !important;
}
.balloon {
	flex: 1;
}
.long {
	white-space: pre-wrap !important;
	line-break: anywhere;
}
.force-ltr {
	direction: ltr;
	unicode-bidi: bidi-override;
}
a, button {
	cursor: pointer;
}
button {
	appearance: none;
	margin: 0;
	padding: 4px 8px;
	border: 1px solid var(--btn-border-color);
	border-radius: 4px;
	background-color: var(--btn-fill-color);
	color: #000;
	font-size: 100%;
}
button:disabled {
	opacity: 50%;
	pointer-events: none;
}
button:hover {
	background-color: var(--btn-hover-fill-color);
}
button:hover:active {
	background-color: #aaa;
	/*transform: translate(0px, 1px);*/
}
body { 
	margin: 3rem; 
	background: #eee;
	display: flex;
	flex-direction: column;
	gap: 8px;
	overflow-y: scroll;
}
body.testnet {
	background: #fef;
}
header {
	display: flex;
	justify-content: space-between;
}
h1 {
	display: flex;
	flex-wrap: wrap;
	align-items: baseline;
	margin: 0;
	gap: 4px;
	white-space: pre;
}
h2 {
	margin: 0;
	font-size: 16pt;
}
#provider {
	font-size: 11pt;
	font-weight: normal;
	color: #666;
}
#provider a {
	font-weight: bold;
}
#github {
	text-align: right;
	box-sizing: border-box;
	width: min-content;
}
#github a {	
	white-space: pre;
}
.spinner {
	width: 32px;
	height: 32px;
	box-sizing: border-box;
	animation: spin 2s infinite linear;
	border: 5px solid #000;
	border-bottom-color: transparent;
	border-radius: 100%;
}
@keyframes spin {
	to { transform:rotate(360deg); }
}
#examples {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 4px;
	font-size: 11pt;
}
#examples b {
	font-size: 12pt;
}
#examples button:not([id]) {
	background: #fff;
	padding: 2px 4px;
	border: 2px solid transparent;
	transition: transform 0.1s;
	font-size: 10pt;
}
#examples button:not([id]):hover {
	border-color: #aaa;
	transform: scale(1.5);
}
#examples button:not([id]):hover:active {
	border-color: #000;
}
#examples button.mapped:not([id]) {
	border-color: #ccf;
}
#examples button.error:not([id]) {
	border-color: #fcc;
}
#examples a {
	background-color: #ffc;
}
#examples_btn {
	font-weight: bold;
}
#options {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 8px;
}
#options > div {
	display: flex;
	align-items: center;
	gap: 4px;
}
#input {
	display: flex;
	align-items: stretch;
	gap: 8px;
}
#input input {
	box-sizing: border-box;
	width: 100%;
	padding: 8px;
	font-size: 16pt;
}
#actions {
	min-height: 32px; /* spinner */
	display: flex;
	flex-wrap: wrap;
	justify-content: flex-end;
	align-items: stretch;
	gap: 8px;
	margin-bottom: 4px;
}
input[type=checkbox], label {
	user-select: none;
	cursor: pointer;
}
/* .boxed input {
	display: none;
} */
.boxed label {
	padding: 2px 4px;
	border-radius: 2px;
	margin-left: -2px;
	border: 2px solid transparent;
}
#show_components_check:checked + label {
	border-color: #0aa;
	background: #cff;
}
#skip_norm_check:checked + label {
	border-color: #f00;
	background: #f00;
	color: #fff;
}
#force_ltr_check:checked + label {	
	border-color: #fb6;
	background: #fb6;
}
#resolve_btn {
	font-weight: bold;
}
#output {
	display: flex;
	flex-direction: column;
	gap: 8px;
	font-size: 14pt;
}
#output button {
	font-size: 11pt;
}
.row-label {
	order: -10;
	text-align: right;
	font-weight: bold;
	white-space: pre-wrap;
}
.row-label a {	
	color: #000;
}
.row {
	padding: 8px;
	background: #fff;
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	gap: 8px;
}
.row.display {
	background: #eff;
}
.row.normalized {
	background: #efe;
}
.row.addr {
	background: #fffff0;
}
.row.dns {
	background:#f5faff; 
}
.row.old {
	opacity: 65%;
}
.row.old:not(.details) {
	outline: 1px solid #ccc;
}
.row.dns .main {
	border-bottom-style: dotted;
}
.row.dns.invalid {
	background: #fff0f0;	
	outline: 3px dashed #fcc;
}
.row.pretty {
	background: linear-gradient(90deg, #fff, #fff0fc);
}
.row.category + .row.category {
	margin-top: 4px;
}
.row.category.ethmoji {
	outline: 3px dashed #add;
	background: #f0ffff;
}
.row.category.integer {
	outline: 3px dashed #fc8;
}
.formula {
	display: flex;
	flex-wrap: wrap;
	gap: 2px;
}
.formula a {
	padding: 4px;
	cursor: pointer;
	color: #000;
	text-decoration: none;
}
.formula a:hover {
	background: #cff;
}
.formula a sup {
	font-family: monospace;
}
.row .main {
	display: inline;
	font-size: 16pt;
	border-bottom: 2px solid #000;
	line-height: 130%;
}
ul.row {
	margin: 4px 0;
	padding: 16px 16px 16px 36px;
	flex-direction: column;
	align-items: start;
}
ul .tokens {
	display: inline-flex;
}
.row.readme {
	background: #ffc;
}
.row.readme code {
	background: #cff;
	padding: 1px;
}
.row.legend {
	background: #fff;
	gap: 2px;
}
.row.legend .tokens {
	min-height: 32px;
}
.row.links {
	display: grid;	
	gap: 8px;
	list-style: disclosure-closed;
	grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
	background: #eff;
	order: 100;
}
a.wide {
	line-break: anywhere;
}
sub {
	user-select: none;
}
span.tags {
	background: #ddd;
	color: #555;
	padding: 4px 8px;
	font-size: 12pt;
	border-radius: 4px;
	/* border: 1px solid #ccc; */
	white-space: pre;
}
button.copy {
	align-self: center;
	padding: 0;
	border: none;
	width: 28px;
	height: 28px;
	border-radius: 4px;
	background-color: inherit;
	background-position: center;
	background-repeat: no-repeat;
	background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='24' shape-rendering='geometricPrecision' stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' viewBox='0 0 24 24' width='24' style='color:var(--geist-foreground)'%3E%3Cpath d='M6 17C4.89543 17 4 16.1046 4 15V5C4 3.89543 4.89543 3 6 3H13C13.7403 3 14.3866 3.4022 14.7324 4M11 21H18C19.1046 21 20 20.1046 20 19V9C20 7.89543 19.1046 7 18 7H11C9.89543 7 9 7.89543 9 9V19C9 20.1046 9.89543 21 11 21Z'/%3E%3C/svg%3E");
}
button.copy:hover {
	background-color: #8f8;
}
button.copy.copied {
	background-color: #8f8;
	background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' height='24' shape-rendering='geometricPrecision' stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' viewBox='0 0 24 24' width='24' style='color:var(--geist-foreground)'%3E%3Cpath d='M20 6L9 17l-5-5'/%3E%3C/svg%3E");
}
.tags.long { order: 30; }
.tags.old {
	background-color: #df8;
	order: 8;
}
.tags.ens { order: 9; }
.tags.metadata { order: 10; }
.tags.third-party { order: 11; font-size: 80%; }
.tags.invalid { color: #f00; }
.tags.elapsed {
	background: #f0f0f0;
	font-size: 75%;
	order: 20;
}
.tags.normalized { background: #8f8; }
.tags.length {
	background: var(--length-color);
}
.tags.iface {
	display: flex;
	gap: 4px;
	text-decoration: none;
	background-color: #dde;
	padding: 4px 8px;
	border-radius: 4px;
	white-space: pre;
}
.tags.iface:hover {
	background-color: #bbd;
}
.tags.iface b {
	font-size: 12pt;
	text-decoration: underline;
	color: #000;
}
.tags.iface code {
	font-size: 12px;
	display: flex;
	align-items: center;
	justify-content: center;
}
.tags.good {
	color: #060;
	background: #cfc;
}
.tags.fire {
	color: #000;
	background: #fdb;
}
.tags.warn {
	background: #ffc;
}
.tags.attn {
	/* background: #fe0;
	color: #000; */
	background: #d47;
	color: #fff;
}
.tags.second {
	background: #fff0dd;
}
.tags.fail {
	background: #fcc;
	color: #600;
}
.tags.special {
	background: #f84;
	border: none;
	color: #fff;
}
.tags.clean {
	background: none;
	border: none;
	padding: 0;
	font-size: 110%;
	order: 7;
}
.tags.palindrome {
	background: #dfd;
}
.tags.white {
	color: #000;
	background: #fff;
}
.avatar {
	order: -1;
} 
.avatar img {
	position: relative;
	z-index: 1;
	display: block;
	border-radius: 4px;
	width: 32px;
	height: 32px;
	border: 1px solid #ccc;
	transition: transform 0.2s;
}
.avatar img:hover {
	transform: scale(3);
}
button.glow {
	border: 2px solid #2c2;
}
.row.details {
	display: grid;
	background: none;
	padding: 0;
	grid-template-columns: 2fr min-content 3fr;
	align-items: start;
	gap: 4px;
	font-size: 12pt;
	box-sizing: border-box;
}
.details a.hashproof {
	color: #000;
	font-weight: bold;
	text-decoration: none;
}
.details a.hashproof:hover {
	text-decoration: underline;
}
#output .details button {
	white-space: pre;
	font-size: 85%;
	padding: 2px 4px;
}
.details .length {
	color: #777;
	background: var(--length-color);
	border: 1px solid #ccc;
	text-align: center;
	padding: 2px 4px;
	border-radius: 5px;
}
.details .label {
	font-size: 14pt;
	display: flex;
	text-align: center;
	background: linear-gradient(90deg, #cfc8, #0000);
}
.details .label br {
	display: none;
}
.details .label .text {
	flex: 1;
}
.details .label.error {
	background: linear-gradient(90deg, #fcc, #0000);
}
.details .label.mapped {
	background: linear-gradient(90deg, #ccf8, #0000);
}
.details code {
	font-size: 90%;
}
.details code,
.details .label {	
	max-height: 10rem;
	overflow-y: auto;
}
.details .group {
	color: #666;
	text-align: left;
	font-style: italic;
	padding-right: 10px;
	font-size: 85%;
}
.details .restricted {
	display: flex;
	align-items: center;
	background: #ffc;
	border: 1px solid #ddd;
	padding: 1px 3px;
	text-decoration: none;
	font-size: 85%;
	color: #000;
}
.details .restricted:hover {
	background-color: #cff;
}
.details .disabled {
	opacity: 50%;
	user-select: none;
}
.details .wide {
	grid-column: 1 / -1;
	text-align: center;
	line-break: anywhere;
	padding-bottom: 2px;;
	border-bottom: 3px solid #fff;
} 
.details .wide:first-child {
	padding-bottom: 5px;
}
.details .wide:last-child {
	border-bottom: none;
}
.details .footer {
	font-size: 90%;
	color: #666;
	padding: 4px 0;
}
.details .footer .error {
	color: #d00;
	font-size: 11pt;
	font-weight: bold;	
	background: #fee;
}
.details .footer.sep {	
	border-top: 1px dotted #aaa;
}
.tokens {
	font-size: 16pt;
}
.exploded > .error {
	background-color: #f97;
	padding: 3px;
	border-radius: 5px;
}
.exploded > .error.first {
	background: #f77;
}
.row.error {
	background: #fcc;
	outline: 3px dashed #d00;
}
.row.contract:not(.error) {
	background-color: #ffc;
	outline: 3px dashed #cc0;
}
.transform {
	background: #fffaf0;
}
#recent_select {
	outline: none;
	width: 37px;
	padding: 0;
	margin: 0;
	border: 1px solid var(--btn-border-color);
	border-radius: 4px;
	cursor: pointer;
	font-size: 100%;
	appearance: none;
	background: no-repeat center url("data:image/svg+xml,%3Csvg height='21' width='20' version='1.1' viewBox='0 0 20 21' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10.5,0 C7,0 3.9,1.9 2.3,4.8 L0,2.5 L0,9 L6.5,9 L3.7,6.2 C5,3.7 7.5,2 10.5,2 C14.6,2 18,5.4 18,9.5 C18,13.6 14.6,17 10.5,17 C7.2,17 4.5,14.9 3.4,12 L1.3,12 C2.4,16 6.1,19 10.5,19 C15.8,19 20,14.7 20,9.5 C20,4.3 15.7,0 10.5,0 L10.5,0 Z M9,5 L9,10.1 L13.7,12.9 L14.5,11.6 L10.5,9.2 L10.5,5 L9,5 L9,5 Z'/%3E%3C/svg%3E"), no-repeat bottom 3px right 2px url("data:image/svg+xml,%3Csvg style='fill: currentColor' width='8' height='4' viewBox='0 0 8 4' version='1.1' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h8l-4 4Z' /%3E%3C/svg%3E") var(--btn-fill-color);
}
#recent_select:hover,
#recent_select:active {
	background-color: var(--btn-hover-fill-color);
}
footer {
	text-align: center;
	color: #666;
	margin-top: 16px;
	margin-bottom: 8px;
}
footer span {
	cursor: help;
}
footer span:hover {	
	color: #000;
}
@media only screen and (max-width: 800px) { 
	body {
		margin: 0;
	}
	button {
		font-size: 100%;
	}
	header {
		margin: 16px;
		margin-bottom: 0;
	}
	#input, #actions, #options, #examples {
		margin: 0 16px;
	}
	#content {
		font-size: 12pt;
	}
	a.wide {
		font-size: 95%;
	}
	.row {
		justify-content: center;
	}
	.row.details .wide {
		padding-left: 5px;
		padding-right: 5px;
	}
	.row.details .label {
		flex-direction: column-reverse;
		align-items: center;
		margin-left: 5px;
	}
	.row.details .group {
		text-align: center;
		padding-right: 0;
	}
	.row.details .restricted {
		flex-direction: row-reverse;
		font-size: 75%;
	}
	#examples_btn {
		display: block;
		width: 100%;
		margin-bottom: 4px;
		font-size: 14pt;
		padding: 4px;
	}
}
</style>
</head>
<body>
<header>
<h1><a href="https://ens.domains/">ENS Resolver</a><span id="provider" target="_blank" title="Registry Contract"></span></h1>
<div id="github"><a href="https://github.com/adraffy/ens-normalize.js">@adraffy/ens-normalize.js</a><br>
<a href="https://github.com/adraffy/ensip-15/blob/master/ens-improvement-proposals/ensip-15-normalization-standard.md">ENSIP-15</a></div>
</header>
<div id="examples" class="hide">
<button>vitalik.eth</button>
<button>nIcK.eTh</button>
<button>brantly.cash</button>
<button>🏴‍☠.art</button>
<button>..a..eth</button>
<button>öbb</button>
<button>Öbb</button>
<button data-name="◌̈bb">◌̈bb</button>

<a href="https://adraffy.github.io/punycode.js/test/demo.html"><b>Punycode:</b></a>
<button>xn--ls8h</button>
<button>xn--💩</button>
<button>💷pound.eth</button>

<a href="https://github.com/ensdomains/ens-contracts/tree/master/contracts/wrapper#namewrapper-docs"><b>Wrapped:</b></a>
<button>firstwrappedname.eth</button>
<button>dessert3.menu.bestsushi7.eth</button>

<b>Subdomain:</b>
<button data-name="nowzad.loopring.eth">loopring</button>
<button data-name="239.chonksociety.eth">Chonk #239</button>
<button>raffy.antistupid.com</button>

<a href="https://docs.ens.domains/ens-improvement-proposals/ensip-10-wildcard-resolution"><b>Wildcard:</b></a>
<button>moo331.nft-owner.eth</button>
<button>💎.gmcafe.art</button>
<button>1.offchainexample.eth</button>
<button>barmstrong.cb.id</button>

<!--
<a href="./display.html"><b>Display:</b></a>
<button>ADRaffy</button>
-->

<b>Address:</b>
<button data-name="0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045">d8dA..6045</button>

<b>Contract:</b>
<button data-name="eth-usd.data.eth">Chainlink ETH-USD</button>

<b>Preimage:</b>
<button data-delay="1000" data-name="token:91842011529764390124322931916134555051359118325819011691525342013207339157209">Token#</button>
<button data-delay="1000" data-name="https://opensea.io/assets/ethereum/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209">OpenSea</button>
<button data-delay="1000" data-name="https://www.gem.xyz/asset/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209">Gem</button>

<a href="./chars.html"><b>Mapped</b></a>
<button data-name="hyph{2D}{2010}{2011}{2012}{2013}{2014}{2015}{2043}{2212}{23AF}{23E4}{FE58}e{2E3A}n{2E3B}s">Hyphens</button>
<button>A.™️.Ю</button>
<button>Ⅷ</button>
<button>⨌</button>

<b>Ignored:</b> 
<button data-name="{FE0E}{FE0F}">Emoji Style</button>

<b>Disallowed:</b>
<button data-name="{26}{3000}{E0061}{FFFFFF}{200D}">Types</button>
<button data-name="test .te st. test">Whitespace</button>
<button data-name="{3002}.{FF0E}.{FF61}">Alt Stops</button>
<button data-name="y{303}.{1EF9}">Invalid NFC</button>
<button data-name="{DF00}">Surrogate</button>
<button data-name="[ba967c160905ade030f84952644a963994eeaed3881a6b8a4e9c8cbe452ad7a2].eth" data-skip="1">"💩.eth"</button>

<b>Deviation:</b> 
<button>ß</button>
<button>ς</button>

<b>Complex:</b>
<button data-name="_1{FE0F}E{FE0E}{303}{AD}{1F4A9}{24C2}{FE0E}{2E3B}a{301}"></button>

<b>Combining Marks:</b>
<button data-name="{300}">Leading</button>
<button data-name="💩{300}">Emoji</button>
<button data-name="x{300}{300}">Whitelisted</button>
<button data-name="{622}{64D}{64E}.{929}{901}{902}">NFD w/CM</button>

<b>NSM:</b>
<button data-name="{625}{610}{610}">Repeated</button>
<button data-name="{625}{610}{611}{612}{613}{614}">Too Many</button>

<a href="https://unicode.org/reports/tr46/#Validity_Criteria"><b>CheckHyphen:</b></a>
<button>-test.test-.t-e--s---t</button>
<button>te--st</button>

<b>Underscore:</b>
<button>__ab</button>
<button>a_b</button>

<a href="./emoji.html"><b>Emoji:</b></a>
<button>©</button>
<button>🕵</button>
<button>🧙‍♂</button>
<button>🏋🏿‍♂</button>
<button data-name="💩💩💩">💩<sup>3</sup></button>
<button data-name="🍞🍞🍞🍞🍞🍞🍞🍞🍞🍞🍞🍞🍞">🍞<sup>13</sup></button>
<button data-name="👁🗨👁️‍🗨️">👁️‍🗨️</button>
<button data-name="🧟🧟♂🧟‍♂">🧟</button>
<button>😵‍💫😵‍💫😵‍💫</button>
<button>😵💫😵💫😵💫</button>
<button>👩‍⚕👩🏽‍⚕️</button>
<button>👪👨‍👩‍👦</button>
<button data-name="🚴️🚵️🚴🏻🚴🏼🚴🏽🚴🏾🚴🏿🚵🏻🚵🏼🚵🏽🚵🏾🚵🏿🚴‍♀️🚴‍♂️🚵‍♀️🚵‍♂️🚴🏻‍♀️🚴🏻‍♂️🚴🏼‍♀️🚴🏼‍♂️🚴🏽‍♀️🚴🏽‍♂️🚴🏾‍♀️🚴🏾‍♂️🚴🏿‍♀️🚴🏿‍♂️🚵🏻‍♀️🚵🏻‍♂️🚵🏼‍♀️🚵🏼‍♂️🚵🏽‍♀️🚵🏽‍♂️🚵🏾‍♀️🚵🏾‍♂️🚵🏿‍♀️🚵🏿‍♂️">🚴️ Bikes (36)</button>
<button data-name="🦰🦱🦲🦳">🦰</button>
<button>👨‍👩‍👦🏿</button>
<button data-name="{1F3FB}{1F3FC}{1F3FD}{1F3FE}{1F3FF}">🏻</button>
<button data-name="💩{200D}💩">💩+💩</button>
<button data-name="{261D}{FE0F}{1F3FB}"></button>
<button>‼️</button>
<button>⁉️</button>
<button data-name="™ℹⓂ㊗㊙🈁🈂🈚🈯🈲🈳🈴🈵🈶🈷🈸🈹🈺🉐🉑">☹️ Demoted</button>

<b>Non-RGI:</b>
<button>🐱‍🐉</button>
<button>👪🏻</button>
<button>🤼🏻‍♀️</button>
<button data-name="{1F469}{1F3FE}{200D}{1F91D}{200D}{1F469}{1F3FE}">Mod+Mod</button>

<b>Regional:</b>
<button>🇦</button>
<button>🇦🇦</button>
<button>🇺🇸🇺🇲</button>

<b>Flag:</b>
<button>🏴</button>
<button>🏁️</button>
<button>🏳️‍🌈</button>

<a href="https://www.unicode.org/reports/tr51/#DisplayValidEmojiTagSeqs"><b>Tag:</b></a>
<button>{1F3F4}{E0067}{E0062}{E0065}{E006E}{E0067}{E007F}</button>
<button>{1F3F4}{E0067}{E0062}{E0073}{E0063}{E0074}{E007F}</button>
<button>{1F3F4}{E0067}{E0062}{E0077}{E006C}{E0073}{E007F}</button>
<button data-name="{1F3F4}{E0075}{E0073}{E0063}{E0061}{E007F}">usca</button>

<b>Circled/Squared:</b>
<button>i{2139}{2139}{FE0F}🛈</button>
<button data-name="ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ">Ⓐ-Ⓩ</button>
<button data-name="ⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ">ⓐ-ⓩ</button>
<button data-name="⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳㉑㉒㉓㉔㉕㉖㉗㉘㉙㉚㉛㉜㉝㉞㉟">⓪-㉟</button>
<button data-name="🅰🅱🅲🅳🅴🅵🅶🅷🅸🅹🅺🅻🅼🅽🅾🅿🆀🆁🆂🆃🆄🆅🆆🆇🆈🆉">🅰-🆉</button>
<button data-name="🅐🅑🅒🅓🅔🅕🅖🅗🅘🅙🅚🅛🅜🅝🅞🅟🅠🅡🅢🅣🅤🅥🅦🅧🅨🅩">🅐-🅩</button>
<button data-name="⓿❶❷❸❹❺❻❼❽❾❿⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴">⓿-❿</button>
<button data-name="🄌➊➋➌➍➎➏➐➑➒➓">🄌-➓</button>
<button data-name="㉈㉉㉊㉋㉌㉍㉎㉏">㉈-㉏</button>

<a href="https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.1"><b>ContextJ:</b></a>
ZWNJ:
<button data-name="ന്{200C}മ"></button>
<button data-name="نیم‌فاصله"></button>
<button data-name="a{200C}b"></button>

ZWJ:
<button data-name="ണ്‍"></button>
<button data-name="a{200D}b"></button>

<a href="https://datatracker.ietf.org/doc/html/rfc5892#appendix-A.3"><b>ContextO:</b></a>
Middle Dot: 
<button data-name="{6C}{B7}{6C}"></button>

Katakana Dot:
<button data-name="月・水"></button>
<button data-name="a・a{300}"></button>

Greek Keraia: 
<button data-name="{375}α"></button>

Hebrew Geresh:
<button data-name="{5D1}{5F3}"></button>


<a href="https://www.rfc-editor.org/rfc/rfc5893.html#section-2"><b>CheckBidi:</b></a>
<button>פעילותהבינאום</button>
<button data-name="{0786}{07AE}{0782}{07B0}{0795}{07A9}{0793}{07A6}{0783}{07AA}">Dhivehi</button>
<button data-name="{05D9}{05B4}{05D5}{05D0}{05B8}">Yiddish</button>
<button data-name="{1F1F8}{1F1E6}{633}{644}{645}{627}{646}">Emoji+RTL</button>
<button data-name="{633}{644}{645}{627}{646}{1F1F8}{1F1E6}">RTL+Emoji</button>
<button data-name="bahrain.مصر">LTR.RTL</button>
<button data-name="bahrainمصر">LTR+RTL in Label</button>
<button data-name="{202e}elgoog{202d}.eth">.ethgoogle</button>
<button data-name="{202e}hte.elgoog">google.eth</button>

<b>Keycaps:</b>
<button>1⃣2️⃣🔟.eth</button>
<button data-name="0️⃣1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣🔟*️⃣#️⃣">*️⃣-🔟</button>

<a href="https://unicode-org.github.io/cldr-staging/charts/latest/by_type/core_data.alphabetic_information.main.html">Exemplars</a> /
<a href="https://util.unicode.org/UnicodeJsps/confusables.jsp"><b>Confusables:</b></a>
<button>aα.ɑ</button>
<button>ஶ்ரீ.ஸ்ரீ</button>
<button data-name="i.i{307}.{131}{307}">i̇</button>
<button data-name="{E8}.e{300}.{450}.{435}{300}">è</button>

<b>Mixed-Script:</b>
<button data-name="0a〇.黑a8">Digit+Latin+Han</button>
<button data-name="あアいイうウえエおオ">Kana+Hira</button>
<button data-name="bitcoin.bitcοin.bi̇tcoin.bitсoin">"bitcoin"</button>
<button>ァ힣</button>

<b>Whole-Script:</b>
<button data-name="0x.0χ.0х">"0x"</button>
<button data-name="apple.дррӏе.аррӏе.aррӏе">"apple"</button>
<button data-name="ιοσρβυνγ">Greek</button>
<button data-name="o.٥.०.౦.੦.൦.ο.օ">"o"</button>
<button data-name="あー.〇一.一ー.一.ー.ᅳ">CJK Dash</button>

<a href="https://unicode.org/emoji/charts/emoji-released.html"><b>Unicode 15:</b></a>
<button data-name="{1F6DC}{1FA75}{1FA76}{1FA77}{1FA87}{1FA88}{1FAAD}{1FAAE}{1FAAF}{1FABB}{1FABC}{1FABD}{1FABF}{1FACE}{1FACF}{1FADA}{1FADB}{1FAE8}{1FAF7}{1FAF8}">Single Emoji (20)</button>
<button data-name="{1FAF7}{1F3FB}{1FAF7}{1F3FC}{1FAF7}{1F3FD}{1FAF7}{1F3FE}{1FAF7}{1F3FF}{1FAF8}{1F3FB}{1FAF8}{1F3FC}{1FAF8}{1F3FD}{1FAF8}{1F3FE}{1FAF8}{1F3FF}">Sequences (10)</button>
<button data-name="{1F426}{200D}{2B1B}">Black Bird</button>

<b>Fenced:</b>
<button>O'Brian</button>
<button data-name="¼½¾⅐⅑⅒⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞⅟↉">"½"</button>
<button>123⁄456’s</button>
<button data-name="a'.’z.a'’b.a⁄'.⁄a">Invalid</button>

<b>Misc:</b>
<button data-name="$¢£¤¥₡₦₩₪₫€₭₮₱₲₴₵₸₹₺₼₽₾⃀₿Ξ.؋">Currency</button>
<button data-name="•-•¬.⌐◨-◨.⌐〇-〇¬">Glasses</button>
<button>360°</button>
<button data-name="2πr.4πθ.8п">"π"</button>
<button>Ξ.≡.☰</button>
<button>♢⟠⧫</button>
<button data-name="_▁▂▃▄▅▆▇█">▃▅▇</button>
<button data-name="✓.✔︎.✔️.✅️.☑️">Checks</button>
<button data-name="ᴀʙᴄᴅᴇꜰɢʜɪᴊᴋʟᴍɴᴏᴘꞯʀꜱᴛᴜᴠᴡxʏᴢ">ꜱᴍᴀʟʟ ᴄᴀᴘꜱ</button>
<button data-name="zʎxʍʌnʇsɹbdouɯꞁʞſ̣ᴉɥᵷɟǝpↄqɐ">pǝuɹnʇ</button>
<button data-name="💩ąçęşìíîïǐł">Rare Latin</button>

<b>Pure:</b>
Arabic:
<button>إنترنت</button>
<button data-name="{660}{661}{662}{663}{664}{665}{666}{667}{668}{669}.{6F0}{6F1}{6F2}{6F3}{6F4}{6F5}{6F6}{6F7}{6F8}{6F9}.{6F0}{780}">Digits</button>
Hebrew:
<button>שירות־שמות</button>

<a href="https://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers"><b>Restricted:</b></a>
<button data-name="𓀀𓀁𓀂">Egyptian Hieroglyphs</button>
<button data-name="𐌱𐌻𐍉𐌼𐌰">Gothic</button>
<button>𓆏➡🐸️</button>
<button data-name="a𓀂">Mixed</button>
<button>ᏎᏮᏂᎥ.eth</button>

<a href="https://adraffy.github.io/ens-norm-tests/test-compare/output/ens_normalize.git_1.9.0_vs_eth-ens-namehash_2.0.15.html#diff-norm"><b>Different Norm:</b></a>
<button data-name="‑888">Remapped Hyphen</button>
<button data-name="۰۱۲۳۷۸۹">Mapped Arabic</button>

</div>
<div id="options">
	<button id="examples_btn">👀 Show Examples</button>
	<label><input type="checkbox" id="auto_resolve_check" checked>Resolve on Input</label>
	<label><input type="checkbox" id="show_details_check" checked>Details</label>
	<div class="boxed">
		<input type="checkbox" id="show_components_check" checked>
		<label for="show_components_check">Emoji Components</label>
	</div>
	<div class="boxed">
		<input type="checkbox" id="skip_norm_check">
		<label for="skip_norm_check">Skip Normalization</label>
	</div>
	<div class="boxed">
		<input type="checkbox" id="force_ltr_check">
		<label for="force_ltr_check">Force LTR</label>
	</div>
</div>
<div id="input">
	<input id="input_field" size="20" placeholder="Name or token:HEX or Marketplace URL or Address (Checksummed)">
	<select id="recent_select" title="Recent Names" class="hide">
		<option value="reset">🗑️ Clear History</option>
		<optgroup label="Recent Names"></optgroup>
	</select>
</div>
<div id="actions">
	<div class="spinner"></div>
	<div class="balloon"></div>
	<button id="random_emoji_btn" title="Random Emoji&#10;[ALT] Just Singles">🎲</button>
	<button id="find_emoji_btn">Emoji</button>
	<button id="confused_btn">Confused</button>
	<button id="nf_btn">NFD↔NFC</button>
	<button id="parent_btn">Parent</button>
	<button id="escape_btn" title="[ALT] Unicode Escaped">Escape</button>
	<button id="link_btn">Copy Link</button>
	<button id="resolve_btn">Resolve</button>
</div>
<div id="output">
<ul class="row readme">
<li>Click an <button data-name="👁️‍🗨️A{303}">Example</button> to see how it works.</li>
<li>Use <code>{FF}</code>, <code>[255]</code>, <code>\uFF</code>, or <code>\u{FF}</code> to manually include codepoints <button data-raw data-name="{200D}a[8205]b\u200D.eth">ZWJ</button></li>
<li><code>range:HEX<sub>1</sub>..HEX<sub>n</sub></code> expands to a range of characters <button data-name="range:61..7A" data-delay="1000">ASCII a-z</button></li>
<li><code>token:HEX</code> resolves to the .eth preimage (if known) <button data-name="token:91842011529764390124322931916134555051359118325819011691525342013207339157209" data-delay="1000">token:</button></li>
<li><code>wrapped:HEX</code> resolves to the name (if wrapped) <button data-name="wrapped:0xc44eec7fb870ae46d4ef4392d33fbbbdc164e7817a86289a1fe30e5f4d98ae85" data-delay="1000">wrapped:</button></li>
<li><code>12F 4C6 A89</code> is shorthand for <code>{12F}{4C6}{A89}</code> <button data-name="65 74 68" data-meta data-delay="1000">65 74 68</button></li>
<li><a href="#vitalik.eth"><button>Copy Link</button></a> to get a URL that resolves on page-load.</li>
<li>Many elements have tooltips with additional information.</li>
<li>Uses <a href="https://docs.ens.domains/terminology">ENS Terminology</a>.</li>
</ul>
<ul class="row legend">
<li>This is a <b>valid</b> sequence of characters: <span data-tokenize="abc"></span> and <b>.eth</b> name: <span data-tokenize="abc.eth"></span></li>
<li>This is an <b>emoji</b>: <span data-tokenize="👩🏽‍⚕️"></span> and its corresponding <b>components</b>: <span data-tokenize="👩🏽‍⚕️" data-parts="1"></span></li>
<li>This is a <b>mapped</b> token: <span data-tokenize="™"></span> which transforms into a <b>valid</b> sequence: <span data-tokenize="tm"></span></li>
<li>Characters not in canonical form require <b>NFC</b>: <span data-tokenize="a{303}"></span></li>
<li>These are <b>ignored</b> characters: <span data-tokenize="{AD}{FE0F}{E0100}"></span></li>
<li>These are <b>disallowed</b> characters: <span data-tokenize="#{00}{1FFFFF}{E0061}{200D}"></span></li>
</ul>
<ul class="row links">
<li><a href="./emoji.html">Supported Emoji</a></li>
<li><a href="./chars.html">Characters Viewer</a></li>
<li><a href="./confused.html">Confused Explainer</a>
<li><a href="https://adraffy.github.io/punycode.js/test/demo.html">Punycode Coder</a></li>
<li><a href="https://adraffy.github.io/keccak.js/test/demo.html">Keccak Hasher</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-regs.html">Recent ENS Registrations</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-emoji-freq.html">Emoji Frequency Browser</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-nft-matcher.html">ENS+NFT Matcher</a></li>
<li><a href="https://raffy.antistupid.com/eth/ens-batch-resolver.html">Batch Resolver</a></li>
<li><a href="https://github.com/adraffy/ens-labels/">Label Database</a>
<li><a href="./validate.html">Validation Test</a>
<li><a href="./report-nf.html">Unicode NormalizationTest</a>
<li><a href="https://adraffy.github.io/ens-norm-tests/test-breakdown/output/">Breakdown Reports</a></li>
<li><a href="https://raffy.antistupid.com/eth/emoji-pixels.html">Emoji Pixel Maker</a></li>
</ul>
</div>
<footer>Created by <a href="https://twitter.com/adraffy">raffy.eth</a></footer>
<script type="module">
import {ethers} from 'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.esm.min.js';
import {
	ens_normalize, ens_split, ens_beautify, ens_tokenize, ens_emoji,
	nfc, nfd, hex_cp, quote_cp, explode_cp, str_from_cps, safe_str_from_cps,
	dom_from_tokens, use_default_style, versions, compare_arrays, should_escape,
} from '../dist/all.min.js';
import {puny_encoded, is_surrogate} from '../../punycode.js/dist/index.min.js';
import eth_ens_namehash from './eth-ens-namehash@2.0.15.min.js';
use_default_style();

const url_params = new URLSearchParams(window.location.search)

let infura_provider = new ethers.providers.WebSocketProvider('wss://mainnet.infura.io/ws/v3/f36f6a8638134ac09f9400d3a7008dfe');
let active_provider = infura_provider;
let window_provider;
let chain_id;
let block_explorer;
let metadata_service;
let registry_contract;
let eth_resolver_contract;
let eth_nft_contract;
let wrapper_contract;
let price_oracle_contract;
let reverse_registrar;

const EMOJI = ens_emoji();

const input_field = document.querySelector('#input_field');
const resolve_btn = document.querySelector('#resolve_btn');
const auto_resolve_check = document.querySelector('#auto_resolve_check');
const show_components_check = document.querySelector('#show_components_check');
const skip_norm_check = document.querySelector('#skip_norm_check');
const show_details_check = document.querySelector('#show_details_check');
const force_ltr_check = document.querySelector('#force_ltr_check');
const recent_select = document.querySelector('#recent_select');
const recent_optgroup = document.querySelector('#recent_select optgroup');
const options_div = document.querySelector('#options');
const actions_div = document.querySelector('#actions');
const primary_loader = document.querySelector('#actions .spinner');
const output_div = document.querySelector('#output');
const readme_dom = [...output_div.childNodes]; // save initial ux
//const links_copy = document.querySelector('.row.links').cloneNode(true);
const examples_div = document.querySelector('#examples');
const examples_btn = document.querySelector('#examples_btn');

const RESOLVE_MODE_IDLE = 'idle';
const RESOLVE_MODE_EMPTY = 'empty';

const STORAGE_RECENT = 'recent';
const STORAGE_AUTO_RESOLVE = 'auto_resolve';
const STORAGE_SHOW_DETAILS = 'show_details';
const STORAGE_SHOW_COMPONENTS = 'show_components';
const STORAGE_FORCE_LTR = 'force_ltr';
const STORAGE_HIDE_EXAMPLES = 'hide_examples';

const APP_TITLE = 'ENS Resolver';
const INPUT_NAME = 'Input';
const OPENSEA_NAME = 'OpenSea';
const VISION_NAME = 'Vision';
const SKIP_SUFFIX = '_!';
const PRETTY_NAME = '💖️'; // 🌷️ 🌺️

const emoji_url = './emoji.html#q=%s';

const CHAIN_ID_MAINNET = 1;
const CHAIN_ID_GOERLI = 5;
const CHAIN_ID_SEPOLIA = 11155111;

const MIN_LENGTH = 3;

const ETH_TLD = 'eth';
const NFT_DOMAINS = new Set([ETH_TLD, 'art']);
const REVERSE_DOMAIN = 'addr.reverse';
const RESOLVER_NAMES = {
	'0x1da022710dF5002339274AaDEe8D58218e9D6AB5': 'Old Public Resolver (v1)',
	'0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41': 'Old Public Resolver (v2)',
	'0x231b0Ee14048e9dCcD1d247744d114a4EB5E8E63': '✨️ Public Resolver',
	'0x5fBb459C49BB06083C33109fA4f14810eC2Cf358': 'Old Reverse Resolver (v1)',
	'0xA2C122BE93b0074270ebeE7f6b7292C7deB45047': '✨️ Reverse Resolver',
};
const NOT_IFACE_RESOLVER = new Set();

const entity_span = document.createElement('span');

let resolve_timer = RESOLVE_MODE_IDLE;
let resolve_date0;

console.log(versions);
document.querySelector('footer').innerHTML += ` — <span>v${versions.version} (${versions.spec_hash.slice(0, 8)})</span>`;
document.querySelector('footer span').addEventListener('click', () => {
	window.alert(JSON.stringify(versions, null, ' '));
});
// TODO: add more 
function keycap(i) {
	return String.fromCodePoint(0x30+i, 0xFE0F, 0x20E3);
}
const KEYCAP_MINUS = '➖️';
const KEYCAP_NAME = 'Keycap';
const DIGIT_MAP = new Map();
const DIGITS_MAP = new Map();
for (let i = 0; i < 10; i++) DIGIT_MAP.set(keycap(i), i);
function add_digits(name, digits, extra = {}) {
	explode_cp(digits).forEach((cp, i) => DIGIT_MAP.set(cp, {name, i, ...extra}));
	DIGITS_MAP.set(name, digits);
}
add_digits('ASCII', '0123456789');
add_digits('Arabic', '٠١٢٣٤٥٦٧٨٩', {mixed: 1}); //, reversed: true
[[0x6F4, 4], [0x6F5, 5], [0x6F6, 6]].forEach(([cp, i]) => {
	DIGIT_MAP.set(cp, {name: 'Extended Arabic', i, mixed: 1});
});
add_digits('CJK', '〇一二三四五六七八九');
add_digits('Devangari', '०१२३४५६७८९');
add_digits('Thai', '๐๑๒๓๔๕๖๗๘๙');
//add_digits('Bengali', '০১২৩৪৫৬৭৮৯');
//add_digits('Tamil', '௦௧௨௩௪௫௬௭௮௯'); 

read_local_storage(STORAGE_HIDE_EXAMPLES, x => examples_div.classList.toggle('hide', x), false);
read_local_storage(STORAGE_SHOW_DETAILS, x => show_details_check.checked = x);
read_local_storage(STORAGE_AUTO_RESOLVE, x => auto_resolve_check.checked = x);
read_local_storage(STORAGE_SHOW_COMPONENTS, x => show_components_check.checked = x);
read_local_storage(STORAGE_FORCE_LTR, x => force_ltr_check.checked = x);

sync_recent(localStorage.getItem(STORAGE_RECENT));

for (let btn of document.querySelectorAll('#examples button:not([id]), button[data-name]')) {
	let name = btn.innerText;
	if (btn.dataset.name) {
		name = btn.dataset.name;
	}
	if (typeof btn.dataset.raw !== 'string') name = replace_escapes(name);
	if (!btn.innerText || btn.innerText.includes('{')) btn.innerText = name;
	let meta = typeof btn.dataset.meta === 'string' || name.includes(':') || is_checksum_address(name);
	try {
		if (meta || name !== ens_normalize(name)) {
			btn.classList.add('mapped');
		}
	} catch (err) {
		btn.classList.add('error');
	}	
	if (!meta && !name.includes('.')) name += `.${ETH_TLD}`;
	if (typeof btn.dataset.escape === 'string') name = apply_escapes(name);
	if (!btn.title) btn.title = meta ? name : `${name}\n${explode_cp(name).map(hex_cp).join(' ')}`;
	btn.addEventListener('click', () => {
		input_field.value = name;
		if (btn.dataset.skip) skip_norm_check.checked = true;
		if (options_div.getBoundingClientRect().top > window.innerHeight * .9) {
			options_div.scrollIntoView(); // scuffed
		}
		let delay = parseInt(btn.dataset.delay)|0;
		if (delay > 0) {
			schedule_resolve(delay);
		} else {
			resolve();
		}
	});
}
for (let x of document.querySelectorAll('[data-tokenize]')) {
	x.replaceWith(dom_from_tokens(ens_tokenize(replace_escapes(x.dataset.tokenize)), {
		emoji_url,
		components: x.dataset.parts
	}));
}

resolve_btn.addEventListener('click', () => resolve());
input_field.addEventListener('keydown', e => {
	if (e.key === 'Enter') {
		e.stopPropagation();
		resolve();
	}
});
input_field.addEventListener('input', () => {
	if (parse()) schedule_resolve();
});

window.addEventListener('storage', e => {
	if (e.type === 'storage' && e.key === STORAGE_RECENT) {
		sync_recent(e.newValue);
	}
});
function sync_recent(saved) {
	recent_optgroup.innerHTML = '';
	try {
		JSON.parse(saved).reverse().forEach(x => add_recent(x, false));
	} catch (err) {	
	}
}
recent_select.addEventListener('change', () => {
	let option = recent_select.selectedOptions[0];
	recent_select.selectedIndex = -1;
	if (!option) return;
	if (recent_optgroup.contains(option)) {
		input_field.value = option.value;
		resolve();
	} else if (option.value === 'reset') {
		recent_select.classList.add('hide');
		recent_optgroup.innerHTML = '';
		localStorage.setItem(STORAGE_RECENT, '[]');
	}
});
function add_recent(name, save = true) {
	let found;
	for (let x of recent_optgroup.children) {
		if (x.value === name) {
			recent_optgroup.prepend(x); // move to top
			found = true;
			break;
		}
	}
	if (!found) {
		while (recent_optgroup.childElementCount >= 25) { // max
			recent_optgroup.lastChild.remove();
		}
		let option = new Option();
		option.value = name;
		if (is_checksum_address(name)) {
			option.innerHTML = `🏠️ ${name}`; 
		} else {
			try {
				let norm = ens_normalize(name);
				option.innerHTML = `${norm === name ? '✅️' : '☑️'} ${name}`;
			} catch (err) {
				option.innerHTML = `❌️ ${apply_escapes(name, cp => should_escape(cp) || cp == 0x20)}`;
			}
		}
		recent_optgroup.prepend(option);
	}
	//recent_optgroup.label = `Recent Names (${recent_optgroup.childElementCount})`;
	recent_select.selectedIndex = -1;
	recent_select.classList.remove('hide');
	if (save) {
		localStorage.setItem(STORAGE_RECENT, JSON.stringify([...recent_optgroup.children].map(x => x.value)));
	} 
}


document.querySelector('#random_emoji_btn').addEventListener('click', e => {
	let name = '';
	let pool = e.altKey ? EMOJI.filter(cps => cps.length == 1 || (cps.length == 2 && cps[1] === 0xFE0F)) : EMOJI;
	while ([...name].length < MIN_LENGTH) {
		name += ens_normalize(str_from_cps(pool[Math.random() * pool.length|0]));
	}
	input_field.value = `${name}.eth`;
	skip_norm_check.checked = false;
	resolve();
});
document.querySelector('#find_emoji_btn').addEventListener('click', e => {
	let url = './emoji.html';
	let token = ens_tokenize(input_field.value).find(x => x.emoji);
	if (token) url += `#q=${encodeURIComponent(String.fromCodePoint(...token.emoji))}`;
	let a = create_link(url);
	if (e.altKey) a.target = '_blank';
	a.click();	
});
document.querySelector('#confused_btn').addEventListener('click', e => {
	let s = input_field.value;
	let a = create_link(`./confused.html#${encode_uri_component_surrogate_escaped(s.replaceAll('.', ''))}`);
	if (e.altKey) a.target = '_blank';
	a.click();
});
document.querySelector('#nf_btn').addEventListener('click', () => {
	let s0 = input_field.value;
	let s1 = replace_escapes(s0);
	let s2 = apply_escapes(str_from_cps(nfd(explode_cp(s1))));
	let s3 = apply_escapes(str_from_cps(nfc(explode_cp(s1))));
	if (s2 === s3 && s2 === apply_escapes(s1)) return; // do nothing
	input_field.value = s0 == s2 ? s3 : s2;
	resolve();
});
document.querySelector('#parent_btn').addEventListener('click', e => {
	let name = input_field.value;
	let pos = name.indexOf('.');
	input_field.value = pos >= 0 ? name.slice(pos+1) : '';
	resolve();
});
document.querySelector('#escape_btn').addEventListener('click', e => {
	let s0 = input_field.value;
	let s1 = replace_escapes(s0);
	let s2 = apply_escapes(s1, undefined, e.altKey);
	let s3 = apply_escapes(s1, () => true, e.altKey);
	let set = [...new Set([s1, s2, s3])];
	let pos = set.indexOf(s0);	
	input_field.value = set[(pos + 1) % set.length];
	update_title();
});
document.querySelector('#link_btn').addEventListener('click', () => {
	//let hash = '#' + encodeURIComponent(input_field.value);
	//if (skip_norm_check.checked) hash += SKIP_SUFFIX;
	navigator.clipboard.writeText(window.location.href);
});

auto_resolve_check.addEventListener('input', () => {
	localStorage.setItem(STORAGE_AUTO_RESOLVE, !!auto_resolve_check.checked);	
	resolve_if_auto();
});
show_details_check.addEventListener('input', () => {	
	localStorage.setItem(STORAGE_SHOW_DETAILS, !!show_details_check.checked);	
	for (let el of document.querySelectorAll('.detailed')) {
		el.classList.toggle('hide', !show_details_check.checked);
	}
});
show_components_check.addEventListener('input', () => {
	localStorage.setItem(STORAGE_SHOW_COMPONENTS, !!show_components_check.checked);
	update_exploded();
});
force_ltr_check.addEventListener('click', () => {
	localStorage.setItem(STORAGE_FORCE_LTR, !!force_ltr_check.checked);
	sync_force_ltr();
});
examples_btn.addEventListener('click', () => {
	let b = !examples_div.classList.contains('hide');
	examples_div.classList.toggle('hide', b);
	localStorage.setItem(STORAGE_HIDE_EXAMPLES, !!examples_div.classList.contains('hide'));
	sync_examples();
});
skip_norm_check.addEventListener('input', resolve_if_auto); // not saved

if (!url_params.has('infura') && window.ethereum) {
	let p = ethereum;
	if (Array.isArray(ethereum.providers)) p = ethereum.providers[0]; // fix scuffed multi-provider
	window_provider = new ethers.providers.Web3Provider(p, 'any');
	window_provider.on('network', update_network);
} else {
	update_network();
}

sync_examples();
sync_force_ltr();
input_field.focus();
apply_location_hash();
window.addEventListener('hashchange', apply_location_hash);

function update_network(network) {
	active_provider = infura_provider;
	let registry = '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e';
	let network_name = 'mainnet';
	chain_id = CHAIN_ID_MAINNET;
	block_explorer = 'https://etherscan.io';
	metadata_service = 'https://metadata.ens.domains/mainnet';
	let use_window;
	if (network) {
		switch (network.chainId) {
			//case 3: return 'https://ropsten.etherscan.io';
			//case 4: return 'https://rinkeby.etherscan.io';
			//case 139: return 'https://polygonscan.io';		
			case CHAIN_ID_SEPOLIA: {
				network_name = 'Sepolia';
				block_explorer = 'https://sepolia.etherscan.io';
				metadata_service = 'https://metadata.ens.domains/sepolia';
				use_window = true;
				break;
			}
			case CHAIN_ID_GOERLI: {
				network_name = 'Goerli';
				block_explorer = 'https://goerli.etherscan.io';
				metadata_service = 'https://metadata.ens.domains/goerli';
				use_window = true;
				break;
			}
			case CHAIN_ID_MAINNET: {
				use_window = true;
				break;
			}
		}
		if (use_window) {
			chain_id = network.chainId;
			active_provider = window_provider;
			if (!network.ensAddress) {
				network.ensAddress = registry; // force it into ethers
			}
		}
	}
	let provider_name = use_window ? 'window.ethereum' : 'Infura';
	document.body.classList.toggle('testnet', chain_id !== CHAIN_ID_MAINNET);
	// TODO: add change network button
	document.querySelector('#provider').innerHTML = `using ${provider_name} (<a href="${block_explorer}/address/${registry}">${network_name}</a>)`;
	let init = !registry_contract;
	registry_contract = new ethers.Contract(registry, [
		'function resolver(bytes32 node) external view returns (address)',
		'function owner(bytes32 node) external view returns (address)',
	], active_provider);
	eth_resolver_contract = null;
	eth_nft_contract = null;
	wrapper_contract = null;
	reverse_registrar = null;
	if (input_field.value) {
		schedule_resolve();
	} else if (init) {
		primary_loader.classList.add('hide');
	}
}

function sync_examples() {
	if (examples_div.classList.contains('hide')) {
		examples_btn.innerText = '👀 Show Examples';
		options_div.prepend(examples_btn);
	} else {
		examples_btn.innerText = '🙈 Hide Examples';
		examples_div.prepend(examples_btn);
	}
}

function sync_force_ltr() {
	input_field.classList.toggle('force-ltr', force_ltr_check.checked);
}

function apply_location_hash() {
	let name = decodeURIComponent(window.location.hash.slice(1));
	let skip = name.endsWith(SKIP_SUFFIX);
	if (skip) name = name.slice(0, -SKIP_SUFFIX.length);
	skip_norm_check.checked = skip;
	input_field.value = name;
	resolve();
}

function should_stop_resolving() {
	return resolve_timer !== RESOLVE_MODE_IDLE;
}

function schedule_resolve(delay = 500) {
	if (!auto_resolve_check.checked) return;
	clearTimeout(resolve_timer);
	if (is_working()) {
		resolve_timer = [Date.now() + delay]; // encode as future time
	} else {
		primary_loader.classList.remove('hide');
		resolve_timer = setTimeout(resolve, delay);
	}
} 

function resolve_if_auto() {
	if (auto_resolve_check.checked && input_field.value && parse()) {
		resolve();
	}
}

function stop_resolving() {
	clearTimeout(resolve_timer);
	resolve_timer = RESOLVE_MODE_EMPTY;
	primary_loader.classList.add('hide');
}

function update_title() {
	let title = APP_TITLE;
	let hash = ' '; // cannot be empty
	let input = input_field.value;
	if (input) {
		title = `${title}: "${input}"`;
		hash = '#' + encode_uri_component_surrogate_escaped(input);
		if (skip_norm_check.checked) {
			title += ' (!)';
			hash += SKIP_SUFFIX;
		}
	}
	window.history.replaceState(null, null, hash); 
	document.title = title;
}

function replace_name(name) {
	//if (name === '[root]') return '';
	return name;
}

function parse() {
	update_title();	
	let input = input_field.value;
	let skip = skip_norm_check.checked;
	/*
function parse() {
	return presolve(input_field.value, skip_norm_check.checked, false);
}
function presolve(input, skip, resolving) {
	// update browser history
	let title = APP_TITLE;
	let hash = ' '; // cannot be empty
	let input = input_field.value;
	if (input) {
		title = `${title}: "${input}"`;
		hash = '#' + encodeURIComponent(input);
	}
	let name = replace_escapes(input);
	let state0 = window.history.state;
	let state = {name, resolving};
	if (skip) {
		title += ' (!)';
		hash += SKIP_SUFFIX;
		state.name += SKIP_SUFFIX;
	}
	// note: only push if records that differ 
	// history API is total dogshit
	// cannot reliably pop a duplicate
	// eg. "A" + [space] => "A " + [del] => "A"
	if (state0 && (resolving || state0.resolving) && state0.name != name) {
		window.history.pushState(state, null, hash);
	} else {
		window.history.replaceState(state, null, hash);
	}
	*/
	// show readme if empty
	if (!input) {
		stop_resolving();
		output_div.innerHTML = '';
		output_div.append(...readme_dom);	
		//actions_div.classList.add('hide');
		return;
	}
	// TODO: conslidate this code with resolve()
	let name = replace_name(replace_escapes(input));
	output_div.innerHTML = '';
	//output_div.append(links_copy);
	//actions_div.classList.remove('hide');
	if (resolve_timer === RESOLVE_MODE_EMPTY) {
		resolve_timer = RESOLVE_MODE_IDLE;
	}
	if (is_checksum_address(name)) {
		let row = create_row('Address');
		row.append(create_etherscan_address_link(name));		
		add_row_tag(row, create_reverse_resolve_btn(name));
		output_div.append(row);
		return true;
	}
	let row = create_row(INPUT_NAME);
	make_exploded(row, name, false);
	output_div.append(row, create_details_row(name, true));
	try {
		let norm = ens_normalize(name);
		if (norm === name) {
			make_normalized(row, norm);
		} else {
			add_row_tag(row, create_typed_tag('fail', 'Normalized'));
			if (!skip) {
				add_transformed_row(name);
				let norm_row = create_row('Normalized');
				make_exploded(norm_row, norm, true);
				make_normalized(norm_row, norm);
				add_old_tag(norm_row, name, true);
				output_div.append(norm_row, create_details_row(norm));
			}
		}		
		add_old_tag(row, name);
		//output_div.append(create_dns_row(norm));
		return true;
	} catch (err) {
		row.classList.add('error');
		add_row_tag(row, create_typed_tag('norm', err));
		if (skip) return true;
		add_old_tag(row, name);
		make_exploded(row, name, false); // show the mapping during the error
		stop_resolving();

		// if there is a fully ignorable label
		let collapsed = ens_split(name).filter(x => !x.tokens || x.tokens.length).map(x => str_from_cps(x.input)).join('.');
		if (collapsed !== name) {
			let btn = document.createElement('button');
			btn.innerText = '💥️ Collapse Empty Labels';
			btn.addEventListener('click', () => {
				input_field.value = collapsed;
				resolve();
			});
			add_row_tag(row, btn);
		}

		// if there is whitespace
		let stripped = name.replace(/\s+/g, '');
		if (stripped !== name) {
			let btn = document.createElement('button');
			btn.innerText = '✂️ Strip Whitespace';
			btn.addEventListener('click', () => {
				input_field.value = stripped;
				resolve();
			});
			add_row_tag(row, btn);
		}

		// if there are likely unmapped mistakes
		const SLOPPY_MAP = new Map([
			[0x2F, 0x2044], 
			[0x3002, 0x2E],
			[0xFF0E, 0x2E],
			[0xFF61, 0x2E],
		]);
		let sloppy = str_from_cps(explode_cp(name).map(x => SLOPPY_MAP.get(x) || x))
		if (sloppy !== name) {
			let btn = document.createElement('button');
			btn.innerHTML = '💣️ Unsafe Replace';
			btn.title = `Replace the following characters:` + [...SLOPPY_MAP.entries()].map(([a, b]) => {
				return `\n"${safe_str_from_cps([a])}" ${hex_cp(a)} → "${safe_str_from_cps([b])}" ${hex_cp(b)}`
			}).join('');
			btn.addEventListener('click', () => {
				input_field.value = sloppy;
				resolve();
			});
			add_row_tag(row, btn);
		}

		let tokens = ens_tokenize(name); 

		// if there are disallowed characters		
		if (tokens.some(x => x.type === 'disallowed')) {
			let btn = document.createElement('button');
			btn.innerText = '❌ Remove Disallowed';
			btn.addEventListener('click', () => {
				input_field.value = str_from_cps(tokens.flatMap(t => t.type === 'nfc' ? t.tokens0 : t).flatMap(t => {
					switch (t.type) {
						case 'disallowed': return [];
						case 'valid': return t.cps;
						case 'emoji': return t.input;
						default: return t.cp;
					}
				}));
				resolve();
			});
			add_row_tag(row, btn);
		}

		// if there are normalizable parts
		if (tokens.some(x => x.type === 'nfc' || x.type === 'ignored' || x.type === 'mapped' || (x.type === 'emoji' && x.input.includes(0xFE0F)))) {
			let btn = document.createElement('button');
			btn.innerHTML = '💪️ Force Normalize';
			btn.addEventListener('click', () => {
				input_field.value = str_from_cps(tokens.flatMap(token => {
					switch (token.type) { 
						case 'ignored': return []; // removes ignored (dangerous)
						case 'mapped': // applies known mappings 
						case 'emoji': // removes FE0F from known emoji
						case 'nfc':
						case 'valid': return token.cps;
						default: return token.cp;
					}
				}));
				resolve();
			});
			add_row_tag(row, btn);
		}
	}
}

function add_detailed(row) {
	row.classList.add('detailed');
	row.classList.toggle('hide', !show_details_check.checked);
}

function add_transformed_row(input) {
	if (ens_tokenize(input).some(x => x.type === 'nfc' || x.type === 'mapped')) {
		let row = create_row('Transformed');
		row.classList.add('transform');
		add_detailed(row);
		make_exploded(row, input, true);
		output_div.append(row);
	}
}

function create_dns_row(name, replaced) {
	let row = create_row(replaced ? 'Alternative DNS' : 'DNS');
	let try_replace = false;
	row.classList.add('dns');
	try {
		const MAX_LABEL = 63;
		const MAX_NAME = 253; 
		const VALID_REGEX = /^[-0-9a-z]*$/;
		let encoded = name.split('.').map(label => {
			let cps = explode_cp(label);
			try {
				let encoded = puny_encoded(cps).toLowerCase();
				if (!VALID_REGEX.test(encoded)) {
					let first = [...encoded].find(ch => !VALID_REGEX.test(ch));
					throw new Error(`unsupported ASCII: "${safe_str_from_cps(explode_cp(first))}"`);
				}
				if (encoded === label) {
					if (label.startsWith('xn--')) throw new Error('punycode literal');
					if (label.slice(2, 4) === '--') throw new Error('invalid label extension');
					// 20230123: WHATWG URL uses "CheckHyphens" false
					//if (label.startsWith('-')) throw new Error('leading hyphen');
					//if (label.endsWith('-')) throw new Error('trailing hyphen');
				}
				if (encoded.length > MAX_LABEL) throw new Error(`too long: ${encoded.length} > ${MAX_LABEL}`);
				return encoded;
			} catch (err) {
				throw new Error(`Invalid label "${safe_str_from_cps(cps)}": ${err.message}`);
			}
		}).join('.');
		if (encoded.length > MAX_NAME) {
			throw new Error(`Name too long: ${encoded.length} > ${MAX_NAME}`);
		}
		let browser;
		try {
			browser = new URL(`https://${name}`).host;
		} catch (ignored) {
		}
		row.append(create_main_span(encoded));
		add_row_tag(row, create_copy_btn(encoded));
		if (encoded === name) {
			add_row_tag(row, create_typed_tag('good', 'Verbatim'));
		} else if (!browser || browser !== encoded) {
			add_row_tag(row, create_typed_tag('stop', 'Pre-IDNA Punycode Required'));
			if (browser) {
				add_row_tag(row, create_copy_btn(browser, {title: 'Copy Mangled'}));
			}
			if (!replaced) {
				add_alternative_btn(row, name);
			}
		} else {
			add_row_tag(row, create_typed_tag('second', 'Punycode Compatible'));
		}
		if (chain_id == CHAIN_ID_MAINNET) {
			add_row_tag(row, create_link(`https://${encoded}.limo`, '.limo'));
			add_row_tag(row, create_link(`https://${encoded}.link`, '.link'));
			add_row_tag(row, create_link(`https://${encoded}.xyz`, '.xyz'));
		}
		add_row_tag(row, create_link(`https://adraffy.github.io/punycode.js/test/demo.html#${browser?'p':'u'}=${browser || name}`, 'Check'));
	} catch (err) {
		row.classList.add('invalid');
		add_row_tag(row, create_typed_tag('fail', err));
		if (!replaced) {
			add_alternative_btn(row, name);
		}
	}	
	return row;
	
}

// try some transformations
function add_alternative_btn(row, name) {
	let alt = name;
	try {
		alt = ens_beautify(alt);
	} catch (err) {
	}
	alt = str_from_cps(explode_cp(name).map(cp => {
		if (cp >= 0x660 && cp <= 0x669) {
			return cp + 0x90; // try other arabic digits
		} else {
			return cp;
		}
	}));
	if (alt !== name) {
		let btn = document.createElement('button');
		btn.innerText = '🥈️ Try Alternative';
		btn.addEventListener('click', () => {
			row.replaceWith(create_dns_row(alt, true));
		});
		add_row_tag(row, btn);
	}
}

function is_safe_ascii(cp) {
	// same as:
	//return !should_escape(cp) && cp != 0x20;
	return cp >= 0x21 && cp <= 0x7E;
}
function unicode_escape_cp(cp) {
	let hex = hex_cp(cp);
	return hex.length > 4 ? `\\u{${hex}}` : `\\u${hex.padStart(4, '0')}`; // be nice
}
function unicode_escape(s) {
	return explode_cp(s).map(unicode_escape_cp).join('');
}
function entity_escape(s) {
	return explode_cp(s).map(cp => is_safe_ascii(cp) ? String.fromCodePoint(cp) : `&#x${hex_cp(cp)};`).join('');
}
// escape where escape_fn is true (default: non-ascii)
// unicode: use \u-format
function apply_escapes(s, escape_fn, unicode) {
	if (!escape_fn) escape_fn = cp => !is_safe_ascii(cp);
	return explode_cp(s).map(cp => {
		return escape_fn(cp) ? unicode ? unicode_escape_cp(cp) : quote_cp(cp) : String.fromCodePoint(cp);
	}).join('');
}
function replace_escapes(s) {
	// match: \u{HEX}, {HEX}, \uXXXX, [0xHEX], [DEC]
	return s.replace(/(?:(?:(?:\\u)?\{([0-9a-f]+)\}|\\u([0-9a-f]{4}))|(?:\[((?:0x[0-9a-f]+)|[0-9]+)\]))/uig, (_, hex1, hex2, num) => {		
		try {
			return String.fromCodePoint(num ? parseInt(num) : parseInt(hex1 || hex2, 16)); 
		} catch (err) {
			return '�';
		}
	});
}
function encode_uri_component_ens_escaped(s) {
	return s.split('.').map(x => {
		try {
			return encodeURIComponent(x);
		} catch (err) {
			return `[${labelhash(x).slice(2)}]`; // support unlinkable stuff
		}
	}).join('.');
}
function encode_uri_component_surrogate_escaped(s) {
	return encodeURIComponent(apply_escapes(s, is_surrogate));
}
function create_link(url, inner, cls) {
	let a = document.createElement('a');
	a.href = url;
	if (inner && typeof inner !== 'string') {
		a.append(...[inner].flat(Infinity));
	} else {
		a.innerHTML = inner || url;
	}
	if (cls) a.classList.add(cls);
	if (!url.includes('ens.domains/') && !url.includes('adraffy.github.io/') && !url.includes('etherscan.io/')) {
		a.classList.add('third-party');
	}
	try {
		new URL(url);
	} catch (err) {
		a.classList.add('invalid');
	}
	return a;
}
function create_ens_link(name, {title = 'ENS'} = {}) {		
	return create_link(`https://app.ens.domains/${encode_uri_component_ens_escaped(name)}`, title, 'ens');
}
function create_ens_metadata_link(contract, token) {
	return create_link(`${metadata_service}/${contract}/${token}`, 'Metadata', 'ens');
}
function create_etherscan_address_link(addr, {title, anchor = '', contract} = {}) {
	if (contract === true) anchor = '#readContract';
	return create_link(`${block_explorer}/address/${addr}${anchor}`, title || addr, title ? false : 'wide');
}
function create_etherscan_nft_link(contract, token, title ='Etherscan') {
	return create_link(`${block_explorer}/nft/${contract}/${ethers.BigNumber.from(token)}`, title, 'third-party');	
}
function create_opensea_link(contract, token, title = OPENSEA_NAME) {
	let prefix;
	switch (chain_id) {
		case CHAIN_ID_MAINNET: prefix = 'https://opensea.io/assets/ethereum/'; break;		
		case CHAIN_ID_GOERLI: prefix = 'https://testnets.opensea.io/assets/goerli/'; break;
		default: return;
	}
	return create_link(`${prefix}${contract}/${ethers.BigNumber.from(token)}`, title);
}

function create_copy_btn(s, {title = 'Copy', explode} = {}) {
	let btn = document.createElement('button');
	btn.addEventListener('click', e => {
		let copy = s;
		if (e.altKey) {
			copy = unicode_escape(copy);
		} else if (e.shiftKey) {
			copy = entity_escape(copy);
		} 
		navigator.clipboard.writeText(copy);
		btn.classList.add('copied');
		setTimeout(() => btn.classList.remove('copied'), 2000);
	});
	btn.classList.add('copy');
	//btn.innerHTML = title;
	btn.title = s;
	if (explode === undefined) {
		explode = !/^0x[0-9a-f]*$/i.test(s);
	}
	if (explode) {
		btn.title += '\n' + explode_cp(s).map(hex_cp).join(' ');
	}
	btn.title += `\n[ALT] Unicode Escaped\n[SHIFT] Entity Escaped`;
	return btn;
}
function reverse_name(addr) {
	return `${addr.slice(2).toLowerCase()}.${REVERSE_DOMAIN}`;
}
function create_reverse_resolve_btn(addr) {
	return create_resolve_btn(reverse_name(addr), '↩️ Reverse Record', true);
}
function create_resolve_btn(s, html = '↩️ Resolve') {
	let btn = document.createElement('button');
	btn.innerHTML = html;
	btn.title = s;
	btn.addEventListener('click', () => {
		input_field.value = s;
		resolve();
	});
	return btn;
}

function set_length(el, n, unit = 'ch') {
	el.classList.add('length');
	el.innerHTML = `${n}<sub>${unit}</sub>`;
	return el;
}

function create_main_span(text) {
	let inner = document.createElement('span');
	inner.classList.add('main', 'long');
	inner.innerText = text;
	let outer = document.createElement('span');
	outer.append(inner);
	return outer;
}
function create_pretty_tag() {
	let span = document.createElement('span');
	span.classList.add('clean');
	span.innerHTML = PRETTY_NAME;
	span.title = 'Beautified Form';
	return span;
}
function create_iface_tag(name, iface, addr) {
	let title =`<b>${name}</b>`;
	if (iface) title += `<code>${iface.slice(2)}</code>`;
	let a = create_etherscan_address_link(addr, {title, contract: true});
	a.classList.add('iface');
	return a;
}

function upgrade_split_type(info) {
	if (info.type !== 'Latin') return;
	let cps = info.tokens.flatMap(x => x.is_emoji ? [] : x);
	if (cps.every(cp => cp < 0x80)) {
		info.type = 'ASCII';	
	} else if (/[ąçęşìíîïǐł]/u.test(str_from_cps(cps))) {
		info.rare = true;
	}
}

function make_normalized(row, name) {
	row.classList.add('normalized');
	let span = document.createElement('span');
	span.title = 'Normalized Form';
	let split = ens_split(name);
	if (split.every(x => x.type === 'ASCII')) {
		span.classList.add('clean');
		span.innerHTML = `✅️`; 
	} else if (split.every(x => x.type === 'Emoji')) {
		span.classList.add('normalized');
		span.innerHTML = `✅️ Emoji`; 
	} else {
		split.forEach(upgrade_split_type);
		let types = new Set(split.map(x => x.type));
		types.delete('Emoji');
		if (types.size > 1 && types.has('ASCII')) types.delete('ASCII');
		span.classList.add('normalized');
		span.innerHTML = `✅️ ${[...types].join('+')}`;
		if (split.some(x => x.emoji)) {
			span.innerHTML += ' w/Emoji';
		}
		if (split.some(x => x.rare)) {
			let span = document.createElement('span');
			span.innerHTML = 'Possibly<br>Confusing';
			span.style.cssText = `
				color: #fff;
				background-color: #d47;
				margin: -8px 0;
				text-align: center;
				font-size: 75%;
			`;
			add_row_tag(row, span);
		}
	}
	add_row_tag(row, span);	
}

function make_contract(row) {
	row.classList.add('contract');
	let span = row.querySelector('.row-label');
	span.innerHTML = span.innerHTML.replace('Address', 'Contract'); // meh
}

function create_palindrome_tag() {
	let span = document.createElement('span');
	span.classList.add('palindrome');
	span.innerHTML = '⇄ Palindrome';
	return span;
}

function create_ethmoji_row(tokens, suffix) {
	let row = create_row('Ethmoji');
	row.classList.add('category', 'ethmoji');
	add_detailed(row);
	let unique = new Set();
	let grouped = [];
	let last;
	for (let token of tokens) {
		let form = String.fromCodePoint(...token.emoji);
		token.form = form; // save
		unique.add(form);
		if (!last || last.form !== form) {
			grouped.push(token);
			token.count = 1;
			last = token;
		} else {
			last.count++;
		}
	}
	let formula = document.createElement('div');
	formula.classList.add('formula');
	formula.innerHTML = grouped.map(token => {
		return `<a href="./emoji.html#q=${String.fromCodePoint(...token.cps)}">${token.form}<sup>${token.count}</sup></a>`;
	}).join('');
	row.append(formula);
	let span_grade = document.createElement('span');
	let min_repeated;
	if (tokens.every(t => t.emoji[2] == 0x20E3)) {
		if (tokens.length == 2) {
			add_row_tag(row, create_typed_tag('fire', 'Shortest Keycaps'));
		} else {
			add_row_tag(row, create_typed_tag('second', 'Keycaps'));
		}
	} else if (unique.size == 1) {
		let ncp = last.cps.length;
		let repeat = 1 + Math.max(0, MIN_LENGTH - ncp);
		if (last.count === repeat) {
			add_row_tag(row, create_typed_tag('fire', last.count == 1 ? 'Single' : 'Shortest Repeated'));
		} else {
			add_row_tag(row, create_typed_tag('second', 'Repeated'));
			min_repeated = String.fromCodePoint(...last.cps).repeat(repeat);
		}
	} else {
		add_row_tag(row, `Unique: ${unique.size}`);
	}
	if (tokens.every((x, i) => x.form == tokens[tokens.length-1-i].form)) {
		add_row_tag(row, create_palindrome_tag());
	}
	if (min_repeated) {
		add_row_tag(row, create_resolve_btn(min_repeated + suffix, '↩️ Shortest'));
	}
	return row;
}

function create_digits_row(norm, group, values, negative, suffix) {
	//let row = create_row(`${name0} Digits`);
	let row = create_row('Integer');
	row.classList.add('category', 'integer');
	add_detailed(row);
	let sign = negative ? '-' : '';
	let form = sign + values.join('');
	if (norm !== form) {
		let main = document.createElement('code');
		main.innerText = form;
		main.classList.add('long'); 
		row.append(main);
	}
	if (values.length == (negative ? 2 : 3)) {
		add_row_tag(row, create_typed_tag('fire', 'Shortest'));
	}
	if (values.every((x, i) => x == values[0])) {
		add_row_tag(row, create_typed_tag('second', `Repeated (${values.length})`));
	}
	if (negative) {
		add_row_tag(row, 'Negative');
	} else if (values.every((x, i) => x == values[values.length-1-i])) {
		add_row_tag(row, create_palindrome_tag());
	}	
	let pad = 0;
	while (values[pad] === 0) pad++;
	if (pad) {
		add_row_tag(row, `Zero Pad (${pad})`);
	}
	let btn = create_resolve_btn((negative ? KEYCAP_MINUS : '') + values.map(keycap).join('') + suffix, KEYCAP_NAME);
	btn.disabled = group === KEYCAP_NAME;
	add_row_tag(row, btn);
	for (let [name, digits] of DIGITS_MAP) {
		//if (name0 === name) continue;
		let btn = create_resolve_btn(sign + values.map(x => digits.charAt(x)).join('') + suffix, name);
		btn.disabled = group === name;
		add_row_tag(row, btn);
	}
	return row;
}

function add_contract_name(row, address) {
	let name = RESOLVER_NAMES[address];
	if (name) {
		add_row_tag(row, create_typed_tag('good', name));
	}
}

function add_old_tag(row, name, is_norm) {
	const OLD_NAME = 'ENSIP-1';
	let span = document.createElement('span');
	span.classList.add('tags', 'old');
	try {
		let norm0 = eth_ens_namehash.normalize(name);
		let norm;
		try {
			norm = ens_normalize(name);
		} catch (err) {				
		}
		let html = OLD_NAME;
		if (!is_norm && norm0 !== norm) { // diff-norm
			html += `: ⚠️<b>Diff Norm</b>`;
		}
		if (norm0 === name) {
			span.innerHTML = `✅️ ${html}`;
		} else {
			if (norm === norm0) throw new Error('not normalized');
			add_row_tag(row, create_resolve_btn(norm0, `❌️ ${html}`));
			return;
		}
	} catch (err) {
		span.innerHTML = `❌️ ${OLD_NAME}`;
		span.title = err.message;
	}
	add_row_tag(row, span);
}

function add_nft_links(row, name, contract, token) {
	add_row_tag(row, create_etherscan_nft_link(contract, token));
	add_row_tag(row, create_ens_metadata_link(contract, token));
	add_row_tag(row, create_opensea_link(contract, token));
	try {
		let encoded = encodeURIComponent(name);
		if (encoded.endsWith('.eth')) {
			add_row_tag(row, create_link(`https://www.ens.vision/name/${encoded.slice(0, -4)}`, VISION_NAME));
		}
		add_row_tag(row, create_link(`http://predomain.eth.limo/#/domain/${encoded}`, 'Predomain'));
	} catch (err) {
	}
}

async function add_avatar(row, resolver) {
	try {
		let avatar = await resolver.getAvatar();
		if (!avatar || should_stop_resolving()) return;
		let {url} = avatar;
		try {
			url = new URL(url).toString().replaceAll('#', '%23');	
		} catch (ignored) {
		}
		let img = new Image();
		img.src = url;
		let a = document.createElement('a');
		a.classList.add('avatar');
		a.href = url;
		a.target = '_blank';
		a.append(img);
		row.append(a);
	} catch (err) {
		console.log('Avatar error', avatar, err);
	}
}

// https://github.com/adraffy/keccak.js/blob/main/src/utils.js#L96
function bytes_from_utf8(s) {
	if (typeof s !== 'string') throw new TypeError('expected string');
	let v = [];
	for (let pos = 0, len = s.length; pos < len; ) {
		let cp = s.codePointAt(pos++);
		if (cp < 0x800) {
			if (cp < 0x80) {
				v.push(cp);
			} else {
				v.push(0xC0 | (cp >> 6), 0x80 | (cp & 0x3F));
			}
		} else {
			if (cp < 0x10000) {
				v.push(0xE0 | (cp >> 12), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
			} else {
				v.push(0xF0 | (cp >> 18), 0x80 | ((cp >> 12) & 0x3F), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
				pos++;
			}
		}
	}
	return Uint8Array.from(v);
}
function utf8_from_bytes(v) {
	let cps = [];
	for (let i = 0, n = v.length; i < n; ) {
		let x = v[i++];
		if (x < 0x80) {
			cps.push(x);
		} else if (x < 0xE0) {
			cps.push(((x & 0x1F) << 6) | req_utf8_cont(v, i++));
		} else if (x < 0xF0) {
			cps.push(((x & 0x0F) << 12) | (req_utf8_cont(v, i++) << 6) | req_utf8_cont(v, i++));
		} else {
			cps.push(((x & 0x07) << 18) | (req_utf8_cont(v, i++) << 12) | (req_utf8_cont(v, i++) << 6) | req_utf8_cont(v, i++));
		}
	}
	return String.fromCodePoint(...cps);
}
function req_utf8_cont(v, i) {
	let x = v[i];
	if ((x & 0xC0) != 0x80) throw new Error(`malformed utf8 at ${i}: expected continuation`);
	return x & 0x3F;
}

function name_from_wrapper_bytes(v) {
	if (v.length < 1 || v[v.length-1] != 0) {
		throw new Error('expected null terminator');
	}
	let labels = [];
	for (let pos = 0, end = v.length-1; pos < end; ) {
		let n = v[pos++];
		labels.push(utf8_from_bytes(v.slice(pos, pos += n)));
	}
	return labels.join('.');
}

function make_tokens_div(name, before) {
	// tokenize each label separately so we can show major/minor errors
	// flatten non-errors tokens into wrapper
	let split = ens_split(name);
	let wrapper = document.createElement('div');
	wrapper.classList.add('tokens');
	let first = true;
	for (let i = 0; i < split.length; i++) {
		if (i > 0) {
			wrapper.append(...dom_from_tokens(ens_tokenize('.')).children); 
		}
		let {input, error} = split[i];
		let tokens = dom_from_tokens(ens_tokenize(String.fromCodePoint(...input)), {
			before, 
			emoji_url,
			components: show_components_check.checked,
			tld_class: i == split.length-1
		});
		if (error) {
			tokens.classList.add('error');
			if (first) {
				tokens.classList.add('first');
				first = false;
			}
			wrapper.append(tokens);
		} else {
			wrapper.append(...tokens.children);
		}		
	}
	wrapper.classList.add('exploded');
	wrapper.dataset.name = name;
	if (before) wrapper.dataset.before = 1;
	return wrapper;
}

function update_exploded() {
	for (let exploded of output_div.querySelectorAll('.exploded')) {
		let tokens_div = make_tokens_div(exploded.dataset.name, exploded.dataset.before);
		if (exploded.dataset.downgraded) {
			apply_downgrade(tokens_div);
		}
		exploded.replaceWith(tokens_div);
	}
}

function apply_downgrade(tokens_div) {
	tokens_div.dataset.downgraded = '1';
	for (let x of tokens_div.querySelectorAll('.disallowed')) {
		x.classList.add('ignored');
		x.classList.remove('disallowed');
	}
}

function make_exploded(row, name, is_norm, downgrade_disallowed) {	
	let before = !is_norm;
	let tokens_div = make_tokens_div(name, before);
	if (downgrade_disallowed) {
		apply_downgrade(tokens_div);
	}
	let old = row.querySelector('.exploded');
	if (old) {
		old.replaceWith(tokens_div);
	} else {
		row.append(tokens_div);
	}
}

function create_typed_tag(type, desc) {
	let span = document.createElement('span');
	if (desc instanceof Error) {
		span.classList.add('long');
		desc = desc.message;
	}
	switch (type) {
		case 'second': 
			desc = `⭐️ ${desc}`;
			break;
		case 'fresh': {
			type = 'second';
			desc = `🌻️ ${desc}`;
			break;
		}
		case 'norm':
			//desc = `❌ ${desc}`;
			type = 'warn';
			//break;
		//case 'error':
		//	type = 'fail'
		case 'attn': 
			//desc = `👀️ ${desc}`;
			//break;
		case 'warn': 
			desc = `⚠️ ${desc}`;
			break;
		case 'fire':
			desc = `🔥️ ${desc}`;
			break;
		case 'good': 
			break;
		case 'special':
			break;
		case 'fail': 
			desc = `❌️ ${desc}`;
			break;
		case 'stop':
			type = 'fail';
			desc = `🛑️ ${desc}`;
			break;
		//default: throw new TypeError(`unknown grade: ${type}`);
	}
	span.innerHTML = desc;
	span.classList.add(type);
	return span;
}

function create_namehash_row(name) {
	let row = create_row();
	row.classList.add('details');
	add_detailed(row);
	let hash_span = document.createElement('span');
	hash_span.classList.add('wide');
	hash_span.innerHTML = `<a class="hashproof" href="https://adraffy.github.io/keccak.js/test/demo.html#algo=namehash&s=${encode_uri_component_surrogate_escaped(name)}&escape=1" target="_blank">Namehash:</a> <code>${namehash(name)}</code>`;
	row.append(hash_span);
	return row;
}

function create_details_row(name, before) {
	
	let row = create_namehash_row(name);

	let split = ens_split(name);	

	for (let info of split) {
		info.cps = before || !info.output ? info.input : info.output;
		info.label = String.fromCodePoint(...info.cps);
	}

	for (let i = 0; i < split.length; i++) {

		let info = split[i];
		let {cps, label} = info;
		let hash = labelhash(label);
		
		let footer_span = document.createElement('span');
		footer_span.classList.add('wide', 'footer');

		if (cps.length) {

			let label_div = document.createElement('span');
			label_div.classList.add('label');

			if (info.error) {
				label_div.classList.add('error');
			} else if (compare_arrays(info.input, info.output)) { 
				label_div.classList.add('mapped');
			} else {
				upgrade_split_type(info);
				if (info.type.startsWith('Restricted[')) {
					let script = type.slice(11, -1);
					let a = document.createElement('a');
					a.classList.add('restricted');
					a.innerHTML = `<span>${script}</span>⚠️`;
					a.href = `https://www.compart.com/en/unicode/scripts/${script}`;
					label_div.append(a);
				} else {
					let span = document.createElement('span');
					span.classList.add('group');
					span.innerHTML = info.type;
					if (info.emoji && info.type !== 'Emoji') {
						span.innerHTML += '+';
					}
					if (info.rare) {
						span.style.color = '#d47';
					}
					label_div.append(span);
				}
			}

			let label_span = document.createElement('span');
			label_span.classList.add('text', 'long');
			label_span.innerText = label; // this will <br> CR LF, disabled with css
			label_div.append(label_span);

			let code = document.createElement('code');
			let len_span = document.createElement('span');

			const update_code = () => {
				let {mode} = code.dataset;
				let text;
				if (code.dataset.mode !== 'cp') {
					code.dataset.mode = 'cp';
					code.title = 'Unicode Codepoints';
					text = cps.map(hex_cp).join(' ');
					set_length(len_span, cps.length);
				} else {
					code.dataset.mode = 'byte';
					code.title = 'Encoded UTF-8 Bytes';
					let bytes = bytes_from_utf8(label);
					text = [...bytes].map(hex_cp).join(' ');
					set_length(len_span, bytes.length, 'bytes');
				}
				code.innerText = text + ' ';
				code.append(swap_btn);
			};

			let swap_btn = document.createElement('button');
			swap_btn.innerText = `⇄`;
			swap_btn.title = `Swap Codepoints/Bytes`;
			swap_btn.addEventListener('click', update_code);

			update_code();
			if (cps.every(cp => cp < 0x80)) {
				swap_btn.remove();
			}

			row.append(label_div, len_span, code);
		
			footer_span.classList.add('sep');
		}

		let footer = [`<a class="hashproof" href="https://adraffy.github.io/keccak.js/test/demo.html#algo=keccak-256&s=${encode_uri_component_surrogate_escaped(label)}&escape=1" target="_blank">Labelhash:</a> <code>${hash}</code>`];
		
		let domain = split.slice(i+1).map(x => x.label).join('.');
		if (NFT_DOMAINS.has(domain)) {
			footer.push(`<b>Token:</b> <code>${ethers.BigNumber.from(labelhash(label))}</code>`);
		}

		if (info.error) { 
			footer.unshift(`<span class="error">❌️ ${info.error}</span>`);
		}
		footer_span.innerHTML = footer.join('<br>');
		row.append(footer_span);
	}
	return row;
}

function create_row(label, waiting) {
	let row = document.createElement('div');
	row.classList.add('row');
	if (label) {
		let span = document.createElement('span');
		span.classList.add('row-label');
		if (typeof label === 'string') {
			span.innerHTML = `${label}:`;
		} else {
			span.append(label);
		}
		row.append(span);
	}
	if (waiting) {
		let div = document.createElement('div');
		div.classList.add('temporary');
		div.innerHTML = '<div class="spinner"></div>';
		row.append(div);
	}
	return row;
}

function remove_temporary(row) {
	for (let x of row.querySelectorAll('.temporary')) {
		x.remove();
	}
}

function add_row_tag(row, tag) {
	if (!tag) return;
	if (typeof tag === 'string') {
		let span = document.createElement('span');
		span.innerHTML = tag;
		tag = span;
	}
	tag.classList.add('tags');
	row.append(tag);
	return true;
}

function trim_trailing_decimal_zeros(s) {
	let match = s.match(/^(.*)\.0+$/);
	if (match) return match[1];
	return s;
}
function format_dur(t) {
	if (t < 1000) return `${Math.ceil(t)}ms`;
	t /= 1000;
	let unit;
	if (t < 60) {
		unit = 's';
	} else {
		t /= 60;
		if (t < 60) {
			unit = 'm';
		} else {
			t /= 60;
			if (t < 24) {
				unit = 'h';
			} else {
				t /= 24;
				if (t < 365) {
					unit = 'd';
				} else {
					t /= 365;
					unit = 'y';
				}
			}
		}
	}
	return trim_trailing_decimal_zeros(t.toFixed(1)) + unit;
}

function is_working() {
	return resolve_btn.disabled || !registry_contract;
}

function resolve() {
	if (is_working()) {
		resolve_timer = [0]; // ASAP
		return;
	}
	clearTimeout(resolve_timer);
	resolve_timer = RESOLVE_MODE_IDLE;
	let input = input_field.value;
	let skip = skip_norm_check.checked;
	// replace marketplace URL with token:XXX
	if (input.includes('://')) {
		try {	
			let url = new URL(input);
			if (url.host === 'ens.vision' || url.host === 'www.ens.vision') {
				// https://ens.vision/name/%F0%9F%91%A9%F0%9F%8F%BC%E2%80%8D%F0%9F%A6%BC%E2%80%8D%E2%AC%85
				let v = url.pathname.toLowerCase().split('/').filter(x => x);
				if (v.length >= 2 && v[0] === 'name') {
					input = decodeURIComponent(v[1]);
					if (!input.endsWith('.eth')) input += '.eth';
					input_field.value = input;
				}
			} else { 
				// generalized handler
				// https://opensea.io/assets/ethereum/0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401/65925476150180752387929572463320899353544457962160224303512375154243473029563
				// https://opensea.io/assets/ethereum/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				// https://www.gem.xyz/asset/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				// https://element.market/assets/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/91842011529764390124322931916134555051359118325819011691525342013207339157209
				let v = url.pathname.toLowerCase().split('/').filter(x => x);
				if (v.length >= 2 && /^[a-f0-9]+$/i.test(v[v.length-1])) {
					// TODO: fix this, use ensure_nft() and ensure_wrapper() 
					if (v[v.length-2] === '0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85') {
						input_field.value = input = `token:${v[v.length-1]}`;
					} else if (v[v.length-2] === '0xd4416b13d2b3a9abae7acd5d6c2bbdbe25686401') {
						input_field.value = input = `wrapped:${v[v.length-1]}`;
					}
				}
			}
		} catch (err) {
		}
	}
	let match;
	// replace token:XXX with ens subgraph label (or fail)
	if (match = input.match(/^token:(0x[a-f0-9]+|[0-9]+)$/i)) {
		let hash = ethers.BigNumber.from(match[1]).toHexString();
		resolve_btn.disabled = true;
		return (async() => {
			try {
				if (chain_id !== CHAIN_ID_MAINNET) throw new Error(`token: only works on mainnet`);
				let res = await fetch('https://api.thegraph.com/subgraphs/name/ensdomains/ens', {
					method: 'POST',
					body: JSON.stringify({
						query: `{domains(where:{labelhash:"${hash}"}){labelName}}`
					})
				});
				if (!res.ok) throw new Error(`HTTP Error ${r.status}`);
				let {data: {domains}} = await res.json();
				if (domains.length == 0) throw new Error(`Unknown Preimage: ${hash}`);
				let label = domains[0].labelName;
				let hash0 = labelhash(label);
				if (hash0 !== hash) throw new Error(`Incorrect Preimage: labelhash("${label}")\n\nExpected: ${hash}\nComputed: ${hash}`);
				input_field.value = `${label}.eth`;
				setTimeout(resolve, 0);
			} catch (err) {
				window.alert(err.message);
				stop_resolving();
			}
			resolve_btn.disabled = false;
		})();
	} else if (match = input.match(/^wrapped:(0x[a-f0-9]+|[0-9]+)$/i)) {
		resolve_btn.disabled = true;
		return (async () => {
			try {
				await ensure_wrapper();
				let bytes = await wrapper_contract.callStatic.names(ethers.BigNumber.from(match[1]));
				input_field.value = name_from_wrapper_bytes(ethers.utils.arrayify(bytes));
				resolve_btn.disabled = false;
				setTimeout(resolve, 0);
			} catch (err) {
				window.alert(err.message);
				stop_resolving();
			}
			resolve_btn.disabled = false;		
		})();
	}
	// input convenience: expand range
	if (match = input.match(/^range:([0-9a-f]+)\.\.([0-9a-f]+)$/i)) {
		let lo = parseInt(match[1], 16);
		let hi = parseInt(match[2], 16);
		if (hi >= lo) {
			input = String.fromCodePoint(...Array(1 + hi - lo).fill().map((_, i) => lo + i));
		}
	}
	// input convenience: HEX HEX HEX => {HEX}{HEX}
	if (/^\s*[0-9a-f]{2,}(\s+[0-9a-f]{2,})+\s*$/i.test(input)) { 
		input = input.trim().split(/\s+/).map(x => `{${x}}`).join('');	
	}
	// input convenience: entities
	input = input.replace(/&#?[0-9a-z]+;/gui, x => {
		entity_span.innerHTML = x;
		return apply_escapes(entity_span.innerText);
	});
	input_field.value = input;
	let name = replace_name(replace_escapes(input));
	add_recent(name);
	if (!parse() && !skip) {
		primary_loader.classList.add('hide');
		return;
	}
	resolve_btn.disabled = true;
	primary_loader.classList.remove('hide');
	resolve_date0 = new Date();
	resolve0(name, skip).then(() => {
		resolve_btn.disabled = false;
		if (Array.isArray(resolve_timer)) {
			setTimeout(resolve, Math.max(0, resolve_timer[0] - Date.now()));
		} else {
			primary_loader.classList.add('hide');
		}
	});
}

function create_elapsed() {
	let now = new Date();
	let delta = now - resolve_date0;
	if (delta < 1) return; // 0ms is stupid
	let span = document.createElement('span');
	span.classList.add('elapsed');
	span.innerHTML = format_dur(delta);
	resolve_date0 = now;
	return span;
}

async function resolve0(input, skip_norm) {
	output_div.innerHTML = '';
	//output_div.append(links_copy);

	let input_is_address = is_checksum_address(input);
	let input_row;
	let normed_row;
	let reverse_row;
	let name_norm;
	let norm_err;

	if (input_is_address) {
		input_row = create_row('Address');
		input_row.append(create_etherscan_address_link(input));
		add_row_tag(input_row, create_copy_btn(input));
		add_row_tag(input_row, create_reverse_resolve_btn(input));

		// doesn't give enough information
		// primary = await active_provider.lookupAddress(input);

		let rev_name = reverse_name(input);
		let rev_node = namehash(rev_name);

		let rev_details = create_namehash_row(rev_name);
		let rev_name_span = document.createElement('span');
		rev_name_span.classList.add('wide');
		rev_name_span.innerHTML = `<b>Reverse Name:</b> ${rev_name}`;
		rev_details.prepend(rev_name_span);

		output_div.append(input_row, rev_details);

		let resolver_row = create_row('Reverse Resolver', true); // ↺ 
		output_div.append(resolver_row);

		try {
			if (!is_null_hex(await active_provider.getCode(input))) {
				make_contract(input_row);
			}
		} catch (err) {
		}
		if (should_stop_resolving()) return;

		let resolver, last_err;
		try {
			resolver = await registry_contract.callStatic.resolver(rev_node);
		} catch (err) {	
			last_err = err;
		} 
		if (should_stop_resolving()) return;
		remove_temporary(resolver_row);
		add_row_tag(resolver_row, create_elapsed());

		try {
			if (reverse_registrar === null) {
				reverse_registrar = await registry_contract.callStatic.owner(namehash(REVERSE_DOMAIN));
			}
		} catch (err) {
			reverse_registrar = false;
		}
		if (should_stop_resolving()) return;

		if (reverse_registrar) {
			let set_name_btn = document.createElement('button');
			set_name_btn.classList.add('glow');
			set_name_btn.innerHTML = '✍️ Set Name';
			set_name_btn.addEventListener('click', () => {
				create_etherscan_address_link(reverse_registrar, {anchor: '#writeContract#F7'}).click();
			});
			add_row_tag(input_row, set_name_btn);
		}

		if (last_err) {
			resolver_row.classList.add('error');
			add_row_tag(resolver_row, create_typed_tag('warn', last_err));
			return;
		} else if (!resolver || is_null_hex(resolver)) {
			add_row_tag(resolver_row, create_typed_tag('stop', 'Primary Not Set'));
			return;
		}

		resolver_row.append(create_etherscan_address_link(resolver, {contract: true}));
		add_contract_name(resolver_row, resolver);
		add_row_tag(resolver_row, create_copy_btn(resolver));

		reverse_row = normed_row = create_row('Reverse', true);
		output_div.append(reverse_row);
			
		let primary;
		try {
			let contract = new ethers.Contract(resolver, [
				`function name(bytes32 node) view returns (string)`
			], active_provider);
			primary = await contract.callStatic.name(rev_node);
		} catch (err) {	
			last_err = err;
		} 
		if (should_stop_resolving()) return;
		remove_temporary(reverse_row);
		add_row_tag(reverse_row, create_elapsed());
		if (last_err) {
			reverse_row.classList.add('error');
			add_row_tag(reverse_row, create_typed_tag('warn', last_err));
			return;
		} else if (!primary) {
			add_row_tag(reverse_row, create_typed_tag('stop', 'Primary is Null'));
			return;
		}

		make_exploded(reverse_row, primary, false);
		add_row_tag(reverse_row, create_copy_btn(primary));
		add_row_tag(reverse_row, create_ens_link(primary));
		//add_nft_links(reverse_row, primary);
		output_div.append(create_details_row(primary, true));
			
		try {
			name_norm = ens_normalize(primary);
		} catch (err) {
			reverse_row.classList.add('error');
			add_row_tag(reverse_row, create_typed_tag('norm', err));
			if (!skip_norm) return;
			name_norm = primary;
			norm_err = err;
		}
		if (!norm_err) {
			if (name_norm === primary) {
				add_row_tag(reverse_row, create_resolve_btn(primary));
				make_normalized(reverse_row, name_norm);
			} else {
				add_row_tag(reverse_row, create_typed_tag('fail', 'Normalized'));
				let row = normed_row = create_row('Normalized Reverse');
				make_exploded(row, name_norm, true);
				add_row_tag(row, create_copy_btn(name_norm));
				add_row_tag(row, create_resolve_btn(name_norm));
				make_normalized(row, name_norm);
				output_div.append(row);
				output_div.append(create_details_row(name_norm));
			}	
		}
	} else {
		
		// the input is a name
		input_row = normed_row = create_row(INPUT_NAME);
		input_row.classList.add('input');
		make_exploded(input_row, input, false);
		add_row_tag(input_row, create_ens_link(input));
		output_div.append(input_row);
		output_div.append(create_details_row(input, true));
		add_row_tag(input_row, create_copy_btn(input));

		if (/^0x[0-9a-f]{40}$/i.test(input)) {
			add_row_tag(input_row, create_resolve_btn(ethers.utils.getAddress(input.toLowerCase()), '🛠️ Fix Checksum'));
		}
		if (!input.includes('.')) {
			add_row_tag(input_row, create_resolve_btn(`${input}.eth`, '🔄️ Add <b>".eth"</b>'));
		}

		try {
			name_norm = ens_normalize(input);
		} catch (err) {
			input_row.classList.add('error');
			add_row_tag(input_row, create_typed_tag('norm', err));
			if (!skip_norm) return; // i think this is always true
			name_norm = input;
			norm_err = err;
		}	

		if (norm_err) {
			//add_nft_links(input_row, input);
		} else {
			if (name_norm === input) {
				make_normalized(input_row, name_norm);
				//add_nft_links(input_row, input);
			} else  { 
				add_row_tag(input_row, create_typed_tag('fail', 'Normalized'));
				if (skip_norm) {
					name_norm = input;
				} else {
					add_transformed_row(input);
					let row = normed_row = create_row('Normalized');
					make_exploded(row, name_norm, true);
					make_normalized(row, name_norm);
					add_row_tag(row, create_copy_btn(name_norm));
					add_row_tag(row, create_resolve_btn(name_norm));
					add_row_tag(row, create_ens_link(name_norm));
					//add_nft_links(row, name_norm);
					add_old_tag(row, name_norm, true);
					output_div.append(row);
					output_div.append(create_details_row(name_norm));
				}
			}
		}
		add_old_tag(input_row, input);
	}

	let sep_pos = name_norm.indexOf('.');
	if (sep_pos == -1) sep_pos = name_norm.length;
	if (sep_pos > 0) {
		let prefix = name_norm.slice(0, sep_pos);
		let suffix = name_norm.slice(sep_pos); 
		let tokens = ens_tokenize(prefix);
		if (tokens.every(t => t.type === 'emoji')) {
			output_div.append(create_ethmoji_row(tokens, suffix));
			let negative = String.fromCodePoint(...tokens[0].emoji) == KEYCAP_MINUS;
			if (negative) tokens = tokens.slice(1);
			let values = tokens.map(x => x.emoji[0] - 0x30);
			if (values.every(x => x >= 0 && x < 10)) {
				output_div.append(create_digits_row(name_norm, KEYCAP_NAME, values, negative, suffix));
			}
		} else {
			let negative = prefix.startsWith('-');
			if (negative) prefix = prefix.slice(1);
			if (prefix) {
				let cps = explode_cp(prefix);
				let digits = cps.map(cp => DIGIT_MAP.get(cp));
				if (digits.every(x => x)) {
					let values = digits.map(x => x.i);
					let name0 = digits[0].name;
					if (digits.every(x => x.name === name0)) {
						//if (digits[0].reversed) values.reverse(); // LTR
						output_div.append(create_digits_row(name_norm, name0, values, negative, suffix));
					} else {
						let first = digits[0].mixed;
						if (first && digits.every(x => x.mixed == first)) {
							let row = create_digits_row(name_norm, 'Arabic', values, negative, suffix); //values.reverse()); // LTR
							add_row_tag(row, create_typed_tag('warn', 'Mixed Digits'));
							output_div.append(row);
						} else {
							let row = create_digits_row(name_norm, 'Numeric', values, negative, suffix);
							add_row_tag(row, create_typed_tag('warn', 'Multiple Scripts'));
							output_div.append(row);
						}
					}
				}
			}
		}
	}

	if (!skip_norm && !norm_err) {
		let pretty = ens_beautify(name_norm);
		let row = create_row(`Beautified`);
		row.classList.add('pretty');
		row.append(create_main_span(pretty));
		add_row_tag(row, create_copy_btn(pretty));
		if (input !== pretty) {
			add_row_tag(row, create_resolve_btn(pretty));
		}
		add_row_tag(row, create_pretty_tag());
		if (input === pretty) { 
			add_row_tag(input_row, create_pretty_tag());
			add_row_tag(row, create_typed_tag('good', 'Same as Input'));
		} else if (name_norm === pretty) {			
			add_row_tag(normed_row, create_pretty_tag());
			add_row_tag(row, create_typed_tag('good', 'Same as Norm'));
		}
		add_old_tag(row, pretty);
		output_div.append(row);
	}

	output_div.append(create_dns_row(name_norm));

	// at this point, we have a name
	// lookup the name
	let resolver, resolver_err;
	let is_wildcard, wildcard_domain;
	let resolver_row = create_row('Resolver', true);
	output_div.append(resolver_row);
	try {
		resolver = await active_provider.getResolver(name_norm);
	} catch (err) {
		resolver_err = err;
	}
	if (should_stop_resolving()) return;
	if (resolver) {
		is_wildcard = await resolver.supportsWildcard();
		if (should_stop_resolving()) return;
		if (is_wildcard) { 
			// ethers doesn't expose this information
			// https://github.com/ethers-io/ethers.js/issues/3398
			let v = name_norm.split('.');
			try {
				while (true) {
					let parent = v.join('.');
					let address = await registry_contract.callStatic.resolver(namehash(parent));
					if (should_stop_resolving()) return;
					if (address === resolver.address) {
						wildcard_domain = parent;
						break;
					}	
					v.shift();
				}
			} catch (ignored) {
			}
		}
		await add_avatar(normed_row, resolver);	
		if (should_stop_resolving()) return;
	}
	remove_temporary(resolver_row);	
	add_row_tag(resolver_row, create_elapsed());
	
	if (resolver_err) {
		resolver_row.classList.add('error');
		add_row_tag(resolver_row, create_typed_tag('warn', resolver_err));
		return;	
	}
	
	// name doesn't exist
	if (resolver) { 
		resolver_row.append(create_etherscan_address_link(resolver.address, {contract: true}));
		add_row_tag(resolver_row, create_copy_btn(resolver.address));
		if (is_wildcard) {
			add_row_tag(resolver_row, create_typed_tag('special', 'Wildcard'));
			if (wildcard_domain === name_norm) {
				add_row_tag(resolver_row, 'Root');
			} else if (wildcard_domain) {
				add_row_tag(resolver_row, create_resolve_btn(wildcard_domain, `↩️ ${wildcard_domain}`));
			} else {
				add_row_tag(resolver_row, create_typed_tag('warn', 'Unknown Parent'));
			}
		} else {
			add_contract_name(resolver_row, resolver.address);
		}
	} else {
		add_row_tag(resolver_row, create_typed_tag('warn', `Name Not Found`));	
	}

	let domain = name_norm.slice(sep_pos+1);
	let nft_backed = NFT_DOMAINS.has(name_norm.slice(sep_pos+1));
	let nft_contract;
	let nft_token;

	let available;	
	if (domain === ETH_TLD) {
		let eth_label = name_norm.slice(0, sep_pos);
		nft_token = ethers.utils.id(eth_label);
		let avail_err;
		let expiry;
		let len = [...eth_label].length;
		let avail_row = create_row('Availability', true);
		let premium;
		output_div.append(avail_row);
		try {
			await ensure_eth_nft();
			if (should_stop_resolving()) return;
			nft_contract = eth_nft_contract;
			if (len >= MIN_LENGTH) {
				available = await eth_nft_contract.callStatic.available(nft_token);
				if (should_stop_resolving()) return;
				expiry = (await eth_nft_contract.callStatic.nameExpires(nft_token)).toNumber();
				if (available) {
					if (should_stop_resolving()) return;
					premium = await price_oracle_contract.callStatic.premium(eth_label, expiry, 0);
				}
			}
		} catch (err) {
			avail_err = err;
		}
		remove_temporary(avail_row);
		if (should_stop_resolving()) return;
		add_row_tag(avail_row, create_elapsed()); 
		add_row_tag(avail_row, set_length(document.createElement('span'), len));

		if (avail_err) {
			avail_row.classList.add('error');
			add_row_tag(avail_row, create_typed_tag('warn', avail_err));
		} else if (available === undefined) {
			add_row_tag(avail_row, create_typed_tag('fail', `Too Short`));
			let padded = Array(1 + Math.max(0, MIN_LENGTH - len)).fill(eth_label).join('');
			add_row_tag(avail_row, create_resolve_btn(`${padded}.eth`, '↩️ Repeat until 3+'));
		} else if (available) {
			let btn = document.createElement('button');
			btn.innerHTML = '👌️ Available to Register';
			btn.classList.add('glow');
			btn.addEventListener('click', () => create_ens_link(name_norm).click());
			add_row_tag(avail_row, btn);
			let ether = parseFloat(ethers.utils.formatEther(premium));
			if (ether) {
				add_row_tag(avail_row, create_typed_tag('warn', `${ether.toFixed(ether < 1 ? 4 : 2)}Ξ Premium`));
			}
			//add_row_tag(avail_row, create_typed_tag('fire', 'Available'));
			//add_row_tag(avail_row, create_ens_link(name_norm, {title: 'Register'}));
		} else {
			let exp = expiry * 1000;
			let end = exp + eth_nft_contract.grace_period;
			let now = Date.now();
			if (now >= exp && now <= end) {
				add_row_tag(avail_row, create_typed_tag('warn', `Grace period (${format_dur(eth_nft_contract.grace_period)}) ends in ${format_dur(end - now)}`));
			} else {
				let span_reg = document.createElement('span');
				span_reg.innerText = `✍️ Registered until ${new Date(exp).toLocaleDateString()}`;
				span_reg.style.backgroundColor = '#def';
				add_row_tag(avail_row, span_reg);
				if (exp - now < eth_nft_contract.warning_period) {
					add_row_tag(avail_row, create_typed_tag('warn', `Expires in ${format_dur(exp - now)}`));
				} else {
					span_reg.innerHTML += ` (${format_dur(exp - now)})`;
				}
			}
		}
		//add_row_tag(avail_row, create_etherscan_address_link(price_oracle_contract.address, {title: 'Price Oracle', contract: true}));
	} else if (nft_backed) {
		let label = name_norm.slice(0, sep_pos);		
		nft_token = ethers.utils.id(label);
		let avail_err;
		let avail_row = create_row('Availability', true);
		output_div.append(avail_row);
		try {
			let address = await registry_contract.callStatic.owner(namehash(domain));
			if (is_null_hex(address)) throw new Error('Missing backing contract');
			nft_contract = new ethers.Contract(address, [
				'function available(uint256 id) external view returns(bool)',
				'function ownerOf(uint256 id) external view returns (address)',
			], active_provider);
		} catch (err) {
			avail_err = err;
		}
		remove_temporary(avail_row);
		if (should_stop_resolving()) return;
		add_row_tag(avail_row, create_elapsed()); 
		if (avail_err) {
			avail_row.classList.add('error');
			add_row_tag(avail_row, create_typed_tag('warn', avail_err));
		} else {
			add_row_tag(avail_row, create_typed_tag(available ? 'good' : 'fail', 'Available'));
			if (chain_id === CHAIN_ID_MAINNET && domain === 'art') {
				add_row_tag(avail_row, create_link(`https://app.protocol.art/name/${encodeURIComponent(label)}.art`, 'Website'));
			}
			add_row_tag(avail_row, create_etherscan_address_link(nft_contract.address, {title: 'NFT Contract', contract: true}));
		}
	}
	
	// get the owner
	let is_wrapped, owner, nft_owner;
	if (!is_wildcard || wildcard_domain === name_norm) {
		let node = namehash(name_norm);
		let wrapped_err;
		let wrapped_row = create_row('Wrapper', true);
		output_div.append(wrapped_row);
		try {
			await ensure_wrapper();
			if (should_stop_resolving()) return;
			is_wrapped = await wrapper_contract.callStatic.isWrapped(node);
		} catch (err) {
			wrapped_err = err;
		}
		remove_temporary(wrapped_row);
		if (should_stop_resolving()) return;
		add_row_tag(wrapped_row, create_elapsed());
		if (wrapped_err) {
			wrapped_row.classList.add('error');
			add_row_tag(wrapped_row, create_typed_tag('warn', wrapped_err));
		} else {
			add_row_tag(wrapped_row, is_wrapped ? create_typed_tag('good', '🎁 Wrapped') : '🎉 Unwrapped');
		}
		if (wrapper_contract) {
			let label = wrapped_row.querySelector('.row-label');
			let title = label.innerHTML;
			label.innerHTML = '';
			label.append(create_etherscan_address_link(wrapper_contract.address, {title, contract: true}));
		}
		if (is_wrapped) {
			add_nft_links(normed_row, name_norm, wrapper_contract.address, node);
			/*if (nft_contract) {
				add_row_tag(wrapped_row, create_etherscan_nft_link(nft_contract.address, nft_token));
				add_row_tag(wrapped_row, create_opensea_link(nft_contract.address, nft_token));
			}*/
		} else if (nft_contract) {
			add_nft_links(normed_row, name_norm, nft_contract.address, nft_token);
		}
		// there doesn't seem to be an "owner"
		//owner = await resolver._fetch('0x02571be3'); // owner(bytes32)
		//owner = await resolver._fetch('0x38a699a4'); // exists(bytes32)
		//owner = await resolver._fetch('0x7dd56411'); // ownerOf(bytes32)
		let owner_row = create_row(available ? 'Previous Owner' : 'Owner', true);
		let owner_err;
		let checked_nft;
		output_div.append(owner_row);
		try {
			if (is_wrapped) {
				let data = await wrapper_contract.callStatic.getData(node);
				if (should_stop_resolving()) return;
				owner = data.owner;

				let {fuses} = data;
				if (!(fuses & (1 << 17))) { // eth
					await ensure_eth_nft(); 
					if (should_stop_resolving()) return;
					let exp = data.expiry * 1000 - eth_nft_contract.grace_period; // includes grace
					let now = Date.now();
					if (exp > now) {
						add_row_tag(wrapped_row, create_typed_tag('warn', `Expires in ${format_dur(exp - now)}`));
					}
				}
				if (fuses == 0) add_row_tag(wrapped_row, '👊️ Can Do Everything');
				if (fuses & 0x00001) add_row_tag(wrapped_row, '🚫️ Unwrap');
				if (fuses & 0x00002) add_row_tag(wrapped_row, '🚫️ Burn Fuses');
				if (fuses & 0x00004) add_row_tag(wrapped_row, '🚫️ Transfer');
				if (fuses & 0x00008) add_row_tag(wrapped_row, '🚫️ Set Resolver');
				if (fuses & 0x00010) add_row_tag(wrapped_row, '🚫️ Set TTL');
				if (fuses & 0x00020) add_row_tag(wrapped_row, '🚫️ Subdomains');
				if (fuses & 0x00040) add_row_tag(wrapped_row, '🚫️ Approve');
				if (fuses & 0x10000) add_row_tag(wrapped_row, create_typed_tag('warn', 'Parent Controlled'));
				if (fuses & 0x40000) add_row_tag(wrapped_row, '☑️ Extend Expiry');
			} else {
				owner = await registry_contract.callStatic.owner(node);
				if (should_stop_resolving()) return;
				if (is_null_hex(owner)) owner = false;
				if (!owner && nft_contract) {
					checked_nft = true;
					owner = await nft_contract.callStatic.ownerOf(nft_token).catch(() => {});
					if (is_null_hex(owner)) owner = false;
				}
			}
		} catch (err) {
			owner_err = err;
		}
		remove_temporary(owner_row);
		if (should_stop_resolving()) return;
		add_row_tag(owner_row, create_elapsed());
		if (owner_err) {
			owner_row.classList.add('error');
			owner_row.append(create_typed_tag('warn', owner_err));
		} else if (!owner) {
			if (available) {
				add_row_tag(owner_row, create_typed_tag('fresh', '<i>None</i>'));
			} else {
				add_row_tag(owner_row, 'Not Set');
			}
		} else {
			owner_row.classList.add(available ? 'old' : 'owner');
			owner_row.append(create_etherscan_address_link(owner));
			add_row_tag(owner_row, create_copy_btn(owner));
			//owner_row.classList.toggle('old', available);
			// if the input was an address, we can validate
			if (input_is_address) {
				add_row_tag(reverse_row, create_typed_tag(owner === input ? 'good' : 'fail', 'Owned'));
				if (owner === input) {
					add_row_tag(owner_row, 'Same as Input');
				}
			}
			if (owner !== input) {
				add_row_tag(owner_row, create_resolve_btn(owner));
			}
			if (!is_wrapped && !checked_nft && nft_contract) {
				let nft_row = create_row(create_etherscan_address_link(nft_contract.address, {title: 'NFT Owner:', contract: true}), true);
				output_div.append(nft_row);
				try {
					await ensure_eth_nft();
					nft_owner = await nft_contract.callStatic.ownerOf(nft_token);
					if (is_null_hex(nft_owner)) nft_owner = false;
				} catch (err) {				
				}
				if (should_stop_resolving()) return;
				if (nft_owner && nft_owner !== owner) {
					owner_row.querySelector('.row-label').innerText = 'Manager:';
					nft_row.append(create_etherscan_address_link(nft_owner));
					add_row_tag(nft_row, create_copy_btn(nft_owner));
					if (owner !== input) {
						add_row_tag(nft_row, create_resolve_btn(nft_owner));
					}
					add_row_tag(nft_row, create_elapsed());
					remove_temporary(nft_row);
					nft_row.classList.toggle('old', !!available);
				} else {
					nft_row.remove();
				}
			}
		}
	}

	if (resolver && !NOT_IFACE_RESOLVER.has(resolver.address)) {
		let row = create_row('<a href="https://docs.ens.domains/contract-api-reference/.eth-permanent-registrar#discovery">Interfaces</a>', true);
		output_div.append(row);	
		let contract = contract_for_resolver(resolver);
		// https://docs.ens.domains/contract-api-reference/.eth-permanent-registrar	
		let interfaces = [
			{iface: '0x80ac58cd', name: 'NFT'},  
			{iface: '0x018fac06', name: 'Controller', children: [
				{
					name: 'Price Oracle', 
					async get(addr) {
						let contract = await price_oracle_from_controller(addr);
						return contract.address;
					}
				}
			]},
			{iface: '0x612e8c09', name: 'Registrar'},
			{iface: '0x6ccb2df4', name: 'Old Registrar'},
			{iface: '0x7ba18ba1', name: 'Migration'},
			{iface: '0x019a38fe', name: 'Wrapper'},
		];
		let any;
		try {
			// https://github.com/ensdomains/ens-contracts/blob/dev/contracts/resolvers/profiles/IInterfaceResolver.sol
			if (!await contract.callStatic.supportsInterface('0x124a319c')) {
				throw new Error('not EIP-165');
			}
			for (let {iface, name, children} of interfaces) {
				let addr = await contract.get_interface(iface);
				if (is_null_hex(addr)) continue;					
				add_row_tag(row, create_iface_tag(name, iface, addr));
				any = true;
				if (children) {
					for (let child of children) {
						try {
							let derived_addr = await child.get(addr);
							if (is_null_hex(derived_addr)) continue;
							add_row_tag(row, create_iface_tag(child.name, null, derived_addr));
						} catch (ignored) {
						}
					}
				}
			}
		} catch (err) {
			if (any) {
				add_row_tag(row, create_typed_tag('warn', err));
			}
		}
		if (any) {
			remove_temporary(row);
			add_row_tag(row, create_elapsed()); 
		} else {
			row.remove();
			NOT_IFACE_RESOLVER.add(resolver.address);
		}
		if (should_stop_resolving()) return;
	}

	// add address
	let address;
	if (resolver) {
		let address_err;
		let address_row = create_row(`ETH Address`, true);
		address_row.classList.add(available ? 'old' : 'addr');
		output_div.append(address_row);	
		try {
			address = await resolver.getAddress();
			if (is_null_hex(address)) address = false;
		} catch (err) {
			address_err = err;
		}
		if (address) {
			try {
				if (should_stop_resolving()) return;
				if (!is_null_hex(await active_provider.getCode(address))) {
					make_contract(address_row);
				}
			} catch (err) {
			}			
		} 
		if (should_stop_resolving()) return;
		remove_temporary(address_row);
		if (address_err) {
			address_row.classList.add('error');
			add_row_tag(address_row, create_typed_tag('warn', address_err));
		} else if (!address) {
			add_row_tag(address_row, create_typed_tag('warn', 'Not Set'));
		} else {
			address_row.append(create_etherscan_address_link(address));
			if (input_is_address) {
				if (address === input) {
					add_row_tag(input_row, create_typed_tag('fire', 'Primary'));
					add_row_tag(address_row, 'Same as Input');
				} else if (address) {
					add_row_tag(address_row, create_copy_btn(address));
					add_row_tag(address_row, create_resolve_btn(address));
					add_row_tag(address_row, create_typed_tag('warn', 'Different from Owner'));	
				}
			} else {
				if (owner === address) {
					if (nft_owner && nft_owner !== address) {
						add_row_tag(address_row, create_typed_tag('good', `Same as Manager`));	
					} else {
						add_row_tag(address_row, create_typed_tag('good', 'Same as Owner'));
					}
				} else if (nft_owner === address) {
					add_row_tag(address_row, create_typed_tag('good', 'Same as NFT Owner'));
				} else {
					add_row_tag(address_row, create_copy_btn(address));
					add_row_tag(address_row, create_resolve_btn(address));
					if (owner) {
						//add_row_tag(address_row, create_typed_tag('warn', 'Not Owner'));	
						add_row_tag(address_row, create_typed_tag('fail', 'Owner'));	
					}
				}
				add_row_tag(address_row, create_link(`https://opensea.io/${address}?tab=collected`, OPENSEA_NAME));
				add_row_tag(address_row, create_link(`https://ens.vision/0x/${address}`, VISION_NAME));	
				add_row_tag(address_row, create_link(`https://rainbow.me/${address}`, 'Rainbow'));	
			}
		}
		add_row_tag(address_row, create_elapsed());	
	}

	if (input_is_address || !address) return; // nothing more to do

	// lookup primary from eth address 
	let primary, primary_err;
	let primary_row = create_row('Primary', true);
	output_div.append(primary_row);
	try {
		primary = await active_provider.lookupAddress(address);
	} catch (err) {
		primary_err = err;
	}
	remove_temporary(primary_row);
	if (should_stop_resolving()) return;
	add_row_tag(primary_row, create_elapsed());

	primary_row.classList.toggle('old', !!available);
	
	if (primary_err) {
		primary_row.classList.add('error');
		add_row_tag(primary_row, create_typed_tag('warn', primary_err));
		return;
	}
	if (!primary) {
		add_row_tag(primary_row, create_typed_tag('warn', 'Not Set'));
		return;
	}

	// primary exists
	make_exploded(primary_row, primary, false);

	// lets check if it's normalized
	let primary_norm;
	try {
		primary_norm = ens_normalize(primary);
		if (primary === input) {
			add_row_tag(primary_row, 'Same as Input');
		} else if (primary === name_norm) {		
			add_row_tag(primary_row, 'Same as Norm');
		} else {
			add_row_tag(primary_row, create_copy_btn(primary_norm));
			add_row_tag(primary_row, create_resolve_btn(primary));
			add_row_tag(primary_row, create_ens_link(primary_norm));
			let details_row = create_details_row(primary, true);
			details_row.classList.toggle('old', !!available);
			output_div.append(details_row);
		}
	} catch (err) {
		primary_row.classList.add('error');
		add_row_tag(primary_row, create_typed_tag('norm', err));
	}

	add_old_tag(primary_row, primary);

	// primary was normalized
	if (primary === primary_norm) {
		make_normalized(primary_row, primary_norm);

	// primary was valid but not normalized
	} else if (primary_norm) {
		add_row_tag(primary_row, create_typed_tag('fail', 'Normalized'));
		// create norm row
		let row = create_row('Normalized Primary');
		row.classList.toggle('old', !!available);
		make_exploded(row, primary_norm, true);
		make_normalized(row, primary_norm);
		add_old_tag(primary_row, primary_norm, true);
		add_row_tag(row, create_copy_btn(primary_norm));
		add_row_tag(row, create_ens_link(primary_norm));
		//add_nft_links(row, primary_norm);
		if (name_norm !== primary_norm) {
			add_row_tag(row, create_resolve_btn(primary_norm));
		}
		output_div.append(row);
		let details_row = create_details_row(primary_norm);
		details_row.classList.toggle('old', !!available);
		output_div.append(details_row);
	}	

	if (primary_norm && name_norm === primary_norm) {
		if (owner === address) {
			add_row_tag(normed_row, create_typed_tag('fire', 'Primary Owner'));
		} else {
			add_row_tag(normed_row, create_typed_tag('good', 'Primary'));
		}
	}
}

async function ensure_eth_resolver() {
	if (eth_resolver_contract) return;
	if (eth_resolver_contract === false) throw new Error(`No "${ETH_TLD}" resolver`);	
	let resolver = await active_provider.getResolver(ETH_TLD);
	if (!resolver) {
		eth_resolver_contract = false;
		return ensure_eth_resolver(); 
	}
	eth_resolver_contract = contract_for_resolver(resolver);
}
function contract_for_resolver(resolver) {
	let contract = new ethers.Contract(resolver.address, [
		'function supportsInterface(bytes4 interfaceID) external view returns (bool)',
		'function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address)'
	], active_provider);
	let node = namehash(resolver.name);
	contract.get_interface = hash => contract.callStatic.interfaceImplementer(node, hash);
	return contract;
}
async function price_oracle_from_controller(controller_address) {
	let address = await active_provider.getStorageAt(controller_address, 2);
	address = '0x' + address.slice(-40);
	let contract = new ethers.Contract(address, [
		'function premium(string calldata name, uint256 expires, uint256 duration) external view returns (uint256)',
		'function price(string calldata name, uint256 expires, uint256 duration) external view returns (uint256)',
	], active_provider);
	/*
	totalDays = 21; // FromDigits["15"]
	price0 = 10^(8 + 18) // FromDigits["52b7d2dcc80cd2e4000000", 16]
	price1 = BitShiftRight[price0, totalDays]
	dur = 1814400;  // t /. First@Solve[price0*(1/2)^(t/86400) == price1, t, Reals]
	*/
	contract.premium_period = 1814400; // 21*86400;
	return contract;
}

async function ensure_wrapper() {
	if (wrapper_contract) return;
	if (wrapper_contract === false) throw new Error(`Not implementated`);
	await ensure_eth_resolver();
	let wrapper_address = await eth_resolver_contract.get_interface('0x019a38fe');
	if (is_null_hex(wrapper_address)) {
		wrapper_contract = false;
		return ensure_wrapper();
	}
	wrapper_contract = new ethers.Contract(wrapper_address, [
		'function isWrapped(bytes32 node) public view returns (bool)',
		'function getData(uint256 id) external view returns (address owner, uint32 fuses, uint64 expiry)',
		'function names(bytes32 node) public view returns (bytes)',	
	], active_provider);
}

async function ensure_eth_nft() {
	if (eth_nft_contract) return;
	if (eth_nft_contract === false) throw new Error(`Not implemented`);
	await ensure_eth_resolver();
	let nft_address = await eth_resolver_contract.get_interface('0x80ac58cd');
	if (is_null_hex(nft_address)) {
		eth_nft_contract = false;
		return ensure_eth_nft();
	}
	eth_nft_contract = new ethers.Contract(nft_address, [
		'function available(uint256 id) external view returns(bool)',
		'function nameExpires(uint256 id) external view returns(uint256)',
		'function ownerOf(uint256 id) external view returns (address)',
		'function GRACE_PERIOD() external view returns (uint256)',
	], active_provider);
	const DAY = 86400000;
	eth_nft_contract.grace_period = (await eth_nft_contract.callStatic.GRACE_PERIOD().then(x => 1000 * x.toNumber()).catch(() => DAY * 90));
	eth_nft_contract.warning_period = Math.round(eth_nft_contract.grace_period / 2); // when to show warning in interface
	let controller_address = await eth_resolver_contract.get_interface('0x018fac06');
	price_oracle_contract = await price_oracle_from_controller(controller_address);
}

function is_checksum_address(s) {
	try {
		return s === ethers.utils.getAddress(s);
	} catch (ignored) {		
	}
}
function is_null_hex(s) {
	return /^0x0*$/.test(s);
}
function labelhash(s) {
	//return ethers.utils.id(s);
	return ethers.utils.keccak256(bytes_from_utf8(s));
}
function namehash(s) {
	let hash = '0x0000000000000000000000000000000000000000000000000000000000000000';
	if (s) hash = s.split('.').reduceRight((h, x) => ethers.utils.keccak256(h + labelhash(x).slice(2)), hash);
	return hash.slice(0, 66);
}

function read_local_storage(key, fn, def) {
	let stored = localStorage.getItem(key);
	if (typeof stored === 'string') {
		try {
			fn(JSON.parse(stored));
			return;
		} catch (err) {
		}
	}
	if (def !== undefined) {
		fn(def);
	}
}
</script>
</body>
</html>
